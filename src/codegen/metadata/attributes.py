attributes = {
    'Buffer': {
        6252: {
            'access': 'read-write',
            'c_function_name': 'BufInputBufSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of samples the input buffer can hold for each channel in the task. Zero indicates to allocate no buffer. Use a buffer size of 0 to perform a hardware-timed operation without using a buffer. Setting this property overrides the automatic input buffer allocation that NI-DAQmx performs.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'INPUT_BUF_SIZE',
            'python_class_name': 'DaqBuffer',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        6253: {
            'access': 'read-write',
            'c_function_name': 'BufOutputBufSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of samples the output buffer can hold for each channel in the task. Zero indicates to allocate no buffer. Use a buffer size of 0 to perform a hardware-timed operation without using a buffer. Setting this property overrides the automatic output buffer allocation that NI-DAQmx performs.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OUTPUT_BUF_SIZE',
            'python_class_name': 'DaqBuffer',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        8970: {
            'access': 'read',
            'c_function_name': 'BufInputOnbrdBufSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in samples per channel the size of the onboard input buffer of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'INPUT_ONBRD_BUF_SIZE',
            'python_class_name': 'DaqBuffer',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8971: {
            'access': 'read-write',
            'c_function_name': 'BufOutputOnbrdBufSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies in samples per channel the size of the onboard output buffer of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OUTPUT_ONBRD_BUF_SIZE',
            'python_class_name': 'DaqBuffer',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        }
    },
    'CalibrationInfo': {
        6240: {
            'access': 'read',
            'c_function_name': 'SelfCalSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the device supports self-calibration.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SELF_CAL_SUPPORTED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        6241: {
            'access': 'read-write',
            'c_function_name': 'CalUserDefinedInfo',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies a string that contains arbitrary, user-defined information. This number of characters in this string can be no more than **cal_user_defined_info_max_size**.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CAL_USER_DEFINED_INFO',
            'python_class_name': 'Device',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        6244: {
            'access': 'read',
            'c_function_name': 'SelfCalLastTemp',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates in degrees Celsius the temperature of the device at the time of the last self-calibration. Compare this temperature to the current onboard temperature to determine if you should perform another calibration.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SELF_CAL_LAST_TEMP',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        6247: {
            'access': 'read',
            'c_function_name': 'ExtCalLastTemp',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates in degrees Celsius the temperature of the device at the time of the last external calibration. Compare this temperature to the current onboard temperature to determine if you should perform another calibration.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'EXT_CAL_LAST_TEMP',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        6248: {
            'access': 'read',
            'c_function_name': 'ExtCalRecommendedInterval',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in months the National Instruments recommended interval between each external calibration of the device.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'EXT_CAL_RECOMMENDED_INTERVAL',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        6428: {
            'access': 'read',
            'c_function_name': 'CalUserDefinedInfoMaxSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the maximum length in characters of **cal_user_defined_info**.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CAL_USER_DEFINED_INFO_MAX_SIZE',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8763: {
            'access': 'read',
            'c_function_name': 'CalDevTemp',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates in degrees Celsius the current temperature of the device.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CAL_DEV_TEMP',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12267: {
            'access': 'read-write',
            'c_function_name': 'CalAccConnectionCount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of times a particular connection that results in tangible wear and tear of onboard components has been made on the accessory. This connection count is useful for tracking accessory life and usage.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CAL_ACC_CONNECTION_COUNT',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12268: {
            'access': 'read',
            'c_function_name': 'CalRecommendedAccConnectionCountLimit',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the recommended connection count limit for an accessory. If the accessory connection count exceeds this limit, the accessory could require maintenance.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CAL_RECOMMENDED_ACC_CONNECTION_COUNT_LIMIT',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        }
    },
    'Channel': {
        80: {
            'access': 'read',
            'c_function_name': 'AIRawSampJustification',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the justification of a raw sample from the device.',
            'enum': 'DataJustification1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RAW_SAMP_JUSTIFICATION',
            'python_class_name': 'AIChannel',
            'python_data_type': 'DataJustification1',
            'resettable': False,
            'type': 'int32'
        },
        98: {
            'access': 'read-write',
            'c_function_name': 'AIImpedance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the input impedance of the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_IMPEDANCE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'Impedance1',
            'resettable': True,
            'type': 'float64'
        },
        100: {
            'access': 'read-write',
            'c_function_name': 'AICoupling',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the coupling for the channel.',
            'enum': 'Coupling1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_COUPLING',
            'python_class_name': 'AIChannel',
            'python_data_type': 'Coupling1',
            'resettable': True,
            'type': 'int32'
        },
        104: {
            'access': 'read-write',
            'c_function_name': 'AIDitherEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable dithering.  Dithering adds Gaussian noise to the input signal. You can use dithering to achieve higher resolution measurements by over sampling the input signal and averaging the results.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DITHER_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        135: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of Wheatstone bridge connected to the channel.',
            'enum': 'BridgeConfiguration1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_CFG',
            'python_class_name': 'AIChannel',
            'python_data_type': 'BridgeConfiguration1',
            'resettable': True,
            'type': 'int32'
        },
        148: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeShuntCalEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable a shunt calibration switch. Use **ai_bridge_shunt_cal_select** to select the switch(es) to enable.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SHUNT_CAL_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        257: {
            'access': 'read-write',
            'c_function_name': 'AIACExcitFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the AC excitation frequency in Hertz.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_AC_EXCIT_FREQ',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        258: {
            'access': 'read-write',
            'c_function_name': 'AIACExcitSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize the AC excitation source of the channel to that of another channel. Synchronize the excitation sources of multiple channels to use multichannel sensors. Set this property to False for the master channel and to True for the slave channels.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_AC_EXCIT_SYNC_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        280: {
            'access': 'read-write',
            'c_function_name': 'AOGain',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in decibels the gain factor to apply to the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_GAIN',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        289: {
            'access': 'read-write',
            'c_function_name': 'AOLoadImpedance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the load impedance connected to the analog output channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_LOAD_IMPEDANCE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        304: {
            'access': 'read-write',
            'c_function_name': 'AODACRefConnToGnd',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to ground the internal DAC reference. Grounding the internal DAC reference has the effect of grounding all analog output channels and stopping waveform generation across all analog output channels regardless of whether the channels belong to the current task. You can ground the internal DAC reference only when **aodac_ref_src** is **SourceSelection.INTERNAL** and **aodac_ref_allow_conn_to_gnd** is True.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_REF_CONN_TO_GND',
            'python_class_name': 'AOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        306: {
            'access': 'read-write',
            'c_function_name': 'AODACRefSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the source of the DAC reference voltage. The value of this voltage source determines the full-scale value of the DAC.',
            'enum': 'SourceSelection',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_REF_SRC',
            'python_class_name': 'AOChannel',
            'python_data_type': 'SourceSelection',
            'resettable': True,
            'type': 'int32'
        },
        307: {
            'access': 'read-write',
            'c_function_name': 'AOReglitchEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable reglitching.  The output of a DAC normally glitches whenever the DAC is updated with a new value. The amount of glitching differs from code to code and is generally largest at major code transitions.  Reglitching generates uniform glitch energy at each code transition and provides for more uniform glitches.  Uniform glitch energy makes it easier to filter out the noise introduced from glitching during spectrum analysis.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_REGLITCH_ENABLE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        308: {
            'access': 'read-write',
            'c_function_name': 'AODataXferMech',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the data transfer mode for the device.',
            'enum': 'DataTransferMechanism',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DATA_XFER_MECH',
            'python_class_name': 'AOChannel',
            'python_data_type': 'DataTransferMechanism',
            'resettable': True,
            'type': 'int32'
        },
        322: {
            'access': 'read-write',
            'c_function_name': 'CICtrTimebaseActiveEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether a timebase cycle is from rising edge to rising edge or from falling edge to falling edge.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CTR_TIMEBASE_ACTIVE_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        323: {
            'access': 'read-write',
            'c_function_name': 'CICtrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the timebase to use for the counter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        324: {
            'access': 'read-write',
            'c_function_name': 'CIFreqMeasMeth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the method to use to measure the frequency of the signal.',
            'enum': 'CounterFrequencyMethod',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_MEAS_METH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'CounterFrequencyMethod',
            'resettable': True,
            'type': 'int32'
        },
        325: {
            'access': 'read-write',
            'c_function_name': 'CIFreqMeasTime',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the length of time to measure the frequency of the signal if **ci_freq_meas_meth** is **CounterFrequencyMethod.HIGHFREQ_2_CTR**. Measurement accuracy increases with increased measurement time and with increased signal frequency. If you measure a high-frequency signal for too long, however, the count register could roll over, which results in an incorrect measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_MEAS_TIME',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        327: {
            'access': 'read-write',
            'c_function_name': 'CIFreqDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the value by which to divide the input signal if  **ci_freq_meas_meth** is **CounterFrequencyMethod.LARGERNG_2_CTR**. The larger the divisor, the more accurate the measurement. However, too large a value could cause the count register to roll over, which results in an incorrect measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_DIV',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        328: {
            'access': 'read',
            'c_function_name': 'CICount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the current value of the count register.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        329: {
            'access': 'read',
            'c_function_name': 'CIOutputState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the current state of the out terminal of the counter.',
            'enum': 'Level1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_OUTPUT_STATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Level1',
            'resettable': False,
            'type': 'int32'
        },
        336: {
            'access': 'read',
            'c_function_name': 'CITCReached',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the counter rolled over. When you query this property, NI-DAQmx resets it to False.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TC_REACHED',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        512: {
            'access': 'read-write',
            'c_function_name': 'CIDataXferMech',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the data transfer mode for the channel.',
            'enum': 'DataTransferMechanism',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DATA_XFER_MECH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'DataTransferMechanism',
            'resettable': True,
            'type': 'int32'
        },
        659: {
            'access': 'read',
            'c_function_name': 'COCount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the current value of the count register.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_COUNT',
            'python_class_name': 'COChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        660: {
            'access': 'read',
            'c_function_name': 'COOutputState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the current state of the output terminal of the counter.',
            'enum': 'Level1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_OUTPUT_STATE',
            'python_class_name': 'COChannel',
            'python_data_type': 'Level1',
            'resettable': False,
            'type': 'int32'
        },
        661: {
            'access': 'read-write',
            'c_function_name': 'COAutoIncrCnt',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies a number of timebase ticks by which to increase the time spent in the idle state for each successive pulse.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_AUTO_INCR_CNT',
            'python_class_name': 'COChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        664: {
            'access': 'read-write',
            'c_function_name': 'COPulseTicksInitialDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of ticks to wait before generating the first pulse.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_TICKS_INITIAL_DELAY',
            'python_class_name': 'COChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        665: {
            'access': 'read-write',
            'c_function_name': 'COPulseFreqInitialDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the amount of time to wait before generating the first pulse.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_FREQ_INITIAL_DELAY',
            'python_class_name': 'COChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        825: {
            'access': 'read-write',
            'c_function_name': 'COCtrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the timebase to use for the counter. Typically, NI-DAQmx uses one of the internal counter timebases when generating pulses. Use this property to specify an external timebase and produce custom pulse widths that are not possible using the internal timebases.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CTR_TIMEBASE_SRC',
            'python_class_name': 'COChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        833: {
            'access': 'read-write',
            'c_function_name': 'COCtrTimebaseActiveEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether a timebase cycle is from rising edge to rising edge or from falling edge to falling edge.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CTR_TIMEBASE_ACTIVE_EDGE',
            'python_class_name': 'COChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        1651: {
            'access': 'read-write',
            'c_function_name': 'AIAccelUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return acceleration measurements from the channel.',
            'enum': 'AccelUnits2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ACCEL_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'AccelUnits2',
            'resettable': True,
            'type': 'int32'
        },
        1682: {
            'access': 'read-write',
            'c_function_name': 'AIAccelSensitivity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the accelerometer. This value is in the units you specify with **ai_accel_sensitivity_units**. Refer to the sensor documentation to determine this value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ACCEL_SENSITIVITY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        1685: {
            'access': 'read',
            'c_function_name': 'AIMeasType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the measurement to take with the analog input channel and in some cases, such as for temperature measurements, the sensor to use.',
            'enum': 'AIMeasurementType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_MEAS_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'AIMeasurementType',
            'resettable': False,
            'type': 'int32'
        },
        1686: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesDir',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether to increment or decrement the counter on each edge.',
            'enum': 'CountDirection1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_DIR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'CountDirection1',
            'resettable': True,
            'type': 'int32'
        },
        1687: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesActiveEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edges to increment or decrement the counter.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_ACTIVE_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        1688: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesInitialCnt',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the starting value from which to count.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_INITIAL_CNT',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        1793: {
            'access': 'read-write',
            'c_function_name': 'AICurrentUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return current measurements from the channel.',
            'enum': 'CurrentUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CURRENT_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'CurrentUnits1',
            'resettable': True,
            'type': 'int32'
        },
        1939: {
            'access': 'read-write',
            'c_function_name': 'DIInvertLines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to invert the lines in the channel. If you set this property to True, the lines are at high logic when off and at low logic when on.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_INVERT_LINES',
            'python_class_name': 'DIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        1945: {
            'access': 'read-write',
            'c_function_name': 'CIFreqStartingEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies between which edges to measure the frequency of the signal.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_STARTING_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        2054: {
            'access': 'read-write',
            'c_function_name': 'AIFreqUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return frequency measurements from the channel.',
            'enum': 'FrequencyUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FREQ_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'FrequencyUnits',
            'resettable': True,
            'type': 'int32'
        },
        2068: {
            'access': 'read-write',
            'c_function_name': 'AIFreqHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in volts a window below **ai_freq_thresh_voltage**. The input voltage must pass below **ai_freq_thresh_voltage** minus this value before NI-DAQmx recognizes a waveform repetition at **ai_freq_thresh_voltage**. Hysteresis can improve the measurement accuracy when the signal contains noise or jitter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FREQ_HYST',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        2069: {
            'access': 'read-write',
            'c_function_name': 'AIFreqThreshVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the voltage level at which to recognize waveform repetitions. You should select a voltage level that occurs only once within the entire period of a waveform. You also can select a voltage that occurs only once while the voltage rises or falls.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FREQ_THRESH_VOLTAGE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        2083: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return pulse width measurements.',
            'enum': 'TimeUnits3',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'TimeUnits3',
            'resettable': True,
            'type': 'int32'
        },
        2085: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthStartingEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the input signal to begin each pulse width measurement.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_STARTING_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        2099: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepFirstEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the first signal to start each measurement.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_FIRST_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        2100: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepSecondEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the second signal to stop each measurement.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_SECOND_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        2130: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodStartingEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies between which edges to measure the period of the signal.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_STARTING_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        2165: {
            'access': 'read-write',
            'c_function_name': 'CIAngEncoderPulsesPerRev',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of pulses the encoder generates per revolution. This value is the number of pulses on either signal A or signal B, not the total number of pulses on both signal A and signal B.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ANG_ENCODER_PULSES_PER_REV',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        2167: {
            'access': 'read-write',
            'c_function_name': 'AIRVDTUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return angular position measurements from the channel.',
            'enum': 'AngleUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RVDT_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'AngleUnits1',
            'resettable': True,
            'type': 'int32'
        },
        2177: {
            'access': 'read-write',
            'c_function_name': 'CIAngEncoderInitialAngle',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the starting angle of the encoder. This value is in the units you specify with **ci_ang_encoder_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ANG_ENCODER_INITIAL_ANGLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        2184: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZIndexVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the value to which to reset the measurement when signal Z is high and signal A and signal B are at the states you specify with **ci_encoderz_index_phase**. Specify this value in the units of the measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INDEX_VAL',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        2185: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZIndexPhase',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the states at which signal A and signal B must be while signal Z is high for NI-DAQmx to reset the measurement. If signal Z is never high while signal A and signal B are high, for example, you must choose a phase other than **EncoderZIndexPhase1.AHIGHBHIGH**.',
            'enum': 'EncoderZIndexPhase1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INDEX_PHASE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'EncoderZIndexPhase1',
            'resettable': True,
            'type': 'int32'
        },
        2192: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZIndexEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to use Z indexing for the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INDEX_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        2307: {
            'access': 'read-write',
            'c_function_name': 'AIRVDTSensitivity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the RVDT. This value is in the units you specify with **airvdt_sensitivity_units**. Refer to the sensor documentation to determine this value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RVDT_SENSITIVITY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        2320: {
            'access': 'read-write',
            'c_function_name': 'AILVDTUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return linear position measurements from the channel.',
            'enum': 'LengthUnits2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LVDT_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'LengthUnits2',
            'resettable': True,
            'type': 'int32'
        },
        2321: {
            'access': 'read-write',
            'c_function_name': 'CILinEncoderDistPerPulse',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the distance to measure for each pulse the encoder generates on signal A or signal B. This value is in the units you specify with **ci_lin_encoder_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_LIN_ENCODER_DIST_PER_PULSE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        2325: {
            'access': 'read-write',
            'c_function_name': 'CILinEncoderInitialPos',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the position of the encoder when the measurement begins. This value is in the units you specify with **ci_lin_encoder_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_LIN_ENCODER_INITIAL_POS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        2361: {
            'access': 'read-write',
            'c_function_name': 'AILVDTSensitivity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the LVDT. This value is in the units you specify with **ailvdt_sensitivity_units**. Refer to the sensor documentation to determine this value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LVDT_SENSITIVITY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        2389: {
            'access': 'read-write',
            'c_function_name': 'AIResistanceUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return resistance measurements.',
            'enum': 'ResistanceUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RESISTANCE_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ResistanceUnits1',
            'resettable': True,
            'type': 'int32'
        },
        2433: {
            'access': 'read-write',
            'c_function_name': 'AIStrainUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return strain measurements from the channel.',
            'enum': 'StrainUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_STRAIN_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'StrainUnits1',
            'resettable': True,
            'type': 'int32'
        },
        2434: {
            'access': 'read-write',
            'c_function_name': 'AIStrainGageCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the bridge configuration of the strain gages.',
            'enum': 'StrainGageBridgeType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_STRAIN_GAGE_CFG',
            'python_class_name': 'AIChannel',
            'python_data_type': 'StrainGageBridgeType1',
            'resettable': True,
            'type': 'int32'
        },
        2452: {
            'access': 'read-write',
            'c_function_name': 'AIStrainGageGageFactor',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the strain gage.  Gage factor relates the change in electrical resistance to the change in strain. Refer to the sensor documentation for this value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_STRAIN_GAGE_GAGE_FACTOR',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        2456: {
            'access': 'read-write',
            'c_function_name': 'AIStrainGagePoissonRatio',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the ratio of lateral strain to axial strain in the material you are measuring.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_STRAIN_GAGE_POISSON_RATIO',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4112: {
            'access': 'read-write',
            'c_function_name': 'AIRTDA',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': "Specifies the 'A' constant of the Callendar-Van Dusen equation. NI-DAQmx requires this value when you use a custom RTD.",
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RTD_A',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4113: {
            'access': 'read-write',
            'c_function_name': 'AIRTDB',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': "Specifies the 'B' constant of the Callendar-Van Dusen equation. NI-DAQmx requires this value when you use a custom RTD.",
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RTD_B',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4115: {
            'access': 'read-write',
            'c_function_name': 'AIRTDC',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': "Specifies the 'C' constant of the Callendar-Van Dusen equation. NI-DAQmx requires this value when you use a custom RTD.",
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RTD_C',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4144: {
            'access': 'read-write',
            'c_function_name': 'AIRTDR0',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the sensor resistance at 0 deg C. The Callendar-Van Dusen equation requires this value. Refer to the sensor documentation to determine this value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RTD_R0',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4146: {
            'access': 'read-write',
            'c_function_name': 'AIRTDType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of RTD connected to the channel.',
            'enum': 'RTDType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RTD_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'RTDType1',
            'resettable': True,
            'type': 'int32'
        },
        4147: {
            'access': 'read-write',
            'c_function_name': 'AITempUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return temperature measurements from the channel.',
            'enum': 'TemperatureUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_TEMP_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'TemperatureUnits1',
            'resettable': True,
            'type': 'int32'
        },
        4148: {
            'access': 'read',
            'c_function_name': 'AIThrmcplCJCChan',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the channel that acquires the temperature of the cold junction if **ai_thrmcplcjc_src** is **CJCSource1.CHAN**. If the channel is a temperature channel, NI-DAQmx acquires the temperature in the correct units. Other channel types, such as a resistance channel with a custom sensor, must use a custom scale to scale values to degrees Celsius.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'AI_THRMCPL_CJC_CHAN',
            'object_constructor_params': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'object_has_factory': True,
            'object_module_location': 'nidaqmx._task_modules.channels.channel',
            'object_type': 'Channel',
            'python_class_name': 'AIChannel',
            'python_data_type': 'Channel',
            'resettable': False,
            'type': 'char[]'
        },
        4149: {
            'access': 'read',
            'c_function_name': 'AIThrmcplCJCSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the source of cold-junction compensation.',
            'enum': 'CJCSource1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_THRMCPL_CJC_SRC',
            'python_class_name': 'AIChannel',
            'python_data_type': 'CJCSource1',
            'resettable': False,
            'type': 'int32'
        },
        4150: {
            'access': 'read-write',
            'c_function_name': 'AIThrmcplCJCVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the temperature of the cold junction if **ai_thrmcplcjc_src** is **CJCSource1.CONSTVAL**. Specify this value in the units of the measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_THRMCPL_CJC_VAL',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4176: {
            'access': 'read-write',
            'c_function_name': 'AIThrmcplType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of thermocouple connected to the channel. Thermocouple types differ in composition and measurement range.',
            'enum': 'ThermocoupleType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_THRMCPL_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ThermocoupleType1',
            'resettable': True,
            'type': 'int32'
        },
        4193: {
            'access': 'read-write',
            'c_function_name': 'AIThrmstrR1',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the value of the reference resistor for the thermistor if you use voltage excitation. NI-DAQmx ignores this value for current excitation.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_THRMSTR_R1',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4242: {
            'access': 'read-write',
            'c_function_name': 'CIGPSSyncMethod',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the method to use to synchronize the counter to a GPS receiver.',
            'enum': 'GpsSignalType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_GPS_SYNC_METHOD',
            'python_class_name': 'CIChannel',
            'python_data_type': 'GpsSignalType1',
            'resettable': True,
            'type': 'int32'
        },
        4243: {
            'access': 'read-write',
            'c_function_name': 'CIGPSSyncSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which the GPS synchronization signal is connected.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_GPS_SYNC_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        4244: {
            'access': 'read-write',
            'c_function_name': 'AIVoltageUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return voltage measurements from the channel.',
            'enum': 'VoltageUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_VOLTAGE_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'VoltageUnits1',
            'resettable': True,
            'type': 'int32'
        },
        4247: {
            'access': 'read-write',
            'c_function_name': 'AITermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the terminal configuration for the channel.',
            'enum': 'InputTermCfg',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_TERM_CFG',
            'python_class_name': 'AIChannel',
            'python_data_type': 'InputTermCfg',
            'resettable': True,
            'type': 'int32'
        },
        4360: {
            'access': 'read',
            'c_function_name': 'AOOutputType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates whether the channel generates voltage,  current, or a waveform.',
            'enum': 'AOOutputChannelType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_OUTPUT_TYPE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'AOOutputChannelType',
            'resettable': False,
            'type': 'int32'
        },
        4361: {
            'access': 'read-write',
            'c_function_name': 'AOCurrentUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies in what units to generate current on the channel. Write data to the channel in the units you select.',
            'enum': 'CurrentUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_CURRENT_UNITS',
            'python_class_name': 'AOChannel',
            'python_data_type': 'CurrentUnits1',
            'resettable': True,
            'type': 'int32'
        },
        4403: {
            'access': 'read-write',
            'c_function_name': 'DOInvertLines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to invert the lines in the channel. If you set this property to True, the lines are at high logic when off and at low logic when on.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_INVERT_LINES',
            'python_class_name': 'DOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        4407: {
            'access': 'read-write',
            'c_function_name': 'DOOutputDriveType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the drive type for digital output channels.',
            'enum': 'DigitalDriveType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_OUTPUT_DRIVE_TYPE',
            'python_class_name': 'DOChannel',
            'python_data_type': 'DigitalDriveType',
            'resettable': True,
            'type': 'int32'
        },
        4457: {
            'access': 'read-write',
            'c_function_name': 'COPulseHighTicks',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of ticks the pulse is high.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_HIGH_TICKS',
            'python_class_name': 'COChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        4464: {
            'access': 'read-write',
            'c_function_name': 'COPulseIdleState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the resting state of the output terminal.',
            'enum': 'Level1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_IDLE_STATE',
            'python_class_name': 'COChannel',
            'python_data_type': 'Level1',
            'resettable': True,
            'type': 'int32'
        },
        4465: {
            'access': 'read-write',
            'c_function_name': 'COPulseLowTicks',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of ticks the pulse is low.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_LOW_TICKS',
            'python_class_name': 'COChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        4470: {
            'access': 'read-write',
            'c_function_name': 'COPulseDutyCyc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the duty cycle of the pulses. The duty cycle of a signal is the width of the pulse divided by period. NI-DAQmx uses this ratio and the pulse frequency to determine the width of the pulses and the delay between pulses.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_DUTY_CYC',
            'python_class_name': 'COChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4472: {
            'access': 'read-write',
            'c_function_name': 'COPulseFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the frequency of the pulses to generate. This value is in the units you specify with **co_pulse_freq_units** or when you create the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_FREQ',
            'python_class_name': 'COChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4484: {
            'access': 'read-write',
            'c_function_name': 'AOVoltageUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies in what units to generate voltage on the channel. Write data to the channel in the units you select.',
            'enum': 'VoltageUnits2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_VOLTAGE_UNITS',
            'python_class_name': 'AOChannel',
            'python_data_type': 'VoltageUnits2',
            'resettable': True,
            'type': 'int32'
        },
        4486: {
            'access': 'read-write',
            'c_function_name': 'AOMax',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the maximum value you expect to generate. The value is in the units you specify with a units property. If you try to write a value larger than the maximum value, NI-DAQmx generates an error. NI-DAQmx might coerce this value to a smaller value if other task settings restrict the device from generating the desired maximum.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_MAX',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4487: {
            'access': 'read-write',
            'c_function_name': 'AOMin',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the minimum value you expect to generate. The value is in the units you specify with a units property. If you try to write a value smaller than the minimum value, NI-DAQmx generates an error. NI-DAQmx might coerce this value to a larger value if other task settings restrict the device from generating the desired minimum.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_MIN',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4488: {
            'access': 'read-write',
            'c_function_name': 'AOCustomScaleName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a custom scale for the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'AO_CUSTOM_SCALE_NAME',
            'object_module_location': 'nidaqmx.system.scale',
            'object_type': 'Scale',
            'python_class_name': 'AOChannel',
            'python_data_type': 'Scale',
            'resettable': True,
            'type': 'char[]'
        },
        5264: {
            'access': 'read-write',
            'c_function_name': 'AOOutputImpedance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the impedance of the analog output stage of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_OUTPUT_IMPEDANCE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5416: {
            'access': 'read-write',
            'c_function_name': 'AISoundPressureUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return sound pressure measurements from the channel.',
            'enum': 'SoundPressureUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_SOUND_PRESSURE_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'SoundPressureUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5430: {
            'access': 'read-write',
            'c_function_name': 'AIMicrophoneSensitivity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the microphone. This value is in mV/Pa. Refer to the sensor documentation to determine this value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_MICROPHONE_SENSITIVITY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5984: {
            'access': 'read-write',
            'c_function_name': 'AIAutoZeroMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies how often to measure ground. NI-DAQmx subtracts the measured ground voltage from every sample.',
            'enum': 'AutoZeroType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_AUTO_ZERO_MODE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'AutoZeroType1',
            'resettable': True,
            'type': 'int32'
        },
        5988: {
            'access': 'read',
            'c_function_name': 'AIResolutionUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the units of **ai_resolution**.',
            'enum': 'ResolutionType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RESOLUTION_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ResolutionType1',
            'resettable': False,
            'type': 'int32'
        },
        5989: {
            'access': 'read',
            'c_function_name': 'AIResolution',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the resolution of the analog-to-digital converter of the channel. This value is in the units you specify with **ai_resolution_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RESOLUTION',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        6109: {
            'access': 'read-write',
            'c_function_name': 'AIMax',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the maximum value you expect to measure. This value is in the units you specify with a units property. When you query this property, it returns the coerced maximum value that the device can measure with the current settings.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_MAX',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6110: {
            'access': 'read-write',
            'c_function_name': 'AIMin',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the minimum value you expect to measure. This value is in the units you specify with a units property.  When you query this property, it returns the coerced minimum value that the device can measure with the current settings.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_MIN',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6112: {
            'access': 'read-write',
            'c_function_name': 'AICustomScaleName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a custom scale for the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'AI_CUSTOM_SCALE_NAME',
            'object_module_location': 'nidaqmx.system.scale',
            'object_type': 'Scale',
            'python_class_name': 'AIChannel',
            'python_data_type': 'Scale',
            'resettable': True,
            'type': 'char[]'
        },
        6114: {
            'access': 'read-write',
            'c_function_name': 'AIVoltageACRMSUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return voltage RMS measurements from the channel.',
            'enum': 'VoltageUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_VOLTAGE_ACRMS_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'VoltageUnits1',
            'resettable': True,
            'type': 'int32'
        },
        6115: {
            'access': 'read-write',
            'c_function_name': 'AICurrentACRMSUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return current RMS measurements from the channel.',
            'enum': 'CurrentUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CURRENT_ACRMS_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'CurrentUnits1',
            'resettable': True,
            'type': 'int32'
        },
        6124: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeNomResistance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the resistance of the bridge while not under load.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_NOM_RESISTANCE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6125: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeInitialVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in volts the output voltage of the bridge while not under load. NI-DAQmx subtracts this value from any measurements before applying scaling equations.  If you set **ai_bridge_initial_ratio**, NI-DAQmx coerces this property to **ai_bridge_initial_ratio** times **ai_excit_actual_val**. This property is set by DAQmx Perform Bridge Offset Nulling Calibration. If you set this property, NI-DAQmx coerces **ai_bridge_initial_ratio** to the value of this property divided by **ai_excit_actual_val**. If you set both this property and **ai_bridge_initial_ratio**, and their values conflict, NI-DAQmx returns an error. To avoid this error, reset one property to its default value before setting the other.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_INITIAL_VOLTAGE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6126: {
            'access': 'read-write',
            'c_function_name': 'AILeadWireResistance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the resistance of the wires that lead to the sensor.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LEAD_WIRE_RESISTANCE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6129: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeBalanceCoarsePot',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies by how much to compensate for offset in the signal. This value can be between 0 and 127.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_BALANCE_COARSE_POT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'int32'
        },
        6130: {
            'access': 'read-write',
            'c_function_name': 'AICurrentShuntLoc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the shunt resistor location for current measurements.',
            'enum': 'CurrentShuntResistorLocation1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CURRENT_SHUNT_LOC',
            'python_class_name': 'AIChannel',
            'python_data_type': 'CurrentShuntResistorLocation1',
            'resettable': True,
            'type': 'int32'
        },
        6131: {
            'access': 'read-write',
            'c_function_name': 'AICurrentShuntResistance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the external shunt resistance for current measurements.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CURRENT_SHUNT_RESISTANCE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6132: {
            'access': 'read-write',
            'c_function_name': 'AIExcitSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the source of excitation.',
            'enum': 'ExcitationSource',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EXCIT_SRC',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ExcitationSource',
            'resettable': True,
            'type': 'int32'
        },
        6133: {
            'access': 'read-write',
            'c_function_name': 'AIExcitVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the amount of excitation that the sensor requires. If **ai_excit_voltage_or_current** is  **ExcitationVoltageOrCurrent.VOLTAGE**, this value is in volts. If **ai_excit_voltage_or_current** is  **ExcitationVoltageOrCurrent.CURRENT**, this value is in amperes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EXCIT_VAL',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6134: {
            'access': 'read-write',
            'c_function_name': 'AIExcitVoltageOrCurrent',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies if the channel uses current or voltage excitation.',
            'enum': 'ExcitationVoltageOrCurrent',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EXCIT_VOLTAGE_OR_CURRENT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ExcitationVoltageOrCurrent',
            'resettable': True,
            'type': 'int32'
        },
        6139: {
            'access': 'read-write',
            'c_function_name': 'AIExcitDCorAC',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies if the excitation supply is DC or AC.',
            'enum': 'ExcitationDCorAC',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EXCIT_D_COR_AC',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ExcitationDCorAC',
            'resettable': True,
            'type': 'int32'
        },
        6140: {
            'access': 'read-write',
            'c_function_name': 'AIExcitUseForScaling',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies if NI-DAQmx divides the measurement by the excitation. You should typically set this property to True for ratiometric transducers. If you set this property to True, set **ai_max** and **ai_min** to reflect the scaling.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EXCIT_USE_FOR_SCALING',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6145: {
            'access': 'read-write',
            'c_function_name': 'AIAtten',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the amount of attenuation to use.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ATTEN',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6146: {
            'access': 'read-write',
            'c_function_name': 'AILowpassEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable the lowpass filter of the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LOWPASS_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6147: {
            'access': 'read-write',
            'c_function_name': 'AILowpassCutoffFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the frequency in Hertz that corresponds to the -3dB cutoff of the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LOWPASS_CUTOFF_FREQ',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6150: {
            'access': 'read-write',
            'c_function_name': 'AIHighpassEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Enables the filter.  Set to false to bypass the filter if supported.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_HIGHPASS_ENABLE',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6151: {
            'access': 'read-write',
            'c_function_name': 'AIHighpassCutoffFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'The frequency corresponding to the -3dB cutoff of the filter in Hz.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_HIGHPASS_CUTOFF_FREQ',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6152: {
            'access': 'read-write',
            'c_function_name': 'AIHighpassType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The type of filter.',
            'enum': 'FilterType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_HIGHPASS_TYPE',
            'python_class_name': 'N/A',
            'python_data_type': 'FilterType1',
            'resettable': True,
            'type': 'int32'
        },
        6153: {
            'access': 'read-write',
            'c_function_name': 'AIHighpassOrder',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'The filter order.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_HIGHPASS_ORDER',
            'python_class_name': 'N/A',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        6155: {
            'access': 'read-write',
            'c_function_name': 'AIBandpassEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Enables the filter.  Set to false to bypass the filter if supported.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BANDPASS_ENABLE',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6156: {
            'access': 'read-write',
            'c_function_name': 'AIBandpassCenterFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'The center frequency of the filter in Hz.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BANDPASS_CENTER_FREQ',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6157: {
            'access': 'read-write',
            'c_function_name': 'AIBandpassType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The type of filter.',
            'enum': 'FilterType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BANDPASS_TYPE',
            'python_class_name': 'N/A',
            'python_data_type': 'FilterType1',
            'resettable': True,
            'type': 'int32'
        },
        6158: {
            'access': 'read-write',
            'c_function_name': 'AIBandpassWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'The 3dB width of the filter in Hz.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BANDPASS_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6160: {
            'access': 'read-write',
            'c_function_name': 'AINotchCenterFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'The center frequency of the filter in Hz.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_NOTCH_CENTER_FREQ',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6161: {
            'access': 'read-write',
            'c_function_name': 'AINotchType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The type of filter.',
            'enum': 'FilterType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_NOTCH_TYPE',
            'python_class_name': 'N/A',
            'python_data_type': 'FilterType1',
            'resettable': True,
            'type': 'int32'
        },
        6162: {
            'access': 'read-write',
            'c_function_name': 'AINotchWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'The 3dB width of the filter in Hz.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_NOTCH_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6165: {
            'access': 'read-write',
            'c_function_name': 'AIRngHigh',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the upper limit of the input range of the device. This value is in the native units of the device. On E Series devices, for example, the native units is volts.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RNG_HIGH',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6166: {
            'access': 'read-write',
            'c_function_name': 'AIRngLow',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the lower limit of the input range of the device. This value is in the native units of the device. On E Series devices, for example, the native units is volts.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RNG_LOW',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6168: {
            'access': 'read-write',
            'c_function_name': 'AIGain',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a gain factor to apply to the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_GAIN',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6170: {
            'access': 'read-write',
            'c_function_name': 'AISampAndHoldEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable the sample and hold circuitry of the device. When you disable sample and hold circuitry, a small voltage offset might be introduced into the signal.  You can eliminate this offset by using **ai_auto_zero_mode** to perform an auto zero on the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_SAMP_AND_HOLD_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6177: {
            'access': 'read-write',
            'c_function_name': 'AIDataXferMech',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the data transfer mode for the device.',
            'enum': 'DataTransferMechanism',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DATA_XFER_MECH',
            'python_class_name': 'AIChannel',
            'python_data_type': 'DataTransferMechanism',
            'resettable': True,
            'type': 'int32'
        },
        6187: {
            'access': 'read-write',
            'c_function_name': 'AOResolutionUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **ao_resolution**.',
            'enum': 'ResolutionType1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_RESOLUTION_UNITS',
            'python_class_name': 'AOChannel',
            'python_data_type': 'ResolutionType1',
            'resettable': True,
            'type': 'int32'
        },
        6188: {
            'access': 'read',
            'c_function_name': 'AOResolution',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the resolution of the digital-to-analog converter of the channel. This value is in the units you specify with **ao_resolution_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_RESOLUTION',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        6189: {
            'access': 'read-write',
            'c_function_name': 'AODACRngLow',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the lower limit of the output range of the device. This value is in the native units of the device. On E Series devices, for example, the native units is volts.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_RNG_LOW',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6190: {
            'access': 'read-write',
            'c_function_name': 'AODACRngHigh',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the upper limit of the output range of the device. This value is in the native units of the device. On E Series devices, for example, the native units is volts.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_RNG_HIGH',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6192: {
            'access': 'read-write',
            'c_function_name': 'AODACRefAllowConnToGnd',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to allow grounding the internal DAC reference at run time. You must set this property to True and set **aodac_ref_src** to **SourceSelection.INTERNAL** before you can set **aodac_ref_conn_to_gnd** to True.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_REF_ALLOW_CONN_TO_GND',
            'python_class_name': 'AOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6194: {
            'access': 'read-write',
            'c_function_name': 'AODACRefVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in volts the value of the DAC reference voltage. This voltage determines the full-scale range of the DAC. Smaller reference voltages result in smaller ranges, but increased resolution.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_REF_VAL',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6202: {
            'access': 'read-write',
            'c_function_name': 'AOUseOnlyOnBrdMem',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to write samples directly to the onboard memory of the device, bypassing the memory buffer. Generally, you cannot update onboard memory directly after you start the task. Onboard memory includes data FIFOs.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_USE_ONLY_ON_BRD_MEM',
            'python_class_name': 'AOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6204: {
            'access': 'read-write',
            'c_function_name': 'AODataXferReqCond',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies under what condition to transfer data from the buffer to the onboard memory of the device.',
            'enum': 'OutputDataTransferCondition',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DATA_XFER_REQ_COND',
            'python_class_name': 'AOChannel',
            'python_data_type': 'OutputDataTransferCondition',
            'resettable': True,
            'type': 'int32'
        },
        6271: {
            'access': 'read',
            'c_function_name': 'ChanType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the type of the virtual channel.',
            'enum': 'ChannelType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CHAN_TYPE',
            'python_class_name': 'Channel',
            'python_data_type': 'ChannelType',
            'resettable': False,
            'type': 'int32'
        },
        6273: {
            'access': 'read-write',
            'c_function_name': 'AIResistanceCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the resistance configuration for the channel. NI-DAQmx uses this value for any resistance-based measurements, including temperature measurement using a thermistor or RTD.',
            'enum': 'ResistanceConfiguration',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RESISTANCE_CFG',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ResistanceConfiguration',
            'resettable': True,
            'type': 'int32'
        },
        6275: {
            'access': 'read-write',
            'c_function_name': 'AIExcitActualVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the actual amount of excitation supplied by an internal excitation source.  If you read an internal excitation source more precisely with an external device, set this property to the value you read.  NI-DAQmx ignores this value for external excitation. When performing shunt calibration, some devices set this property automatically.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EXCIT_ACTUAL_VAL',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6276: {
            'access': 'read-write',
            'c_function_name': 'AILowpassSwitchCapClkSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the source of the filter clock. If you need a higher resolution for the filter, you can supply an external clock to increase the resolution. Refer to the SCXI-1141/1142/1143 User Manual for more information.',
            'enum': 'SourceSelection',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LOWPASS_SWITCH_CAP_CLK_SRC',
            'python_class_name': 'AIChannel',
            'python_data_type': 'SourceSelection',
            'resettable': True,
            'type': 'int32'
        },
        6277: {
            'access': 'read-write',
            'c_function_name': 'AILowpassSwitchCapExtClkFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the frequency of the external clock when you set **ai_lowpass_switch_cap_clk_src** to **SourceSelection.EXTERNAL**.  NI-DAQmx uses this frequency to set the pre- and post- filters on the SCXI-1141, SCXI-1142, and SCXI-1143. On those devices, NI-DAQmx determines the filter cutoff by using the equation f/(100*n), where f is the external frequency, and n is the external clock divisor. Refer to the SCXI-1141/1142/1143 User Manual for more information.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LOWPASS_SWITCH_CAP_EXT_CLK_FREQ',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6278: {
            'access': 'read-write',
            'c_function_name': 'AILowpassSwitchCapExtClkDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the divisor for the external clock when you set **ai_lowpass_switch_cap_clk_src** to **SourceSelection.EXTERNAL**. On the SCXI-1141, SCXI-1142, and SCXI-1143, NI-DAQmx determines the filter cutoff by using the equation f/(100*n), where f is the external frequency, and n is the external clock divisor. Refer to the SCXI-1141/1142/1143 User Manual for more information.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LOWPASS_SWITCH_CAP_EXT_CLK_DIV',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        6279: {
            'access': 'read-write',
            'c_function_name': 'AILowpassSwitchCapOutClkDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the divisor for the output clock.  NI-DAQmx uses the cutoff frequency to determine the output clock frequency. Refer to the SCXI-1141/1142/1143 User Manual for more information.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LOWPASS_SWITCH_CAP_OUT_CLK_DIV',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        6283: {
            'access': 'read-write',
            'c_function_name': 'AIDataXferReqCond',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies under what condition to transfer data from the onboard memory of the device to the buffer.',
            'enum': 'InputDataTransferCondition',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DATA_XFER_REQ_COND',
            'python_class_name': 'AIChannel',
            'python_data_type': 'InputDataTransferCondition',
            'resettable': True,
            'type': 'int32'
        },
        6284: {
            'access': 'read-write',
            'c_function_name': 'AIMemMapEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies for NI-DAQmx to map hardware registers to the memory space of the application, if possible. Normally, NI-DAQmx maps hardware registers to memory accessible only to the kernel. Mapping the registers to the memory space of the application increases performance. However, if the application accesses the memory space mapped to the registers, it can adversely affect the operation of the device and possibly result in a system crash.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_MEM_MAP_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6286: {
            'access': 'read-write',
            'c_function_name': 'AOTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the terminal configuration of the channel.',
            'enum': 'OutputTermCfg',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_TERM_CFG',
            'python_class_name': 'AOChannel',
            'python_data_type': 'OutputTermCfg',
            'resettable': True,
            'type': 'int32'
        },
        6287: {
            'access': 'read-write',
            'c_function_name': 'AOMemMapEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies for NI-DAQmx to map hardware registers to the memory space of the application, if possible. Normally, NI-DAQmx maps hardware registers to memory accessible only to the kernel. Mapping the registers to the memory space of the application increases performance. However, if the application accesses the memory space mapped to the registers, it can adversely affect the operation of the device and possibly result in a system crash.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_MEM_MAP_ENABLE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6288: {
            'access': 'read-write',
            'c_function_name': 'DITristate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to tristate the lines in the channel. If you set this property to True, NI-DAQmx tristates the lines in the channel. If you set this property to False, NI-DAQmx does not modify the configuration of the lines even if the lines were previously tristated. Set this property to False to read lines in other tasks or to read output-only lines.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_TRISTATE',
            'python_class_name': 'DIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6300: {
            'access': 'read-write',
            'c_function_name': 'CIMax',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the maximum value you expect to measure. This value is in the units you specify with a units property. When you query this property, it returns the coerced maximum value that the hardware can measure with the current settings.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_MAX',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6301: {
            'access': 'read-write',
            'c_function_name': 'CIMin',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the minimum value you expect to measure. This value is in the units you specify with a units property. When you query this property, it returns the coerced minimum value that the hardware can measure with the current settings.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_MIN',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6302: {
            'access': 'read-write',
            'c_function_name': 'CICustomScaleName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a custom scale for the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'CI_CUSTOM_SCALE_NAME',
            'object_module_location': 'nidaqmx.system.scale',
            'object_type': 'Scale',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Scale',
            'resettable': True,
            'type': 'char[]'
        },
        6304: {
            'access': 'read',
            'c_function_name': 'CIMeasType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the measurement to take with the channel.',
            'enum': 'CIMeasurementType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_MEAS_TYPE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'CIMeasurementType',
            'resettable': False,
            'type': 'int32'
        },
        6305: {
            'access': 'read-write',
            'c_function_name': 'CIFreqUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return frequency measurements.',
            'enum': 'FrequencyUnits3',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'FrequencyUnits3',
            'resettable': True,
            'type': 'int32'
        },
        6306: {
            'access': 'read-write',
            'c_function_name': 'CIFreqTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6307: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the unit to use to return period measurements.',
            'enum': 'TimeUnits3',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'TimeUnits3',
            'resettable': True,
            'type': 'int32'
        },
        6308: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6310: {
            'access': 'read-write',
            'c_function_name': 'CIAngEncoderUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return angular position measurements from the channel.',
            'enum': 'AngleUnits2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ANG_ENCODER_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'AngleUnits2',
            'resettable': True,
            'type': 'int32'
        },
        6313: {
            'access': 'read-write',
            'c_function_name': 'CILinEncoderUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return linear encoder measurements from the channel.',
            'enum': 'LengthUnits3',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_LIN_ENCODER_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LengthUnits3',
            'resettable': True,
            'type': 'int32'
        },
        6314: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6316: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return two-edge separation measurements from the channel.',
            'enum': 'TimeUnits3',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'TimeUnits3',
            'resettable': True,
            'type': 'int32'
        },
        6317: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepFirstTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the source terminal of the digital signal that starts each measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_FIRST_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6318: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepSecondTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the source terminal of the digital signal that stops each measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_SECOND_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6319: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return semi-period measurements.',
            'enum': 'TimeUnits3',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'TimeUnits3',
            'resettable': True,
            'type': 'int32'
        },
        6320: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6322: {
            'access': 'read-write',
            'c_function_name': 'CICtrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in Hertz the frequency of the counter timebase. Specifying the rate of a counter timebase allows you to take measurements in terms of time or frequency rather than in ticks of the timebase. If you use an external timebase and do not specify the rate, you can take measurements only in terms of ticks of the timebase.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6323: {
            'access': 'read-write',
            'c_function_name': 'CICtrTimebaseMasterTimebaseDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the divisor for an external counter timebase. You can divide the counter timebase in order to measure slower signals without causing the count register to roll over.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CTR_TIMEBASE_MASTER_TIMEBASE_DIV',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        6325: {
            'access': 'read',
            'c_function_name': 'COOutputType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates how to define pulses generated on the channel.',
            'enum': 'COOutputType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_OUTPUT_TYPE',
            'python_class_name': 'COChannel',
            'python_data_type': 'COOutputType',
            'resettable': False,
            'type': 'int32'
        },
        6330: {
            'access': 'read-write',
            'c_function_name': 'COPulseHighTime',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the amount of time that the pulse is at a high voltage. This value is in the units you specify with **co_pulse_time_units** or when you create the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_HIGH_TIME',
            'python_class_name': 'COChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6331: {
            'access': 'read-write',
            'c_function_name': 'COPulseLowTime',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the amount of time that the pulse is at a low voltage. This value is in the units you specify with **co_pulse_time_units** or when you create the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_LOW_TIME',
            'python_class_name': 'COChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6332: {
            'access': 'read-write',
            'c_function_name': 'COPulseTimeInitialDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the amount of time to wait before generating the first pulse.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_TIME_INITIAL_DELAY',
            'python_class_name': 'COChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6338: {
            'access': 'read-write',
            'c_function_name': 'COCtrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in Hertz the frequency of the counter timebase. Specifying the rate of a counter timebase allows you to define output pulses in seconds rather than in ticks of the timebase. If you use an external timebase and do not specify the rate, you can define output pulses only in ticks of the timebase.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CTR_TIMEBASE_RATE',
            'python_class_name': 'COChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6339: {
            'access': 'read-write',
            'c_function_name': 'COCtrTimebaseMasterTimebaseDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the divisor for an external counter timebase. You can divide the counter timebase in order to generate slower signals without causing the count register to roll over.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CTR_TIMEBASE_MASTER_TIMEBASE_DIV',
            'python_class_name': 'COChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        6343: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6345: {
            'access': 'read-write',
            'c_function_name': 'AIThrmstrA',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': "Specifies the 'A' constant of the Steinhart-Hart thermistor equation.",
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_THRMSTR_A',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6346: {
            'access': 'read-write',
            'c_function_name': 'AIThrmstrC',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': "Specifies the 'C' constant of the Steinhart-Hart thermistor equation.",
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_THRMSTR_C',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6347: {
            'access': 'read-write',
            'c_function_name': 'AIThrmstrB',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': "Specifies the 'B' constant of the Steinhart-Hart thermistor equation.",
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_THRMSTR_B',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6349: {
            'access': 'read-write',
            'c_function_name': 'AIACExcitWireMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the number of leads on the LVDT or RVDT. Some sensors require you to tie leads together to create a four- or five- wire sensor. Refer to the sensor documentation for more information.',
            'enum': 'ACExcitWireMode',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_AC_EXCIT_WIRE_MODE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ACExcitWireMode',
            'resettable': True,
            'type': 'int32'
        },
        6357: {
            'access': 'read-write',
            'c_function_name': 'COPulseFreqUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units in which to define pulse frequency.',
            'enum': 'FrequencyUnits2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_FREQ_UNITS',
            'python_class_name': 'COChannel',
            'python_data_type': 'FrequencyUnits2',
            'resettable': True,
            'type': 'int32'
        },
        6358: {
            'access': 'read-write',
            'c_function_name': 'COPulseTimeUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units in which to define high and low pulse time.',
            'enum': 'TimeUnits2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_TIME_UNITS',
            'python_class_name': 'COChannel',
            'python_data_type': 'TimeUnits2',
            'resettable': True,
            'type': 'int32'
        },
        6369: {
            'access': 'read-write',
            'c_function_name': 'COPulseTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies on which terminal to generate pulses.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_TERM',
            'python_class_name': 'COChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6387: {
            'access': 'read-write',
            'c_function_name': 'DOTristate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to stop driving the channel and set it to a high-impedance state. You must commit the task for this setting to take effect.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_TRISTATE',
            'python_class_name': 'DOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6388: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeBalanceFinePot',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies by how much to compensate for offset in the signal. This value can be between 0 and 4095.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_BALANCE_FINE_POT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'int32'
        },
        6389: {
            'access': 'read-write',
            'c_function_name': 'PhysicalChanName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of the physical channel upon which this virtual channel is based.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'PHYSICAL_CHAN_NAME',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Channel',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        6392: {
            'access': 'read-write',
            'c_function_name': 'AIForceReadFromChan',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to read from the channel if it is a cold-junction compensation channel. By default, DAQmx Read does not return data from cold-junction compensation channels.  Setting this property to True forces read operations to return the cold-junction compensation channel data with the other channels in the task.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FORCE_READ_FROM_CHAN',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6414: {
            'access': 'read',
            'c_function_name': 'COPulseDone',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the task completed pulse generation. Use this value for retriggerable pulse generation when you need to determine if the device generated the current pulse. For retriggerable tasks, when you query this property, NI-DAQmx resets it to False.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PULSE_DONE',
            'python_class_name': 'COChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        6438: {
            'access': 'read-write',
            'c_function_name': 'ChanDescr',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies a user-defined description for the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CHAN_DESCR',
            'python_class_name': 'Channel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6444: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodMeasMeth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the method to use to measure the period of the signal.',
            'enum': 'CounterFrequencyMethod',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_MEAS_METH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'CounterFrequencyMethod',
            'resettable': True,
            'type': 'int32'
        },
        6445: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodMeasTime',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the length of time to measure the period of the signal if **ci_period_meas_meth** is **CounterFrequencyMethod.HIGHFREQ_2_CTR**. Measurement accuracy increases with increased measurement time and with increased signal frequency. If you measure a high-frequency signal for too long, however, the count register could roll over, which results in an incorrect measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_MEAS_TIME',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6446: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the value by which to divide the input signal if **ci_period_meas_meth** is **CounterFrequencyMethod.LARGERNG_2_CTR**. The larger the divisor, the more accurate the measurement. However, too large a value could cause the count register to roll over, which results in an incorrect measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_DIV',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        6448: {
            'access': 'read',
            'c_function_name': 'AIDevScalingCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the coefficients of a polynomial equation that NI-DAQmx uses to scale values from the native format of the device to volts. Each element of the list corresponds to a term of the equation. For example, if index two of the list is 4, the third term of the equation is 4x^2. Scaling coefficients do not account for any custom scales or sensors contained by the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_DEV_SCALING_COEFF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        6449: {
            'access': 'read',
            'c_function_name': 'AODevScalingCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the coefficients of a linear equation that NI-DAQmx uses to scale values from a voltage to the native format of the device. Each element of the list corresponds to a term of the equation. The first element of the list corresponds to the y-intercept, and the second element corresponds to the slope. Scaling coefficients do not account for any custom scales that may be applied to the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AO_DEV_SCALING_COEFF',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        6460: {
            'access': 'read',
            'c_function_name': 'CINumPossiblyInvalidSamps',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of samples that the device might have overwritten before it could transfer them to the buffer.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_NUM_POSSIBLY_INVALID_SAMPS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        6463: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeShuntCalGainAdjust',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the result of a shunt calibration. This property is set by DAQmx Perform Shunt Calibration. NI-DAQmx multiplies data read from the channel by the value of this property. This value should be close to 1.0.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SHUNT_CAL_GAIN_ADJUST',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8568: {
            'access': 'read',
            'c_function_name': 'DINumLines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of digital lines in the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_NUM_LINES',
            'python_class_name': 'DIChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8569: {
            'access': 'read',
            'c_function_name': 'DONumLines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of digital lines in the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_NUM_LINES',
            'python_class_name': 'DOChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8576: {
            'access': 'read-write',
            'c_function_name': 'AIExcitUseMultiplexed',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies if the SCXI-1122 multiplexes the excitation to the upper half of the channels as it advances through the scan list.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EXCIT_USE_MULTIPLEXED',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8600: {
            'access': 'read-write',
            'c_function_name': 'AIInputSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the source of the channel. You can use the signal from the I/O connector or one of several calibration signals. Certain devices have a single calibration signal bus. For these devices, you must specify the same calibration signal for all channels you connect to a calibration signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_INPUT_SRC',
            'python_class_name': 'AIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8602: {
            'access': 'read-write',
            'c_function_name': 'AILVDTSensitivityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **ailvdt_sensitivity**.',
            'enum': 'LVDTSensitivityUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LVDT_SENSITIVITY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'LVDTSensitivityUnits1',
            'resettable': True,
            'type': 'int32'
        },
        8603: {
            'access': 'read-write',
            'c_function_name': 'AIRVDTSensitivityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **airvdt_sensitivity**.',
            'enum': 'RVDTSensitivityUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RVDT_SENSITIVITY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'RVDTSensitivityUnits1',
            'resettable': True,
            'type': 'int32'
        },
        8604: {
            'access': 'read-write',
            'c_function_name': 'AIAccelSensitivityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **ai_accel_sensitivity**.',
            'enum': 'AccelSensitivityUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ACCEL_SENSITIVITY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'AccelSensitivityUnits1',
            'resettable': True,
            'type': 'int32'
        },
        8605: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderAInputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which signal A is connected.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_A_INPUT_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8606: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderBInputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which signal B is connected.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_B_INPUT_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8607: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZInputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which signal Z is connected.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INPUT_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8620: {
            'access': 'read-write',
            'c_function_name': 'CIDupCountPrevent',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable duplicate count prevention for the channel. Duplicate count prevention is enabled by default. Setting  **ci_prescaler** disables duplicate count prevention unless you explicitly enable it.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DUP_COUNT_PREVENT',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8661: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeShuntCalSelect',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies which shunt calibration switch(es) to enable.  Use **ai_bridge_shunt_cal_enable** to enable the switch(es) you specify with this property.',
            'enum': 'ShuntCalSelect',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SHUNT_CAL_SELECT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ShuntCalSelect',
            'resettable': True,
            'type': 'int32'
        },
        8662: {
            'access': 'read-write',
            'c_function_name': 'DIDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable the digital filter for the line(s) or port(s). You can enable the filter on a line-by-line basis. You do not have to enable the filter for all lines in a channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_DIG_FLTR_ENABLE',
            'python_class_name': 'DIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8663: {
            'access': 'read-write',
            'c_function_name': 'DIDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes as a valid high or low state transition.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'DIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8672: {
            'access': 'read',
            'c_function_name': 'AITEDSUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the units defined by TEDS information associated with the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_TEDS_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        8673: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesDirTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the source terminal of the digital signal that controls the count direction if **ci_count_edges_dir** is **CountDirection1.EXTCONTROLLED**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_DIR_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8678: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderDecodingType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies how to count and interpret the pulses the encoder generates on signal A and signal B. **EncoderType2.X_1**, **EncoderType2.X_2**, and **EncoderType2.X_4** are valid for quadrature encoders only. **EncoderType2.TWOPULSECOUNTING** is valid for two-pulse encoders only.',
            'enum': 'EncoderType2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_DECODING_TYPE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'EncoderType2',
            'resettable': True,
            'type': 'int32'
        },
        8679: {
            'access': 'read-write',
            'c_function_name': 'CIFreqDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8680: {
            'access': 'read-write',
            'c_function_name': 'CIFreqDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8681: {
            'access': 'read-write',
            'c_function_name': 'CIFreqDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8682: {
            'access': 'read-write',
            'c_function_name': 'CIFreqDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8683: {
            'access': 'read-write',
            'c_function_name': 'CIFreqDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8684: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8685: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8686: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8687: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8688: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8689: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountDirDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_DIR_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8690: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountDirDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_DIR_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8691: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountDirDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_DIR_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8692: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountDirDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_DIR_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8693: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountDirDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_DIR_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8694: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8695: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8696: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8697: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8698: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8699: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderAInputDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_A_INPUT_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8700: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderAInputDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_A_INPUT_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8701: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderAInputDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_A_INPUT_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8702: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderAInputDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_A_INPUT_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8703: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderAInputDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_A_INPUT_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8704: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderBInputDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_B_INPUT_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8705: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderBInputDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_B_INPUT_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8706: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderBInputDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_B_INPUT_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8707: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderBInputDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_B_INPUT_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8708: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderBInputDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_B_INPUT_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8709: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZInputDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INPUT_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8710: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZInputDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INPUT_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8711: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZInputDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INPUT_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8712: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZInputDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INPUT_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8713: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZInputDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INPUT_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8714: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8715: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8716: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8717: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8718: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8719: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepFirstDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_FIRST_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8720: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepFirstDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_FIRST_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8721: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepFirstDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_FIRST_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8722: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepFirstDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_FIRST_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8723: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepFirstDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_FIRST_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8724: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepSecondDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_SECOND_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8725: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepSecondDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_SECOND_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8726: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepSecondDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_SECOND_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8727: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepSecondDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_SECOND_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8728: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepSecondDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_SECOND_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8729: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8730: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8731: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8732: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8733: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8761: {
            'access': 'read-write',
            'c_function_name': 'CIPrescaler',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the divisor to apply to the signal you connect to the counter source terminal. Scaled data that you read takes this setting into account. You should use a prescaler only when you connect an external signal to the counter source terminal and when that signal has a higher frequency than the fastest onboard timebase. Setting this value disables duplicate count prevention unless you explicitly set **ci_dup_count_prevention** to True.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PRESCALER',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        8762: {
            'access': 'read-write',
            'c_function_name': 'AISoundPressureMaxSoundPressureLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the maximum instantaneous sound pressure level you expect to measure. This value is in decibels, referenced to 20 micropascals. NI-DAQmx uses the maximum sound pressure level to calculate values in pascals for **ai_max** and **ai_min** for the channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_SOUND_PRESSURE_MAX_SOUND_PRESSURE_LVL',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8768: {
            'access': 'read-write',
            'c_function_name': 'AOIdleOutputBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the state of the channel when no generation is in progress.',
            'enum': 'AOIdleOutputBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_IDLE_OUTPUT_BEHAVIOR',
            'python_class_name': 'AOChannel',
            'python_data_type': 'AOIdleOutputBehavior',
            'resettable': True,
            'type': 'int32'
        },
        8769: {
            'access': 'read-write',
            'c_function_name': 'AOEnhancedImageRejectionEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable the DAC interpolation filter. Disable the interpolation filter to improve DAC signal-to-noise ratio at the expense of degraded image rejection.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_ENHANCED_IMAGE_REJECTION_ENABLE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8786: {
            'access': 'read-write',
            'c_function_name': 'AODACRefExtSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the source of the DAC reference voltage if **aodac_ref_src** is **SourceSelection.EXTERNAL**. The valid sources for this signal vary by device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_REF_EXT_SRC',
            'python_class_name': 'AOChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8787: {
            'access': 'read-write',
            'c_function_name': 'AODACOffsetSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the source of the DAC offset voltage. The value of this voltage source determines the full-scale value of the DAC.',
            'enum': 'SourceSelection',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_OFFSET_SRC',
            'python_class_name': 'AOChannel',
            'python_data_type': 'SourceSelection',
            'resettable': True,
            'type': 'int32'
        },
        8788: {
            'access': 'read-write',
            'c_function_name': 'AODACOffsetExtSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the source of the DAC offset voltage if **aodac_offset_src** is **SourceSelection.EXTERNAL**. The valid sources for this signal vary by device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_OFFSET_EXT_SRC',
            'python_class_name': 'AOChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8789: {
            'access': 'read-write',
            'c_function_name': 'AODACOffsetVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in volts the value of the DAC offset voltage. To achieve best accuracy, the DAC offset value should be hand calibrated.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_DAC_OFFSET_VAL',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8803: {
            'access': 'read-write',
            'c_function_name': 'DIDataXferMech',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the data transfer mode for the device.',
            'enum': 'DataTransferMechanism',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_DATA_XFER_MECH',
            'python_class_name': 'DIChannel',
            'python_data_type': 'DataTransferMechanism',
            'resettable': True,
            'type': 'int32'
        },
        8804: {
            'access': 'read-write',
            'c_function_name': 'DIDataXferReqCond',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies under what condition to transfer data from the onboard memory of the device to the buffer.',
            'enum': 'InputDataTransferCondition',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_DATA_XFER_REQ_COND',
            'python_class_name': 'DIChannel',
            'python_data_type': 'InputDataTransferCondition',
            'resettable': True,
            'type': 'int32'
        },
        8805: {
            'access': 'read-write',
            'c_function_name': 'DOUseOnlyOnBrdMem',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to write samples directly to the onboard memory of the device, bypassing the memory buffer. Generally, you cannot update onboard memory after you start the task. Onboard memory includes data FIFOs.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_USE_ONLY_ON_BRD_MEM',
            'python_class_name': 'DOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8806: {
            'access': 'read-write',
            'c_function_name': 'DODataXferMech',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the data transfer mode for the device.',
            'enum': 'DataTransferMechanism',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_DATA_XFER_MECH',
            'python_class_name': 'DOChannel',
            'python_data_type': 'DataTransferMechanism',
            'resettable': True,
            'type': 'int32'
        },
        8807: {
            'access': 'read-write',
            'c_function_name': 'DODataXferReqCond',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies under what condition to transfer data from the buffer to the onboard memory of the device.',
            'enum': 'OutputDataTransferCondition',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_DATA_XFER_REQ_COND',
            'python_class_name': 'DOChannel',
            'python_data_type': 'OutputDataTransferCondition',
            'resettable': True,
            'type': 'int32'
        },
        8813: {
            'access': 'read-write',
            'c_function_name': 'COPrescaler',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the divisor to apply to the signal you connect to the counter source terminal. Pulse generations defined by frequency or time take this setting into account, but pulse generations defined by ticks do not. You should use a prescaler only when you connect an external signal to the counter source terminal and when that signal has a higher frequency than the fastest onboard timebase.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_PRESCALER',
            'python_class_name': 'COChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        8817: {
            'access': 'read-write',
            'c_function_name': 'CICtrTimebaseDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CTR_TIMEBASE_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8818: {
            'access': 'read-write',
            'c_function_name': 'CICtrTimebaseDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CTR_TIMEBASE_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8819: {
            'access': 'read-write',
            'c_function_name': 'CICtrTimebaseDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CTR_TIMEBASE_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8820: {
            'access': 'read-write',
            'c_function_name': 'CICtrTimebaseDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CTR_TIMEBASE_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8821: {
            'access': 'read-write',
            'c_function_name': 'CICtrTimebaseDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CTR_TIMEBASE_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8822: {
            'access': 'read-write',
            'c_function_name': 'COCtrTimebaseDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CTR_TIMEBASE_DIG_FLTR_ENABLE',
            'python_class_name': 'COChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8823: {
            'access': 'read-write',
            'c_function_name': 'COCtrTimebaseDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CTR_TIMEBASE_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'COChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8824: {
            'access': 'read-write',
            'c_function_name': 'COCtrTimebaseDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CTR_TIMEBASE_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'COChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8825: {
            'access': 'read-write',
            'c_function_name': 'COCtrTimebaseDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CTR_TIMEBASE_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'COChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8826: {
            'access': 'read-write',
            'c_function_name': 'COCtrTimebaseDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CTR_TIMEBASE_DIG_SYNC_ENABLE',
            'python_class_name': 'COChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8852: {
            'access': 'read-write',
            'c_function_name': 'AIEnhancedAliasRejectionEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable enhanced alias rejection. Leave this property set to the default value for most applications.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ENHANCED_ALIAS_REJECTION_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8855: {
            'access': 'read',
            'c_function_name': 'AIChanCalHasValidCalInfo',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the channel has calibration information.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CHAN_CAL_HAS_VALID_CAL_INFO',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8856: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalEnableCal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable the channel calibration associated with the channel.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CHAN_CAL_ENABLE_CAL',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8857: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalApplyCalIfExp',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the channel calibration to the channel after the expiration date has passed.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CHAN_CAL_APPLY_CAL_IF_EXP',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8860: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalScaleType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the method or equation form that the calibration scale uses.',
            'enum': 'ScaleType3',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CHAN_CAL_SCALE_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ScaleType3',
            'resettable': True,
            'type': 'int32'
        },
        8861: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalTablePreScaledVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies the reference values collected when calibrating the channel.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_CHAN_CAL_TABLE_PRE_SCALED_VALS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        8862: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalTableScaledVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies the acquired values collected when calibrating the channel.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_CHAN_CAL_TABLE_SCALED_VALS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        8863: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalPolyForwardCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies the forward polynomial values used for calibrating the channel.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_CHAN_CAL_POLY_FORWARD_COEFF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        8864: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalPolyReverseCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies the reverse polynomial values used for calibrating the channel.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_CHAN_CAL_POLY_REVERSE_COEFF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        8865: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalVerifRefVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies the reference values collected when verifying the calibration. NI-DAQmx stores these values as a record of calibration accuracy and does not use them in the scaling process.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_CHAN_CAL_VERIF_REF_VALS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        8866: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalVerifAcqVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies the acquired values collected when verifying the calibration. NI-DAQmx stores these values as a record of calibration accuracy and does not use them in the scaling process.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_CHAN_CAL_VERIF_ACQ_VALS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        8867: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalOperatorName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of the operator who performed the channel calibration.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CHAN_CAL_OPERATOR_NAME',
            'python_class_name': 'AIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8868: {
            'access': 'read-write',
            'c_function_name': 'AIChanCalDesc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the description entered for the calibration of the channel.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CHAN_CAL_DESC',
            'python_class_name': 'AIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8883: {
            'access': 'read-write',
            'c_function_name': 'CITimestampUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return timestamp measurements.',
            'enum': 'TimeUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TIMESTAMP_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'TimeUnits',
            'resettable': True,
            'type': 'int32'
        },
        8884: {
            'access': 'read-write',
            'c_function_name': 'CITimestampInitialSeconds',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of seconds that elapsed since the beginning of the current year. This value is ignored if  **cigps_sync_method** is **GpsSignalType1.IRIGB**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TIMESTAMP_INITIAL_SECONDS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        8920: {
            'access': 'read-write',
            'c_function_name': 'AIRawDataCompressionType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of compression to apply to raw samples returned from the device.',
            'enum': 'RawDataCompressionType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RAW_DATA_COMPRESSION_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'RawDataCompressionType',
            'resettable': True,
            'type': 'int32'
        },
        8921: {
            'access': 'read-write',
            'c_function_name': 'AILossyLSBRemovalCompressedSampSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of bits to return in a raw sample when **ai_raw_data_compression_type** is set to **RawDataCompressionType.LOSSYLSBREMOVAL**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_LOSSY_LSB_REMOVAL_COMPRESSED_SAMP_SIZE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        8922: {
            'access': 'read',
            'c_function_name': 'AIRawSampSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in bits the size of a raw sample from the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_RAW_SAMP_SIZE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8958: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodStartingEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the input signal to begin semi-period measurement. Semi-period measurements alternate between high time and low time, starting on this edge.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_STARTING_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        8959: {
            'access': 'read',
            'c_function_name': 'CORdyForNewVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the counter is ready for new continuous pulse train values.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_RDY_FOR_NEW_VAL',
            'python_class_name': 'COChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8964: {
            'access': 'read',
            'c_function_name': 'ChanIsGlobal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the channel is a global channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CHAN_IS_GLOBAL',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8972: {
            'access': 'read-write',
            'c_function_name': 'AIDataXferCustomThreshold',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of samples that must be in the FIFO to transfer data from the device if **ai_data_xfer_req_cond** is **InputDataTransferCondition.ONBRDMEMCUSTOMTHRESHOLD**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DATA_XFER_CUSTOM_THRESHOLD',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        10598: {
            'access': 'read-write',
            'c_function_name': 'DIAcquireOn',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the sample clock to acquire samples.',
            'enum': 'SampleClockActiveOrInactiveEdgeSelection',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_ACQUIRE_ON',
            'python_class_name': 'DIChannel',
            'python_data_type': 'SampleClockActiveOrInactiveEdgeSelection',
            'resettable': True,
            'type': 'int32'
        },
        10599: {
            'access': 'read-write',
            'c_function_name': 'DOLineStatesPausedState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the state of the lines in a digital output task when the task pauses.',
            'enum': 'DigitalLineState',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_LINE_STATES_PAUSED_STATE',
            'python_class_name': 'DOChannel',
            'python_data_type': 'DigitalLineState',
            'resettable': True,
            'type': 'int32'
        },
        10600: {
            'access': 'read-write',
            'c_function_name': 'DOLineStatesDoneState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the state of the lines in a digital output task when the task completes execution.',
            'enum': 'DigitalLineState',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_LINE_STATES_DONE_STATE',
            'python_class_name': 'DOChannel',
            'python_data_type': 'DigitalLineState',
            'resettable': True,
            'type': 'int32'
        },
        10601: {
            'access': 'read-write',
            'c_function_name': 'DOGenerateOn',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the sample clock to generate samples.',
            'enum': 'SampleClockActiveOrInactiveEdgeSelection',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_GENERATE_ON',
            'python_class_name': 'DOChannel',
            'python_data_type': 'SampleClockActiveOrInactiveEdgeSelection',
            'resettable': True,
            'type': 'int32'
        },
        10602: {
            'access': 'read-write',
            'c_function_name': 'DIMemMapEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies for NI-DAQmx to map hardware registers to the memory space of the application, if possible. Normally, NI-DAQmx maps hardware registers to memory accessible only to the kernel. Mapping the registers to the memory space of the application increases performance. However, if the application accesses the memory space mapped to the registers, it can adversely affect the operation of the device and possibly result in a system crash.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_MEM_MAP_ENABLE',
            'python_class_name': 'DIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        10603: {
            'access': 'read-write',
            'c_function_name': 'DOMemMapEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies for NI-DAQmx to map hardware registers to the memory space of the application, if possible. Normally, NI-DAQmx maps hardware registers to memory accessible only to the kernel. Mapping the registers to the memory space of the application increases performance. However, if the application accesses the memory space mapped to the registers, it can adversely affect the operation of the device and possibly result in a system crash.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_MEM_MAP_ENABLE',
            'python_class_name': 'DOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        10605: {
            'access': 'read-write',
            'c_function_name': 'DILogicFamily',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic family to use for acquisition. A logic family corresponds to voltage thresholds that are compatible with a group of voltage standards. Refer to the device documentation for information on the logic high and logic low voltages for these logic families.',
            'enum': 'LogicFamily',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_LOGIC_FAMILY',
            'python_class_name': 'DIChannel',
            'python_data_type': 'LogicFamily',
            'resettable': True,
            'type': 'int32'
        },
        10606: {
            'access': 'read-write',
            'c_function_name': 'DOLogicFamily',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic family to use for generation. A logic family corresponds to voltage thresholds that are compatible with a group of voltage standards. Refer to the device documentation for information on the logic high and logic low voltages for these logic families.',
            'enum': 'LogicFamily',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_LOGIC_FAMILY',
            'python_class_name': 'DOChannel',
            'python_data_type': 'LogicFamily',
            'resettable': True,
            'type': 'int32'
        },
        10610: {
            'access': 'read-write',
            'c_function_name': 'DOLineStatesStartState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the state of the lines in a digital output task when the task starts.',
            'enum': 'DigitalLineState',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_LINE_STATES_START_STATE',
            'python_class_name': 'DOChannel',
            'python_data_type': 'DigitalLineState',
            'resettable': True,
            'type': 'int32'
        },
        10627: {
            'access': 'read',
            'c_function_name': 'AIIsTEDS',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the virtual channel was initialized using a TEDS bitstream from the corresponding physical channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_IS_TEDS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10672: {
            'access': 'read-write',
            'c_function_name': 'AIVoltagedBRef',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the decibel reference level in the units of the channel. When you read samples as a waveform, the decibel reference level is included in the waveform attributes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_VOLTAGE_DB_REF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10673: {
            'access': 'read-write',
            'c_function_name': 'AISoundPressuredBRef',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the decibel reference level in the units of the channel. When you read samples as a waveform, the decibel reference level is included in the waveform attributes. NI-DAQmx also uses the decibel reference level when converting **ai_sound_pressure_max_sound_pressure_lvl** to a voltage level.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_SOUND_PRESSURE_DB_REF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10674: {
            'access': 'read-write',
            'c_function_name': 'AIAcceldBRef',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the decibel reference level in the units of the channel. When you read samples as a waveform, the decibel reference level is included in the waveform attributes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ACCEL_DB_REF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10704: {
            'access': 'read-write',
            'c_function_name': 'AIThrmcplScaleType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the method or equation form that the thermocouple scale uses.',
            'enum': 'ScaleType2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_THRMCPL_SCALE_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ScaleType2',
            'resettable': True,
            'type': 'int32'
        },
        10738: {
            'access': 'read-write',
            'c_function_name': 'COConstrainedGenMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies constraints to apply when the counter generates pulses. Constraining the counter reduces the device resources required for counter operation. Constraining the counter can also allow additional analog or counter tasks on the device to run concurrently. For continuous counter tasks, NI-DAQmx consumes no device resources when the counter is constrained. For finite counter tasks, resource use increases with the frequency regardless of the constraint mode. However, fixed frequency constraints significantly reduce resource usage, and fixed duty cycle constraint marginally reduces it.',
            'enum': 'ConstrainedGenMode',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_CONSTRAINED_GEN_MODE',
            'python_class_name': 'COChannel',
            'python_data_type': 'ConstrainedGenMode',
            'resettable': True,
            'type': 'int32'
        },
        10745: {
            'access': 'read-write',
            'c_function_name': 'AIADCTimingMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the ADC timing mode, controlling the tradeoff between speed and effective resolution. Some ADC timing modes provide increased powerline noise rejection. On devices that have an AI Convert clock, this setting affects both the maximum and default values for **ai_conv_rate**. You must use the same ADC timing mode for all channels on a device, but you can use different ADC timing modes for different devices in the same task.',
            'enum': 'ADCTimingMode',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ADC_TIMING_MODE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ADCTimingMode',
            'resettable': True,
            'type': 'int32'
        },
        10776: {
            'access': 'read-write',
            'c_function_name': 'AOFuncGenType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the kind of the waveform to generate.',
            'enum': 'FuncGenType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FUNC_GEN_TYPE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'FuncGenType',
            'resettable': True,
            'type': 'int32'
        },
        10777: {
            'access': 'read-write',
            'c_function_name': 'AOFuncGenFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the frequency of the waveform to generate in hertz.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FUNC_GEN_FREQ',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10778: {
            'access': 'read-write',
            'c_function_name': 'AOFuncGenAmplitude',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the zero-to-peak amplitude of the waveform to generate in volts. Zero and negative values are valid.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FUNC_GEN_AMPLITUDE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10779: {
            'access': 'read-write',
            'c_function_name': 'AOFuncGenOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the voltage offset of the waveform to generate.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FUNC_GEN_OFFSET',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10780: {
            'access': 'read-write',
            'c_function_name': 'AOFuncGenSquareDutyCycle',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the square wave duty cycle of the waveform to generate.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FUNC_GEN_SQUARE_DUTY_CYCLE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10781: {
            'access': 'read-write',
            'c_function_name': 'AOVoltageCurrentLimit',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the current limit, in amperes, for the voltage channel.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_VOLTAGE_CURRENT_LIMIT',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10786: {
            'access': 'read-write',
            'c_function_name': 'AOFuncGenModulationType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies if the device generates a modulated version of the waveform using the original waveform as a carrier and input from an external terminal as the signal.',
            'enum': 'ModulationType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FUNC_GEN_MODULATION_TYPE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'ModulationType',
            'resettable': True,
            'type': 'int32'
        },
        10787: {
            'access': 'read-write',
            'c_function_name': 'AOFuncGenFMDeviation',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the FM deviation in hertz per volt when **ao_func_gen_modulation_type** is **ModulationType.FM**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FUNC_GEN_FM_DEVIATION',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10885: {
            'access': 'read-write',
            'c_function_name': 'DOOvercurrentLimit',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the current threshold in Amperes for the channel. A value of 0 means the channel observes no limit. Devices can monitor only a finite number of current thresholds simultaneously. If you attempt to monitor additional thresholds, NI-DAQmx returns an error.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_OVERCURRENT_LIMIT',
            'python_class_name': 'DOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10886: {
            'access': 'read-write',
            'c_function_name': 'DOOvercurrentAutoReenable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to automatically reenable channels after they no longer exceed the current limit specified by **do_overcurrent_limit**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_OVERCURRENT_AUTO_REENABLE',
            'python_class_name': 'DOChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        10887: {
            'access': 'read-write',
            'c_function_name': 'DOOvercurrentReenablePeriod',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the delay in seconds between the time a channel no longer exceeds the current limit and the reactivation of that channel, if **do_overcurrent_auto_reenable** is True.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_OVERCURRENT_REENABLE_PERIOD',
            'python_class_name': 'DOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10888: {
            'access': 'read-write',
            'c_function_name': 'AIProbeAtten',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the amount of attenuation provided by the probe connected to the channel. Specify this attenuation as a ratio.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_PROBE_ATTEN',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10889: {
            'access': 'read-write',
            'c_function_name': 'AIDCOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the DC value to add to the input range of the device. Use **ai_rng_high** and **ai_rng_low** to specify the input range. This offset is in the native units of the device .',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DC_OFFSET',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10894: {
            'access': 'read-write',
            'c_function_name': 'AIUsbXferReqSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum size of a USB transfer request in bytes. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_USB_XFER_REQ_SIZE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        10895: {
            'access': 'read-write',
            'c_function_name': 'AOUsbXferReqSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum size of a USB transfer request in bytes. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_USB_XFER_REQ_SIZE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        10896: {
            'access': 'read-write',
            'c_function_name': 'DIUsbXferReqSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum size of a USB transfer request in bytes. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_USB_XFER_REQ_SIZE',
            'python_class_name': 'DIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        10897: {
            'access': 'read-write',
            'c_function_name': 'DOUsbXferReqSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum size of a USB transfer request in bytes. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_USB_XFER_REQ_SIZE',
            'python_class_name': 'DOChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        10898: {
            'access': 'read-write',
            'c_function_name': 'CIUsbXferReqSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum size of a USB transfer request in bytes. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_USB_XFER_REQ_SIZE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        10899: {
            'access': 'read-write',
            'c_function_name': 'COUsbXferReqSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum size of a USB transfer request in bytes. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_USB_XFER_REQ_SIZE',
            'python_class_name': 'COChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        10942: {
            'access': 'read-write',
            'c_function_name': 'AIEddyCurrentProxProbeSensitivity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the eddy current proximity probe . This value is in the units you specify with **ai_eddy_current_prox_sensitivity_units**. Refer to the sensor documentation to determine this value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EDDY_CURRENT_PROX_PROBE_SENSITIVITY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10943: {
            'access': 'read-write',
            'c_function_name': 'AIEddyCurrentProxProbeSensitivityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **ai_eddy_current_prox_sensitivity**.',
            'enum': 'EddyCurrentProxProbeSensitivityUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EDDY_CURRENT_PROX_PROBE_SENSITIVITY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'EddyCurrentProxProbeSensitivityUnits',
            'resettable': True,
            'type': 'int32'
        },
        10944: {
            'access': 'read-write',
            'c_function_name': 'AIEddyCurrentProxProbeUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return proximity measurements from the channel.',
            'enum': 'LengthUnits2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EDDY_CURRENT_PROX_PROBE_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'LengthUnits2',
            'resettable': True,
            'type': 'int32'
        },
        11977: {
            'access': 'read-write',
            'c_function_name': 'COEnableInitialDelayOnRetrigger',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the initial delay to retriggered pulse trains.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_ENABLE_INITIAL_DELAY_ON_RETRIGGER',
            'python_class_name': 'COChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        11979: {
            'access': 'read-write',
            'c_function_name': 'COUseOnlyOnBrdMem',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to write samples directly to the onboard memory of the device, bypassing the memory buffer. Generally, you cannot update onboard memory directly after you start the task. Onboard memory includes data FIFOs.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_USE_ONLY_ON_BRD_MEM',
            'python_class_name': 'COChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        11980: {
            'access': 'read-write',
            'c_function_name': 'CODataXferMech',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the data transfer mode for the device. For buffered operations, use DMA or USB Bulk. For non-buffered operations, use Polled.',
            'enum': 'DataTransferMechanism',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_DATA_XFER_MECH',
            'python_class_name': 'COChannel',
            'python_data_type': 'DataTransferMechanism',
            'resettable': True,
            'type': 'int32'
        },
        11981: {
            'access': 'read-write',
            'c_function_name': 'CODataXferReqCond',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies under what condition to transfer data from the buffer to the onboard memory of the device.',
            'enum': 'OutputDataTransferCondition',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_DATA_XFER_REQ_COND',
            'python_class_name': 'COChannel',
            'python_data_type': 'OutputDataTransferCondition',
            'resettable': True,
            'type': 'int32'
        },
        11984: {
            'access': 'read-write',
            'c_function_name': 'CIFreqEnableAveraging',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable averaging mode for Sample Clock-timed frequency measurements.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_ENABLE_AVERAGING',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        11985: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodEnableAveraging',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable averaging mode for Sample Clock-timed period measurements.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_ENABLE_AVERAGING',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        11986: {
            'access': 'read-write',
            'c_function_name': 'CIMemMapEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies for NI-DAQmx to map hardware registers to the memory space of the application, if possible. Normally, NI-DAQmx maps hardware registers to memory accessible only to the kernel. Mapping the registers to the memory space of the application increases performance. However, if the application accesses the memory space mapped to the registers, it can adversely affect the operation of the device and possibly result in a system crash.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_MEM_MAP_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        11987: {
            'access': 'read-write',
            'c_function_name': 'COMemMapEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies for NI-DAQmx to map hardware registers to the memory space of the application, if possible. Normally, NI-DAQmx maps hardware registers to memory accessible only to the kernel. Mapping the registers to the memory space of the application increases performance. However, if the application accesses the memory space mapped to the registers, it can adversely affect the operation of the device and possibly result in a system crash.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_MEM_MAP_ENABLE',
            'python_class_name': 'COChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        11988: {
            'access': 'read-write',
            'c_function_name': 'DIDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'DIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        11989: {
            'access': 'read-write',
            'c_function_name': 'DIDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'DIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        11990: {
            'access': 'read-write',
            'c_function_name': 'DIDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_DIG_SYNC_ENABLE',
            'python_class_name': 'DIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12027: {
            'access': 'read-write',
            'c_function_name': 'CIDataXferReqCond',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies under what condition to transfer data from the onboard memory of the device to the buffer.',
            'enum': 'InputDataTransferCondition',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DATA_XFER_REQ_COND',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputDataTransferCondition',
            'resettable': True,
            'type': 'int32'
        },
        12030: {
            'access': 'read-write',
            'c_function_name': 'DIDigFltrEnableBusMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable bus mode for digital filtering. If you set this property to True, NI-DAQmx treats all lines that use common filtering settings as a bus. If any line in the bus has jitter, all lines in the bus hold state until the entire bus stabilizes, or until 2 times the minimum pulse width elapses. If you set this property to False, NI-DAQmx filters all lines individually. Jitter in one line does not affect other lines.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_DIG_FLTR_ENABLE_BUS_MODE',
            'python_class_name': 'DIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12036: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12037: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqStartEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the input signal to begin pulse measurement.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_START_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        12038: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12039: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12040: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12041: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12042: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12043: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return pulse specifications in terms of frequency.',
            'enum': 'FrequencyUnits2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'FrequencyUnits2',
            'resettable': True,
            'type': 'int32'
        },
        12044: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12045: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeStartEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the input signal to begin pulse measurement.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_START_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        12046: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12047: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12048: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12049: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12050: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12051: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return pulse specifications in terms of high time and low time.',
            'enum': 'TimeUnits2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'TimeUnits2',
            'resettable': True,
            'type': 'int32'
        },
        12052: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTicksTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TICKS_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12053: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTicksStartEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the input signal to begin pulse measurement.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TICKS_START_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        12054: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTicksDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TICKS_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12055: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTicksDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TICKS_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12056: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTicksDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TICKS_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12057: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTicksDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TICKS_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12058: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTicksDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TICKS_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12139: {
            'access': 'read-write',
            'c_function_name': 'AIADCCustomTimingMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the timing mode of the ADC when **aiadc_timing_mode** is **ADCTimingMode.CUSTOM**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ADC_CUSTOM_TIMING_MODE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12146: {
            'access': 'read-write',
            'c_function_name': 'AIOpenThrmcplDetectEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the open thermocouple detection bias voltage to the channel. Changing the value of this property on a channel may require settling time before the data returned is valid. To compensate for this settling time, discard unsettled data or add a delay between committing and starting the task. Refer to your device specifications for the required settling time. When open thermocouple detection is enabled, use **open_thrmcpl_chans_exist** to determine if any channels were open.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_OPEN_THRMCPL_DETECT_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12149: {
            'access': 'read-write',
            'c_function_name': 'AIForceUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies in which unit to return force or load measurements from the channel.',
            'enum': 'ForceUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FORCE_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ForceUnits',
            'resettable': True,
            'type': 'int32'
        },
        12150: {
            'access': 'read-write',
            'c_function_name': 'AIPressureUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies  in which unit to return pressure measurements from the channel.',
            'enum': 'PressureUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_PRESSURE_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'PressureUnits',
            'resettable': True,
            'type': 'int32'
        },
        12151: {
            'access': 'read-write',
            'c_function_name': 'AITorqueUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies in which unit to return torque measurements from the channel.',
            'enum': 'TorqueUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_TORQUE_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'TorqueUnits',
            'resettable': True,
            'type': 'int32'
        },
        12152: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeShuntCalShuntCalAResistance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the desired value of the internal shunt calibration A resistor.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SHUNT_CAL_SHUNT_CAL_A_RESISTANCE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12153: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeShuntCalShuntCalAActualResistance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the actual value of the internal shunt calibration A resistor.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SHUNT_CAL_SHUNT_CAL_A_ACTUAL_RESISTANCE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12154: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeShuntCalShuntCalBResistance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the desired value of the internal shunt calibration B resistor.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SHUNT_CAL_SHUNT_CAL_B_RESISTANCE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12155: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeShuntCalShuntCalBActualResistance',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in ohms the actual value of the internal shunt calibration B resistor.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SHUNT_CAL_SHUNT_CAL_B_ACTUAL_RESISTANCE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12161: {
            'access': 'read-write',
            'c_function_name': 'AIForceIEPESensorSensitivity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the IEPE force sensor connected to the channel. Specify this value in the unit indicated by **ai_forceiepe_sensor_sensitivity_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FORCE_IEPE_SENSOR_SENSITIVITY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12162: {
            'access': 'read-write',
            'c_function_name': 'AIForceIEPESensorSensitivityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units for **ai_forceiepe_sensor_sensitivity**.',
            'enum': 'ForceIEPESensorSensitivityUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FORCE_IEPE_SENSOR_SENSITIVITY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ForceIEPESensorSensitivityUnits',
            'resettable': True,
            'type': 'int32'
        },
        12166: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeInitialRatio',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in volts per volt the ratio of output voltage from the bridge to excitation voltage supplied to the bridge while not under load. NI-DAQmx subtracts this value from any measurements before applying scaling equations. If you set **ai_bridge_initial_voltage**, NI-DAQmx coerces this property  to **ai_bridge_initial_voltage** divided by **ai_excit_actual_val**. If you set this property, NI-DAQmx coerces **ai_bridge_initial_voltage** to the value of this property times **ai_excit_actual_val**. If you set both this property and **ai_bridge_initial_voltage**, and their values conflict, NI-DAQmx returns an error.  To avoid this error, reset one property to its default value before setting the other.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_INITIAL_RATIO',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12167: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeElectricalUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies from which electrical unit to scale data. Select  the same unit that the sensor data sheet or calibration certificate uses for electrical values.',
            'enum': 'BridgeElectricalUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_ELECTRICAL_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'BridgeElectricalUnits',
            'resettable': True,
            'type': 'int32'
        },
        12168: {
            'access': 'read-write',
            'c_function_name': 'AIBridgePhysicalUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies to which physical unit to scale electrical data. Select the same unit that the sensor data sheet or calibration certificate uses for physical values.',
            'enum': 'BridgePhysicalUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_PHYSICAL_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'BridgePhysicalUnits',
            'resettable': True,
            'type': 'int32'
        },
        12169: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeScaleType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the scaling type to use when scaling electrical values from the sensor to physical units.',
            'enum': 'ScaleType4',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SCALE_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ScaleType4',
            'resettable': True,
            'type': 'int32'
        },
        12170: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeTwoPointLinFirstElectricalVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the first electrical value, corresponding to **ai_bridge_two_point_lin_first_physical_val**. Specify this value in the unit indicated by **ai_bridge_electrical_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_TWO_POINT_LIN_FIRST_ELECTRICAL_VAL',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12171: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeTwoPointLinFirstPhysicalVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the first physical value, corresponding to **ai_bridge_two_point_lin_first_electrical_val**. Specify this value in the unit indicated by **ai_bridge_physical_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_TWO_POINT_LIN_FIRST_PHYSICAL_VAL',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12172: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeTwoPointLinSecondElectricalVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the second electrical value, corresponding to **ai_bridge_two_point_lin_second_physical_val**. Specify this value in the unit indicated by **ai_bridge_electrical_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_TWO_POINT_LIN_SECOND_ELECTRICAL_VAL',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12173: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeTwoPointLinSecondPhysicalVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the second physical value, corresponding to **ai_bridge_two_point_lin_second_electrical_val**. Specify this value in the unit indicated by **ai_bridge_physical_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_TWO_POINT_LIN_SECOND_PHYSICAL_VAL',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12174: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeTableElectricalVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies the list of electrical values that map to the values in **ai_bridge_table_physical_vals**. Specify this value in the unit indicated by **ai_bridge_electrical_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_BRIDGE_TABLE_ELECTRICAL_VALS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        12175: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeTablePhysicalVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies the list of physical values that map to the values in **ai_bridge_table_electrical_vals**. Specify this value in the unit indicated by **ai_bridge_physical_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_BRIDGE_TABLE_PHYSICAL_VALS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        12176: {
            'access': 'read-write',
            'c_function_name': 'AIBridgePolyForwardCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies an list of coefficients for the polynomial that converts electrical values to physical values. Each element of the list corresponds to a term of the equation. For example, if index three of the list is 9, the fourth term of the equation is 9x^3.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_BRIDGE_POLY_FORWARD_COEFF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        12177: {
            'access': 'read-write',
            'c_function_name': 'AIBridgePolyReverseCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies an list of coefficients for the polynomial that converts physical values to electrical values. Each element of the list corresponds to a term of the equation. For example, if index three of the list is 9, the fourth term of the equation is 9x^3.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_BRIDGE_POLY_REVERSE_COEFF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        12178: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies in which unit to return voltage ratios from the channel.',
            'enum': 'BridgeUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'BridgeUnits',
            'resettable': True,
            'type': 'int32'
        },
        12207: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to reset the count on the active edge specified with **ci_count_edges_count_reset_term**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12208: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetResetCount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the value to reset the count to.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_RESET_COUNT',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12209: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to reset the count.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12210: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetActiveEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the signal to reset the count.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_ACTIVE_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        12211: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12212: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12213: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12214: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12215: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_DIG_SYNC_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12216: {
            'access': 'read-write',
            'c_function_name': 'AIThrmcplLeadOffsetVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the lead offset nulling voltage to subtract from measurements on a device. This property is ignored if open thermocouple detection is disabled.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_THRMCPL_LEAD_OFFSET_VOLTAGE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12221: {
            'access': 'read-write',
            'c_function_name': 'AIRemoveFilterDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies if filter delay removal is enabled on the device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_REMOVE_FILTER_DELAY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12269: {
            'access': 'read',
            'c_function_name': 'AIFilterDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the amount of time between when the ADC samples data and when the sample is read by the host device. This value is in the units you specify with **ai_filter_delay_units**. You can adjust this amount of time using **ai_filter_delay_adjustment**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FILTER_DELAY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12270: {
            'access': 'read-write',
            'c_function_name': 'AIAveragingWinSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of samples to average while acquiring data. Increasing the number of samples to average reduces noise in your measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_AVERAGING_WIN_SIZE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12276: {
            'access': 'read-write',
            'c_function_name': 'AIVelocityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies in which unit to return velocity measurements from the channel.',
            'enum': 'VelocityUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_VELOCITY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'VelocityUnits',
            'resettable': True,
            'type': 'int32'
        },
        12277: {
            'access': 'read-write',
            'c_function_name': 'AIVelocityIEPESensordBRef',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the decibel reference level in the units of the channel. When you read samples as a waveform, the decibel reference level is included in the waveform attributes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_VELOCITY_IEPE_SENSOR_DB_REF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12278: {
            'access': 'read-write',
            'c_function_name': 'AIVelocityIEPESensorSensitivity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the IEPE velocity sensor connected to the channel. Specify this value in the unit indicated by **ai_velocityiepe_sensor_sensitivity_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_VELOCITY_IEPE_SENSOR_SENSITIVITY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12279: {
            'access': 'read-write',
            'c_function_name': 'AIVelocityIEPESensorSensitivityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units for **ai_velocityiepe_sensor_sensitivity**.',
            'enum': 'VelocityIEPESensorSensitivityUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_VELOCITY_IEPE_SENSOR_SENSITIVITY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'VelocityIEPESensorSensitivityUnits',
            'resettable': True,
            'type': 'int32'
        },
        12282: {
            'access': 'read-write',
            'c_function_name': 'AIStrainGageForceReadFromChan',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether the data is returned by DAQmx Read when set on a raw strain channel that is part of a rosette configuration.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_STRAIN_GAGE_FORCE_READ_FROM_CHAN',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12283: {
            'access': 'read',
            'c_function_name': 'AIRosetteStrainGageStrainChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the raw strain channels that comprise the strain rosette.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_ROSETTE_STRAIN_GAGE_STRAIN_CHANS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12284: {
            'access': 'read-write',
            'c_function_name': 'AIRosetteStrainGageOrientation',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies gage orientation in degrees with respect to the X axis.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ROSETTE_STRAIN_GAGE_ORIENTATION',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12285: {
            'access': 'read-write',
            'c_function_name': 'AIRosetteStrainGageRosetteMeasType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of rosette measurement.',
            'enum': 'StrainGageRosetteMeasurementType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ROSETTE_STRAIN_GAGE_ROSETTE_MEAS_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'StrainGageRosetteMeasurementType',
            'resettable': True,
            'type': 'int32'
        },
        12286: {
            'access': 'read',
            'c_function_name': 'AIRosetteStrainGageRosetteType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the type of rosette gage.',
            'enum': 'StrainGageRosetteType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ROSETTE_STRAIN_GAGE_ROSETTE_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'StrainGageRosetteType',
            'resettable': False,
            'type': 'int32'
        },
        12288: {
            'access': 'read-write',
            'c_function_name': 'AIUsbXferReqCount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum number of simultaneous USB transfers used to stream data. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_USB_XFER_REQ_COUNT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12289: {
            'access': 'read-write',
            'c_function_name': 'AOUsbXferReqCount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum number of simultaneous USB transfers used to stream data. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_USB_XFER_REQ_COUNT',
            'python_class_name': 'AOChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12290: {
            'access': 'read-write',
            'c_function_name': 'DIUsbXferReqCount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum number of simultaneous USB transfers used to stream data. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_USB_XFER_REQ_COUNT',
            'python_class_name': 'DIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12291: {
            'access': 'read-write',
            'c_function_name': 'DOUsbXferReqCount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum number of simultaneous USB transfers used to stream data. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_USB_XFER_REQ_COUNT',
            'python_class_name': 'DOChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12292: {
            'access': 'read-write',
            'c_function_name': 'CIUsbXferReqCount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum number of simultaneous USB transfers used to stream data. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_USB_XFER_REQ_COUNT',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12293: {
            'access': 'read-write',
            'c_function_name': 'COUsbXferReqCount',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum number of simultaneous USB transfers used to stream data. Modify this value to affect performance under different combinations of operating system and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_USB_XFER_REQ_COUNT',
            'python_class_name': 'COChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12345: {
            'access': 'read-write',
            'c_function_name': 'CITimestampTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TIMESTAMP_TERM',
            'python_class_name': 'N/A',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12346: {
            'access': 'read-write',
            'c_function_name': 'CITimestampEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the edge of the input terminal to timestamp in a streaming task.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TIMESTAMP_EDGE',
            'python_class_name': 'N/A',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        12347: {
            'access': 'read-write',
            'c_function_name': 'CITimestampTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the timescale that will be used when returning time to a user.',
            'enum': 'Timescale',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TIMESTAMP_TIMESCALE',
            'python_class_name': 'N/A',
            'python_data_type': 'Timescale',
            'resettable': True,
            'type': 'int32'
        },
        12348: {
            'access': 'read-write',
            'c_function_name': 'NavCustomScaleName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a custom scale for the channel.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'NAV_CUSTOM_SCALE_NAME',
            'object_module_location': 'nidaqmx.system.scale',
            'object_type': 'Scale',
            'python_class_name': 'N/A',
            'python_data_type': 'Scale',
            'resettable': True,
            'type': 'char[]'
        },
        12349: {
            'access': 'read',
            'c_function_name': 'NavMeasType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the measurement to take with the channel.',
            'enum': 'NavMeasurementType',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_MEAS_TYPE',
            'python_class_name': 'N/A',
            'python_data_type': 'NavMeasurementType',
            'resettable': False,
            'type': 'int32'
        },
        12350: {
            'access': 'read-write',
            'c_function_name': 'NavAltUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return altitude measurements from the channel.',
            'enum': 'LengthUnits4',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_ALT_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'LengthUnits4',
            'resettable': True,
            'type': 'int32'
        },
        12351: {
            'access': 'read-write',
            'c_function_name': 'NavLatUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return latitude measurements from the channel.',
            'enum': 'AngleUnits3',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_LAT_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'AngleUnits3',
            'resettable': True,
            'type': 'int32'
        },
        12352: {
            'access': 'read-write',
            'c_function_name': 'NavLongUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return longitude measurements from the channel.',
            'enum': 'AngleUnits3',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_LONG_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'AngleUnits3',
            'resettable': True,
            'type': 'int32'
        },
        12353: {
            'access': 'read-write',
            'c_function_name': 'NavSpeedOverGroundUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return speed over ground measurements from the channel.',
            'enum': 'VelocityUnits2',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_SPEED_OVER_GROUND_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'VelocityUnits2',
            'resettable': True,
            'type': 'int32'
        },
        12354: {
            'access': 'read-write',
            'c_function_name': 'NavTrackUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return track measurements from the channel.',
            'enum': 'AngleUnits1',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_TRACK_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'AngleUnits1',
            'resettable': True,
            'type': 'int32'
        },
        12355: {
            'access': 'read-write',
            'c_function_name': 'NavVertVelocityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return vertical velocity measurements from the channel.',
            'enum': 'VelocityUnits2',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_VERT_VELOCITY_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'VelocityUnits2',
            'resettable': True,
            'type': 'int32'
        },
        12356: {
            'access': 'read-write',
            'c_function_name': 'NavTimestampUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return timestamp measurements.',
            'enum': 'TimeUnits',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_TIMESTAMP_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'TimeUnits',
            'resettable': True,
            'type': 'int32'
        },
        12357: {
            'access': 'read-write',
            'c_function_name': 'NavTimestampTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the timescale that will be used when returning time to a user.',
            'enum': 'Timescale',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_TIMESTAMP_TIMESCALE',
            'python_class_name': 'N/A',
            'python_data_type': 'Timescale',
            'resettable': True,
            'type': 'int32'
        },
        12401: {
            'access': 'read-write',
            'c_function_name': 'AIFilterDelayUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **ai_filter_delay** and **ai_filter_delay_adjustment**.',
            'enum': 'DigitalWidthUnits4',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FILTER_DELAY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'DigitalWidthUnits4',
            'resettable': True,
            'type': 'int32'
        },
        12402: {
            'access': 'read-write',
            'c_function_name': 'AOFilterDelayAdjustment',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies an additional amount of time to wait between when the sample is written by the host device and when the sample is output by the DAC. This delay adjustment is in addition to the value indicated by **ao_filter_delay**. This delay adjustment is in the units you specify with **ao_filter_delay_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FILTER_DELAY_ADJUSTMENT',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12404: {
            'access': 'read-write',
            'c_function_name': 'AIFilterDelayAdjustment',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the amount of filter delay that gets removed if **ai_remove_filter_delay** is enabled. This delay adjustment is in addition to the value indicated by **ai_filter_delay**. This delay adjustment is in the units you specify with **ai_filter_delay_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FILTER_DELAY_ADJUSTMENT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12405: {
            'access': 'read-write',
            'c_function_name': 'AOFilterDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the amount of time between when the sample is written by the host device and when the sample is output by the DAC. This value is in the units you specify with **ao_filter_delay_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FILTER_DELAY',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12406: {
            'access': 'read-write',
            'c_function_name': 'AOFilterDelayUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **ao_filter_delay** and **ao_filter_delay_adjustment**.',
            'enum': 'DigitalWidthUnits4',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FILTER_DELAY_UNITS',
            'python_class_name': 'AOChannel',
            'python_data_type': 'DigitalWidthUnits4',
            'resettable': True,
            'type': 'int32'
        },
        12429: {
            'access': 'read-write',
            'c_function_name': 'CIDutyCycleTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to measure.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DUTY_CYCLE_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12430: {
            'access': 'read-write',
            'c_function_name': 'CIDutyCycleDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DUTY_CYCLE_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12431: {
            'access': 'read-write',
            'c_function_name': 'CIDutyCycleDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the digital filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DUTY_CYCLE_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12432: {
            'access': 'read-write',
            'c_function_name': 'CIDutyCycleDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DUTY_CYCLE_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12433: {
            'access': 'read-write',
            'c_function_name': 'CIDutyCycleDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DUTY_CYCLE_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12434: {
            'access': 'read-write',
            'c_function_name': 'CIDutyCycleStartingEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies which edge of the input signal to begin the duty cycle measurement.',
            'enum': 'Edge1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DUTY_CYCLE_STARTING_EDGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        12435: {
            'access': 'read-write',
            'c_function_name': 'CISampClkOverrunBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the counter behavior when data is read but a new value was not detected during a sample clock.',
            'enum': 'SampClkOverrunBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SAMP_CLK_OVERRUN_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'SampClkOverrunBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12436: {
            'access': 'read-write',
            'c_function_name': 'CISampClkOverrunSentinelVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the sentinel value returned when the No New Sample Behavior is set to Sentinel Value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SAMP_CLK_OVERRUN_SENTINEL_VAL',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'int32'
        },
        12437: {
            'access': 'read-write',
            'c_function_name': 'CIMaxMeasPeriod',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the maximum period (in seconds) in which the device will recognize signals. For frequency measurements, a signal with a higher period than the one set in this property will return 0 Hz. For duty cycle, the device will return 0 or 1 depending on the state of the line during the max defined period of time. Period measurements will return NaN. Pulse width measurement will return zero.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_MAX_MEAS_PERIOD',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12439: {
            'access': 'read-write',
            'c_function_name': 'CIFreqTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12440: {
            'access': 'read-write',
            'c_function_name': 'CIFreqLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12441: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12442: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12443: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12444: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12445: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountDirTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_DIR_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12446: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountDirLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the count reset line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_DIR_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12447: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12448: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the count reset line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12449: {
            'access': 'read-write',
            'c_function_name': 'CIDutyCycleTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DUTY_CYCLE_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12450: {
            'access': 'read-write',
            'c_function_name': 'CIDutyCycleLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_DUTY_CYCLE_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12451: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderAInputTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_A_INPUT_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12452: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderAInputLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_A_INPUT_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12453: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderBInputTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_B_INPUT_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12454: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderBInputLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_B_INPUT_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12455: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZInputTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INPUT_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12456: {
            'access': 'read-write',
            'c_function_name': 'CIEncoderZInputLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_ENCODER_Z_INPUT_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12457: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12458: {
            'access': 'read-write',
            'c_function_name': 'CIPulseWidthLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_WIDTH_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12459: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepFirstTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_FIRST_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12460: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepFirstLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_FIRST_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12461: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepSecondTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_SECOND_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12462: {
            'access': 'read-write',
            'c_function_name': 'CITwoEdgeSepSecondLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the count reset line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_TWO_EDGE_SEP_SECOND_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12463: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12464: {
            'access': 'read-write',
            'c_function_name': 'CISemiPeriodLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the count reset line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SEMI_PERIOD_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12465: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12466: {
            'access': 'read-write',
            'c_function_name': 'CIPulseFreqLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the count reset line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_FREQ_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12467: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12468: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTimeLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the count reset line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TIME_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12469: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTicksTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TICKS_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12470: {
            'access': 'read-write',
            'c_function_name': 'CIPulseTicksLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the count reset line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PULSE_TICKS_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12471: {
            'access': 'read-write',
            'c_function_name': 'CIThreshVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the digital threshold value in Volts for high and low input transitions. Some devices do not support this for differential channels.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_THRESH_VOLTAGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12472: {
            'access': 'read-write',
            'c_function_name': 'AIExcitIdleOutputBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether this channel will disable excitation after the task is uncommitted. Setting this to Zero Volts or Amps disables excitation after task uncommit. Setting this attribute to Maintain Existing Value leaves the excitation on after task uncommit.',
            'enum': 'ExcitationIdleOutputBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EXCIT_IDLE_OUTPUT_BEHAVIOR',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ExcitationIdleOutputBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12477: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether the digital filter is enabled or disabled.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12478: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the digital filter type.',
            'enum': 'FilterType2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'FilterType2',
            'resettable': True,
            'type': 'int32'
        },
        12479: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrResponse',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the digital filter response.',
            'enum': 'FilterResponse',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_RESPONSE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'FilterResponse',
            'resettable': True,
            'type': 'int32'
        },
        12480: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrOrder',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the order of the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_ORDER',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12481: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrLowpassCutoffFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the lowpass cutoff frequency of the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_LOWPASS_CUTOFF_FREQ',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12482: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrHighpassCutoffFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the highpass cutoff frequency of the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_HIGHPASS_CUTOFF_FREQ',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12483: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrBandpassCenterFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the center frequency of the passband for the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_BANDPASS_CENTER_FREQ',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12484: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrBandpassWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the width of the passband centered around the center frequency for the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_BANDPASS_WIDTH',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12485: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrNotchCenterFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the center frequency of the stopband for the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_NOTCH_CENTER_FREQ',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12486: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrNotchWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the width of the stopband centered around the center frequency for the digital filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DIG_FLTR_NOTCH_WIDTH',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12487: {
            'access': 'read-write',
            'c_function_name': 'AIDigFltrCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies the digital filter coefficients.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_DIG_FLTR_COEFF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        12490: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeShuntCalShuntCalASrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether to use internal or external shunt when Shunt Cal A is selected.',
            'enum': 'BridgeShuntCalSource',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SHUNT_CAL_SHUNT_CAL_A_SRC',
            'python_class_name': 'AIChannel',
            'python_data_type': 'BridgeShuntCalSource',
            'resettable': True,
            'type': 'int32'
        },
        12504: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityAngEncoderUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return angular velocity counter measurements.',
            'enum': 'AngularVelocityUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ANG_ENCODER_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'AngularVelocityUnits',
            'resettable': True,
            'type': 'int32'
        },
        12505: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityAngEncoderPulsesPerRev',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of pulses the encoder generates per revolution. This value is the number of pulses on either signal A or signal B, not the total number of pulses on both signal A and signal B.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ANG_ENCODER_PULSES_PER_REV',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12506: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityLinEncoderUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return linear encoder velocity measurements from the channel.',
            'enum': 'VelocityUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_LIN_ENCODER_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'VelocityUnits',
            'resettable': True,
            'type': 'int32'
        },
        12507: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityLinEncoderDistPerPulse',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the distance to measure for each pulse the encoder generates on signal A or signal B. This value is in the units you specify in CI.Velocity.LinEncoder.DistUnits.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_LIN_ENCODER_DIST_PER_PULSE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12508: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderDecodingType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies how to count and interpret the pulses the encoder generates on signal A and signal B. X1, X2, and X4 are valid for quadrature encoders only. Two Pulse Counting is valid for two-pulse encoders only.',
            'enum': 'EncoderType2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_DECODING_TYPE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'EncoderType2',
            'resettable': True,
            'type': 'int32'
        },
        12509: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderAInputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which signal A is connected.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_A_INPUT_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12510: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderAInputTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_A_INPUT_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12511: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderAInputLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior of the input terminal.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_A_INPUT_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12512: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderAInputDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_A_INPUT_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12513: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderAInputDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the digital filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_A_INPUT_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12514: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderAInputDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_A_INPUT_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12515: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderAInputDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_A_INPUT_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12516: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderBInputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which signal B is connected.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_B_INPUT_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12517: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderBInputTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the input terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_B_INPUT_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12518: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderBInputLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior of the input terminal.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_B_INPUT_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12519: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderBInputDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_B_INPUT_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12520: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderBInputDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the digital filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_B_INPUT_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12521: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderBInputDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_B_INPUT_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12522: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityEncoderBInputDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_ENCODER_B_INPUT_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12523: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityMeasTime',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the length of time to measure the velocity of the signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_MEAS_TIME',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12524: {
            'access': 'read-write',
            'c_function_name': 'CIVelocityDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the value by which to divide the input signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_VELOCITY_DIV',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12525: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable the functionality to gate the counter input signal for a count edges measurement.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12526: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the gate terminal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_TERM',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12527: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateTermCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the gate terminal configuration.',
            'enum': 'InputTermCfg2',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_TERM_CFG',
            'python_class_name': 'CIChannel',
            'python_data_type': 'InputTermCfg2',
            'resettable': True,
            'type': 'int32'
        },
        12528: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateLogicLvlBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the logic level behavior on the gate input line.',
            'enum': 'LogicLvlBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_LOGIC_LVL_BEHAVIOR',
            'python_class_name': 'CIChannel',
            'python_data_type': 'LogicLvlBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12529: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the gate input signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_DIG_FLTR_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12530: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the digital filter recognizes.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12531: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'CIChannel',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12532: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12533: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the counter gates input pulses while the signal is high or low.',
            'enum': 'Level1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_WHEN',
            'python_class_name': 'CIChannel',
            'python_data_type': 'Level1',
            'resettable': True,
            'type': 'int32'
        },
        12535: {
            'access': 'read-write',
            'c_function_name': 'AIBridgeShuntCalShuntCalBSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether to use an internal or external shunt when Shunt Cal B is selected.',
            'enum': 'BridgeShuntCalSource',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_BRIDGE_SHUNT_CAL_SHUNT_CAL_B_SRC',
            'python_class_name': 'AIChannel',
            'python_data_type': 'BridgeShuntCalSource',
            'resettable': True,
            'type': 'int32'
        },
        12541: {
            'access': 'read-write',
            'c_function_name': 'AIExcitSense',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether to use local or remote sense to sense excitation.',
            'enum': 'Sense',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_EXCIT_SENSE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'Sense',
            'resettable': True,
            'type': 'int32'
        },
        12543: {
            'access': 'read-write',
            'c_function_name': 'AIOpenChanDetectEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable open channel detection.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_OPEN_CHAN_DETECT_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12562: {
            'access': 'read-write',
            'c_function_name': 'AIChargeUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units to use to return charge measurements from the channel.',
            'enum': 'ChargeUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CHARGE_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'ChargeUnits',
            'resettable': True,
            'type': 'int32'
        },
        12563: {
            'access': 'read-write',
            'c_function_name': 'AIAccelChargeSensitivity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the charge acceleration sensor connected to the channel. This value is the units you specify with AI.Accel.Charge.SensitivityUnits. Refer to the sensor documentation to determine this value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ACCEL_CHARGE_SENSITIVITY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12564: {
            'access': 'read-write',
            'c_function_name': 'AIAccelChargeSensitivityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of AI.Accel.Charge.Sensitivity.',
            'enum': 'AccelChargeSensitivityUnits',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ACCEL_CHARGE_SENSITIVITY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'AccelChargeSensitivityUnits',
            'resettable': True,
            'type': 'int32'
        },
        12565: {
            'access': 'read-write',
            'c_function_name': 'AIAccel4WireDCVoltageSensitivity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sensitivity of the 4 wire DC voltage acceleration sensor connected to the channel. This value is the units you specify with AI.Accel.4WireDCVoltage.SensitivityUnits. Refer to the sensor documentation to determine this value.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ACCEL_4_WIRE_DC_VOLTAGE_SENSITIVITY',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12566: {
            'access': 'read-write',
            'c_function_name': 'AIAccel4WireDCVoltageSensitivityUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of AI.Accel.4WireDCVoltage.Sensitivity.',
            'enum': 'AccelSensitivityUnits1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_ACCEL_4_WIRE_DC_VOLTAGE_SENSITIVITY_UNITS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'AccelSensitivityUnits1',
            'resettable': True,
            'type': 'int32'
        },
        12567: {
            'access': 'read-write',
            'c_function_name': 'AIDataXferMaxRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the rate in B/s to transfer data from the device. If this value is not set, then the device will transfer data at a rate based on the bus detected. Modify this value to affect performance under different combinations of operating system, configuration, and device.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_DATA_XFER_MAX_RATE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12604: {
            'access': 'read-write',
            'c_function_name': 'ChanSyncUnlockBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the action to take if the target loses its synchronization to the grand master.',
            'enum': 'SyncUnlockBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CHAN_SYNC_UNLOCK_BEHAVIOR',
            'python_class_name': 'Channel',
            'python_data_type': 'SyncUnlockBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12611: {
            'access': 'read-write',
            'c_function_name': 'AIChopEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether the device will chop its inputs. Chopping removes offset voltages and other low frequency errors.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CHOP_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12649: {
            'access': 'read-write',
            'c_function_name': 'AISensorPowerVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': "Specifies the voltage level for the sensor's power supply.",
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_SENSOR_POWER_VOLTAGE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12650: {
            'access': 'read-write',
            'c_function_name': 'AISensorPowerCfg',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': "Specifies whether to turn on the sensor's power supply or to leave the configuration unchanged.",
            'enum': 'SensorPowerCfg',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_SENSOR_POWER_CFG',
            'python_class_name': 'AIChannel',
            'python_data_type': 'SensorPowerCfg',
            'resettable': True,
            'type': 'int32'
        },
        12651: {
            'access': 'read-write',
            'c_function_name': 'AISensorPowerType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of power supplied to the sensor.',
            'enum': 'SensorPowerType',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_SENSOR_POWER_TYPE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'SensorPowerType',
            'resettable': True,
            'type': 'int32'
        },
        12659: {
            'access': 'read-write',
            'c_function_name': 'AIFilterEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies the corresponding filter enable/disable state.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FILTER_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12660: {
            'access': 'read-write',
            'c_function_name': 'AIFilterFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the corresponding filter frequency (cutoff or center) of the filter response.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FILTER_FREQ',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12661: {
            'access': 'read-write',
            'c_function_name': 'AIFilterResponse',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the corresponding filter response and defines the shape of the filter response.',
            'enum': 'FilterResponse1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FILTER_RESPONSE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'FilterResponse1',
            'resettable': True,
            'type': 'int32'
        },
        12662: {
            'access': 'read-write',
            'c_function_name': 'AIFilterOrder',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the corresponding filter order and defines the slope of the filter response.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_FILTER_ORDER',
            'python_class_name': 'AIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12684: {
            'access': 'read-write',
            'c_function_name': 'AIInputLimitsFaultDetectUpperLimit',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the level of the upper limit for input limits detection. An input sample outside the upper and lower bounds causes a fault. Note: Fault detection applies to both positive and negative inputs. For instance, if you specify a lower limit of 2 mA and an upper limit of 12 mA, NI-DAQmx detects a fault at 15 mA and -15 mA, but not at -6 mA because it is in the range of -12 mA to -2 mA.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_INPUT_LIMITS_FAULT_DETECT_UPPER_LIMIT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12685: {
            'access': 'read-write',
            'c_function_name': 'AIInputLimitsFaultDetectLowerLimit',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the level of the lower limit for input limits detection. An input sample outside the upper and lower bounds causes a fault. Note: Fault detection applies to both positive and negative inputs. For instance, if you specify a lower limit of 2 mA and an upper limit of 12 mA, NI-DAQmx detects a fault at 15 mA and -15 mA, but not at -6 mA because it is in the range of -12 mA to -2 mA.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_INPUT_LIMITS_FAULT_DETECT_LOWER_LIMIT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12686: {
            'access': 'read-write',
            'c_function_name': 'AIInputLimitsFaultDetectEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable input limits fault detection.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_INPUT_LIMITS_FAULT_DETECT_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12689: {
            'access': 'read-write',
            'c_function_name': 'AIPowerSupplyFaultDetectEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable power supply fault detection.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_POWER_SUPPLY_FAULT_DETECT_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12692: {
            'access': 'read-write',
            'c_function_name': 'AIOvercurrentDetectEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable overcurrent detection.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_OVERCURRENT_DETECT_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12715: {
            'access': 'read-write',
            'c_function_name': 'CIFreqThreshVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the voltage level at which to recognize waveform repetitions. Select a voltage level that occurs only once within the entire period of a waveform. You also can select a voltage that occurs only once while the voltage rises or falls.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_THRESH_VOLTAGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12716: {
            'access': 'read-write',
            'c_function_name': 'CIFreqHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a hysteresis level to apply to **ci_freq_thresh_voltage**. When **ci_freq_starting_edge** is rising, the source signal must first fall below **ci_freq_thresh_voltage** minus the hysteresis before a rising edge is detected at **ci_freq_thresh_voltage**. When **ci_freq_starting_edge** is falling, the source signal must first rise above **ci_freq_thresh_voltage** plus the hysteresis before a falling edge is detected at **ci_freq_thresh_voltage**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FREQ_HYST',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12717: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodThreshVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the voltage level at which to recognize waveform repetitions. Select a voltage level that occurs only once within the entire period of a waveform. You also can select a voltage that occurs only once while the voltage rises or falls.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_THRESH_VOLTAGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12718: {
            'access': 'read-write',
            'c_function_name': 'CIPeriodHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a hysteresis level to apply to **ci_period_thresh_voltage**. When **ci_period_starting_edge** is rising, the source signal must first fall below **ci_period_thresh_voltage** minus the hysteresis before a rising edge is detected at **ci_period_thresh_voltage**. When **ci_period_starting_edge** is falling, the source signal must first rise above **ci_period_thresh_voltage** plus the hysteresis before a falling edge is detected at **ci_period_thresh_voltage**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_PERIOD_HYST',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12719: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesThreshVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the voltage level at which to recognize waveform repetitions. Select a voltage level that occurs only once within the entire period of a waveform. You also can select a voltage that occurs only once while the voltage rises or falls.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_THRESH_VOLTAGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12720: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a hysteresis level to apply to **ci_count_edges_thresh_voltage**. When **ci_count_edges_active_edge** is rising, the source signal must first fall below **ci_count_edges_thresh_voltage** minus the hysteresis before a rising edge is detected at **ci_count_edges_thresh_voltage**. When **ci_count_edges_active_edge** is falling, the source signal must first rise above **ci_count_edges_thresh_voltage** plus the hysteresis before a falling edge is detected at **ci_count_edges_thresh_voltage**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_HYST',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12721: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountDirThreshVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the voltage level applied to the Count Direction terminal. When the signal is above this threshold, the counter counts up. When the signal is below this threshold, the counter counts down.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_DIR_THRESH_VOLTAGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12722: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountDirHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a hysteresis level applied to the **ci_count_edges_count_dir_thresh_voltage**. The source signal must fall below **ci_count_edges_count_dir_thresh_voltage** minus the hysteresis before a change in count direction occurs.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_DIR_HYST',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12723: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetThreshVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the voltage level at which to recognize the counter reset event.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_THRESH_VOLTAGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12724: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesCountResetHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a hysteresis level applied to **ci_count_edges_count_reset_thresh_voltage**. When **ci_count_edges_count_reset_active_edge** is rising, the source signal must first fall below **ci_count_edges_count_reset_thresh_voltage** minus the hysteresis before a rising edge is detected at **ci_count_edges_count_reset_thresh_voltage**. When **ci_count_edges_count_reset_active_edge** is falling, the source signal must first rise above **ci_count_edges_count_reset_thresh_voltage** plus the hysteresis before a falling edge is detected at **ci_count_edges_count_reset_thresh_voltage**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_COUNT_RESET_HYST',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12725: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateThreshVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the voltage level at which to recognize the counter gate signal.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_THRESH_VOLTAGE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12726: {
            'access': 'read-write',
            'c_function_name': 'CICountEdgesGateHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a hysteresis level applied to the **ci_count_edges_gate_thresh_voltage**. When **ci_count_edges_gate_when** is High, the source signal must fall below **ci_count_edges_gate_thresh_voltage** minus the hysteresis before the counter resumes counting. When **ci_count_edges_gate_when** is Low, the source signal must rise above **ci_count_edges_gate_thresh_voltage** plus the hysteresis before the counter resumes counting.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_COUNT_EDGES_GATE_HYST',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12727: {
            'access': 'read-write',
            'c_function_name': 'CIFilterEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies the corresponding filter enable/disable state.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FILTER_ENABLE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12728: {
            'access': 'read-write',
            'c_function_name': 'CIFilterFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the corresponding filter frequency (cutoff or center) of the filter response.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FILTER_FREQ',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12729: {
            'access': 'read-write',
            'c_function_name': 'CIFilterResponse',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the corresponding filter response and defines the shape of the filter response.',
            'enum': 'FilterResponse1',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FILTER_RESPONSE',
            'python_class_name': 'CIChannel',
            'python_data_type': 'FilterResponse1',
            'resettable': True,
            'type': 'int32'
        },
        12730: {
            'access': 'read-write',
            'c_function_name': 'CIFilterOrder',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the corresponding filter order and defines the slope of the filter response.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FILTER_ORDER',
            'python_class_name': 'CIChannel',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12731: {
            'access': 'read',
            'c_function_name': 'CIFilterDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the amount of time between when the input signal transitions and when the filtered sample is read by the host device. This value is in the units specified with **ci_filter_delay_units**.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FILTER_DELAY',
            'python_class_name': 'CIChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12732: {
            'access': 'read-write',
            'c_function_name': 'CIFilterDelayUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **ci_filter_delay**.',
            'enum': 'DigitalWidthUnits4',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_FILTER_DELAY_UNITS',
            'python_class_name': 'CIChannel',
            'python_data_type': 'DigitalWidthUnits4',
            'resettable': True,
            'type': 'int32'
        },
        12740: {
            'access': 'read-write',
            'c_function_name': 'AOFuncGenStartPhase',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the starting phase in degrees of the waveform to generate.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_FUNC_GEN_START_PHASE',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12748: {
            'access': 'read-write',
            'c_function_name': 'AOCommonModeOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the common-mode offset of the AO channel. Use the property only when Terminal Configuration is set to Differential.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_COMMON_MODE_OFFSET',
            'python_class_name': 'AOChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12756: {
            'access': 'read-write',
            'c_function_name': 'PwrVoltageSetpoint',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the constant output voltage, in volts. Can be set while a task is running. Can be read at any time during a task.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PWR_VOLTAGE_SETPOINT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12757: {
            'access': 'read-write',
            'c_function_name': 'PwrCurrentSetpoint',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the output current, in amperes. If the load draws current greater than the specified value, the device will operate in Constant Current mode.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PWR_CURRENT_SETPOINT',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12758: {
            'access': 'read-write',
            'c_function_name': 'PwrOutputEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable or disable power module output. Can be set while a task is running. Can be read at any time during a task. When a task is running, the output is enabled immediately. Otherwise, the output is not enabled until the task enters the Committed state.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PWR_OUTPUT_ENABLE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12759: {
            'access': 'read',
            'c_function_name': 'PwrOutputState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates power channel operating state. Can be read at any time during a task.',
            'enum': 'PowerOutputState',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PWR_OUTPUT_STATE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'PowerOutputState',
            'resettable': False,
            'type': 'int32'
        },
        12760: {
            'access': 'read-write',
            'c_function_name': 'PwrIdleOutputBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether to disable the output or maintain the existing value after the task is uncommitted.',
            'enum': 'PowerIdleOutputBehavior',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PWR_IDLE_OUTPUT_BEHAVIOR',
            'python_class_name': 'AIChannel',
            'python_data_type': 'PowerIdleOutputBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12761: {
            'access': 'read',
            'c_function_name': 'PwrVoltageDevScalingCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the coefficients of the polynomial equation that NI-DAQmx uses to scale values from the native format of the device to volts. Can be read at any time during a task.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PWR_VOLTAGE_DEV_SCALING_COEFF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        12762: {
            'access': 'read',
            'c_function_name': 'PwrCurrentDevScalingCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the coefficients of the polynomial equation that NI-DAQmx uses to scale values from the native format of the device to amperes. Can be read at any time during a task.',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PWR_CURRENT_DEV_SCALING_COEFF',
            'python_class_name': 'AIChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        12763: {
            'access': 'read-write',
            'c_function_name': 'PwrRemoteSense',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether to use local or remote sense to sense the output voltage. DAQmx Read (Power) will return remote or local voltage based on the Remote Sense attribute value. Reading this property will return the user-defined value.',
            'enum': 'Sense',
            'handle_parameters': {
                'channelHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'channel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PWR_REMOTE_SENSE',
            'python_class_name': 'AIChannel',
            'python_data_type': 'Sense',
            'resettable': True,
            'type': 'int32'
        }
    },
    'Device': {
        1585: {
            'access': 'read',
            'c_function_name': 'DevProductType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the product name of the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PRODUCT_TYPE',
            'python_class_name': 'Device',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        1586: {
            'access': 'read',
            'c_function_name': 'DevSerialNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the serial number of the device. This value is zero if the device does not have a serial number.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SERIAL_NUM',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8906: {
            'access': 'read',
            'c_function_name': 'DevIsSimulated',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device is a simulated device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'IS_SIMULATED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8989: {
            'access': 'read',
            'c_function_name': 'DevProductNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the unique hardware identification number for the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PRODUCT_NUM',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8990: {
            'access': 'read',
            'c_function_name': 'DevAIPhysicalChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the analog input physical channels available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'AI_PHYSICAL_CHANS',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Device',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        8991: {
            'access': 'read',
            'c_function_name': 'DevAOPhysicalChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the analog output physical channels available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'AO_PHYSICAL_CHANS',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Device',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        8992: {
            'access': 'read',
            'c_function_name': 'DevDILines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the digital input lines available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'DI_LINES',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Device',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        8993: {
            'access': 'read',
            'c_function_name': 'DevDIPorts',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the digital input ports available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'DI_PORTS',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Device',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        8994: {
            'access': 'read',
            'c_function_name': 'DevDOLines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the digital output lines available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'DO_LINES',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Device',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        8995: {
            'access': 'read',
            'c_function_name': 'DevDOPorts',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the digital output ports available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'DO_PORTS',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Device',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        8996: {
            'access': 'read',
            'c_function_name': 'DevCIPhysicalChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the counter input physical channels available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'CI_PHYSICAL_CHANS',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Device',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        8997: {
            'access': 'read',
            'c_function_name': 'DevCOPhysicalChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the counter output physical channels available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'CO_PHYSICAL_CHANS',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Device',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        8998: {
            'access': 'read',
            'c_function_name': 'DevBusType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the bus type of the device.',
            'enum': 'BusType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'BUS_TYPE',
            'python_class_name': 'Device',
            'python_data_type': 'BusType',
            'resettable': False,
            'type': 'int32'
        },
        8999: {
            'access': 'read',
            'c_function_name': 'DevPCIBusNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the PCI bus number of the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PCI_BUS_NUM',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        9000: {
            'access': 'read',
            'c_function_name': 'DevPCIDevNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the PCI slot number of the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PCI_DEV_NUM',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        9001: {
            'access': 'read',
            'c_function_name': 'DevPXIChassisNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the PXI chassis number of the device, as identified in MAX.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PXI_CHASSIS_NUM',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        9002: {
            'access': 'read',
            'c_function_name': 'DevPXISlotNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the PXI slot number of the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PXI_SLOT_NUM',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        9020: {
            'access': 'read',
            'c_function_name': 'DevNumDMAChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of DMA channels on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NUM_DMA_CHANS',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        10628: {
            'access': 'read',
            'c_function_name': 'DevAnlgTrigSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device supports analog triggering.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_TRIG_SUPPORTED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10629: {
            'access': 'read',
            'c_function_name': 'DevDigTrigSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device supports digital triggering.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_TRIG_SUPPORTED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10630: {
            'access': 'read',
            'bitfield_enum': '_TriggerUsageTypes',
            'c_function_name': 'DevAITrigUsage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the triggers supported by this device for an analog input task.',
            'enum': 'TriggerUsage',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': True,
            'is_object': False,
            'name': 'AI_TRIG_USAGE',
            'python_class_name': 'Device',
            'python_data_type': 'TriggerUsage',
            'resettable': False,
            'type': 'int32[]'
        },
        10631: {
            'access': 'read',
            'bitfield_enum': '_TriggerUsageTypes',
            'c_function_name': 'DevAOTrigUsage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the triggers supported by this device for analog output tasks.',
            'enum': 'TriggerUsage',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': True,
            'is_object': False,
            'name': 'AO_TRIG_USAGE',
            'python_class_name': 'Device',
            'python_data_type': 'TriggerUsage',
            'resettable': False,
            'type': 'int32[]'
        },
        10632: {
            'access': 'read',
            'bitfield_enum': '_TriggerUsageTypes',
            'c_function_name': 'DevDITrigUsage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the triggers supported by this device for digital input tasks.',
            'enum': 'TriggerUsage',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': True,
            'is_object': False,
            'name': 'DI_TRIG_USAGE',
            'python_class_name': 'Device',
            'python_data_type': 'TriggerUsage',
            'resettable': False,
            'type': 'int32[]'
        },
        10633: {
            'access': 'read',
            'bitfield_enum': '_TriggerUsageTypes',
            'c_function_name': 'DevDOTrigUsage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the triggers supported by this device for digital output tasks.',
            'enum': 'TriggerUsage',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': True,
            'is_object': False,
            'name': 'DO_TRIG_USAGE',
            'python_class_name': 'Device',
            'python_data_type': 'TriggerUsage',
            'resettable': False,
            'type': 'int32[]'
        },
        10634: {
            'access': 'read',
            'bitfield_enum': '_TriggerUsageTypes',
            'c_function_name': 'DevCITrigUsage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the triggers supported by this device for counter input tasks.',
            'enum': 'TriggerUsage',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': True,
            'is_object': False,
            'name': 'CI_TRIG_USAGE',
            'python_class_name': 'Device',
            'python_data_type': 'TriggerUsage',
            'resettable': False,
            'type': 'int32[]'
        },
        10635: {
            'access': 'read',
            'bitfield_enum': '_TriggerUsageTypes',
            'c_function_name': 'DevCOTrigUsage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the triggers supported by this device for counter output tasks.',
            'enum': 'TriggerUsage',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': True,
            'is_object': False,
            'name': 'CO_TRIG_USAGE',
            'python_class_name': 'Device',
            'python_data_type': 'TriggerUsage',
            'resettable': False,
            'type': 'int32[]'
        },
        10636: {
            'access': 'read',
            'c_function_name': 'DevAIMaxSingleChanRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the maximum rate for an analog input task if the task contains only a single channel from this device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_MAX_SINGLE_CHAN_RATE',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10637: {
            'access': 'read',
            'c_function_name': 'DevAIMaxMultiChanRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the maximum sampling rate for an analog input task from this device. To find the maximum rate for the task, take the minimum of **ai_max_single_chan_rate** or the indicated sampling rate of this device divided by the number of channels to acquire data from (including cold-junction compensation and autozero channels).',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_MAX_MULTI_CHAN_RATE',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10638: {
            'access': 'read',
            'c_function_name': 'DevAIMinRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the minimum rate for an analog input task on this device. NI-DAQmx returns a warning or error if you attempt to sample at a slower rate.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_MIN_RATE',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10639: {
            'access': 'read',
            'c_function_name': 'DevAISimultaneousSamplingSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device supports simultaneous sampling.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_SIMULTANEOUS_SAMPLING_SUPPORTED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10640: {
            'access': 'read',
            'c_function_name': 'DevAIVoltageRngs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates pairs of input voltage ranges supported by this device. Each pair consists of the low value, followed by the high value.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_VOLTAGE_RNGS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10641: {
            'access': 'read',
            'c_function_name': 'DevAICurrentRngs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the pairs of current input ranges supported by this device. Each pair consists of the low value, followed by the high value.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_CURRENT_RNGS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10642: {
            'access': 'read',
            'c_function_name': 'DevAIFreqRngs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the pairs of frequency input ranges supported by this device. Each pair consists of the low value, followed by the high value.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_FREQ_RNGS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10643: {
            'access': 'read',
            'c_function_name': 'DevAIGains',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the input gain settings supported by this device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_GAINS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10644: {
            'access': 'read',
            'bitfield_enum': '_CouplingTypes',
            'c_function_name': 'DevAICouplings',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the coupling types supported by this device.',
            'enum': 'Coupling1',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': True,
            'is_object': False,
            'name': 'AI_COUPLINGS',
            'python_class_name': 'Device',
            'python_data_type': 'Coupling1',
            'resettable': False,
            'type': 'int32[]'
        },
        10645: {
            'access': 'read',
            'c_function_name': 'DevAILowpassCutoffFreqDiscreteVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the set of discrete lowpass cutoff frequencies supported by this device. If the device supports ranges of lowpass cutoff frequencies, use **ai_lowpass_cutoff_freq_range_vals** to determine supported frequencies.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_LOWPASS_CUTOFF_FREQ_DISCRETE_VALS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10646: {
            'access': 'read',
            'c_function_name': 'DevAOSampClkSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device supports the sample clock timing  type for analog output tasks.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_SAMP_CLK_SUPPORTED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10647: {
            'access': 'read',
            'c_function_name': 'DevAOMaxRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the maximum analog output rate of the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_MAX_RATE',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10648: {
            'access': 'read',
            'c_function_name': 'DevAOMinRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the minimum analog output rate of the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_MIN_RATE',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10649: {
            'access': 'read',
            'c_function_name': 'DevDIMaxRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the maximum digital input rate of the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_MAX_RATE',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10650: {
            'access': 'read',
            'c_function_name': 'DevDOMaxRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the maximum digital output rate of the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_MAX_RATE',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10651: {
            'access': 'read',
            'c_function_name': 'DevAOVoltageRngs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates pairs of output voltage ranges supported by this device. Each pair consists of the low value, followed by the high value.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AO_VOLTAGE_RNGS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10652: {
            'access': 'read',
            'c_function_name': 'DevAOCurrentRngs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates pairs of output current ranges supported by this device. Each pair consists of the low value, followed by the high value.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AO_CURRENT_RNGS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10653: {
            'access': 'read',
            'c_function_name': 'DevAOGains',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the output gain settings supported by this device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AO_GAINS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10654: {
            'access': 'read',
            'c_function_name': 'DevCISampClkSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device supports the sample clock timing type for counter input tasks.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_SAMP_CLK_SUPPORTED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10655: {
            'access': 'read',
            'c_function_name': 'DevCIMaxSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in bits the size of the counters on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_MAX_SIZE',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        10656: {
            'access': 'read',
            'c_function_name': 'DevCIMaxTimebase',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates in hertz the maximum counter timebase frequency.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_MAX_TIMEBASE',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10657: {
            'access': 'read',
            'c_function_name': 'DevCOMaxSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in bits the size of the counters on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_MAX_SIZE',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        10658: {
            'access': 'read',
            'c_function_name': 'DevCOMaxTimebase',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates in hertz the maximum counter timebase frequency.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_MAX_TIMEBASE',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10665: {
            'access': 'read',
            'c_function_name': 'DevProductCategory',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the product category of the device. This category corresponds to the category displayed in MAX when creating NI-DAQmx simulated devices.',
            'enum': 'ProductCategory',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PRODUCT_CATEGORY',
            'python_class_name': 'Device',
            'python_data_type': 'ProductCategory',
            'resettable': False,
            'type': 'int32'
        },
        10678: {
            'access': 'read',
            'c_function_name': 'DevChassisModuleDevNames',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the modules in the chassis.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'CHASSIS_MODULE_DEV_NAMES',
            'object_module_location': 'nidaqmx.system.device',
            'object_type': 'Device',
            'python_class_name': 'Device',
            'python_data_type': 'Device',
            'resettable': False,
            'type': 'char[]'
        },
        10679: {
            'access': 'read',
            'c_function_name': 'DevCompactDAQChassisDevName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the CompactDAQ chassis that contains this module.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'COMPACT_DAQ_CHASSIS_DEV_NAME',
            'object_module_location': 'nidaqmx.system.device',
            'object_type': 'Device',
            'python_class_name': 'Device',
            'python_data_type': 'Device',
            'resettable': False,
            'type': 'char[]'
        },
        10680: {
            'access': 'read',
            'c_function_name': 'DevCompactDAQSlotNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the slot number in which this module is located in the CompactDAQ chassis.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'COMPACT_DAQ_SLOT_NUM',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        10697: {
            'access': 'read',
            'c_function_name': 'DevAIVoltageIntExcitDiscreteVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the set of discrete internal voltage excitation values supported by this device. If the device supports ranges of internal excitation values, use **ai_voltage_int_excit_range_vals** to determine supported excitation values.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_VOLTAGE_INT_EXCIT_DISCRETE_VALS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10698: {
            'access': 'read',
            'c_function_name': 'DevAIVoltageIntExcitRangeVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates pairs of internal voltage excitation ranges supported by this device. Each pair consists of the low value, followed by the high value. If the device supports a set of discrete internal excitation values, use **ai_voltage_int_excit_discrete_vals** to determine the supported excitation values.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_VOLTAGE_INT_EXCIT_RANGE_VALS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10699: {
            'access': 'read',
            'c_function_name': 'DevAICurrentIntExcitDiscreteVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the set of discrete internal current excitation values supported by this device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_CURRENT_INT_EXCIT_DISCRETE_VALS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10703: {
            'access': 'read',
            'c_function_name': 'DevAILowpassCutoffFreqRangeVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates pairs of lowpass cutoff frequency ranges supported by this device. Each pair consists of the low value, followed by the high value. If the device supports a set of discrete lowpass cutoff frequencies, use **ai_lowpass_cutoff_freq_discrete_vals** to determine the supported  frequencies.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_LOWPASS_CUTOFF_FREQ_RANGE_VALS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10773: {
            'access': 'read',
            'c_function_name': 'DevAIResistanceRngs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates pairs of input resistance ranges, in ohms, supported by devices that have the necessary signal conditioning to measure resistances. Each pair consists of the low value followed by the high value.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_RESISTANCE_RNGS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        10816: {
            'access': 'read',
            'c_function_name': 'DevTerminals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of all terminals on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'TERMINALS',
            'python_class_name': 'N/A',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        10890: {
            'access': 'read',
            'c_function_name': 'CarrierSerialNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the serial number of the device carrier. This value is zero if the carrier does not have a serial number.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CARRIER_SERIAL_NUM',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        10891: {
            'access': 'read',
            'c_function_name': 'DevTCPIPHostname',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the IPv4 hostname of the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TCPIP_HOSTNAME',
            'python_class_name': 'Device',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        10892: {
            'access': 'read',
            'c_function_name': 'DevTCPIPEthernetIP',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the IPv4 address of the Ethernet interface in dotted decimal format. This property returns 0.0.0.0 if the Ethernet interface cannot acquire an address.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TCPIP_ETHERNET_IP',
            'python_class_name': 'Device',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        10893: {
            'access': 'read',
            'c_function_name': 'DevTCPIPWirelessIP',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the IPv4 address of the 802.11 wireless interface in dotted decimal format. This property returns 0.0.0.0 if the wireless interface cannot acquire an address.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TCPIP_WIRELESS_IP',
            'python_class_name': 'Device',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12123: {
            'access': 'read',
            'c_function_name': 'DevCOSampClkSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device supports Sample Clock timing for counter output tasks.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_SAMP_CLK_SUPPORTED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12141: {
            'access': 'read',
            'c_function_name': 'DevAccessoryProductTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the model names of accessories connected to the device. Each list element corresponds to a connector. For example, index 0 corresponds to connector 0. The list contains an empty string for each connector with no accessory connected.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ACCESSORY_PRODUCT_TYPES',
            'python_class_name': 'Device',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12142: {
            'access': 'read',
            'c_function_name': 'DevAccessoryProductNums',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.uint32',
            'description': 'Indicates the unique hardware identification number for accessories connected to the device. Each list element corresponds to a connector. For example, index 0 corresponds to connector 0. The list contains 0 for each connector with no accessory connected.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ACCESSORY_PRODUCT_NUMS',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32[]'
        },
        12143: {
            'access': 'read',
            'c_function_name': 'DevAccessorySerialNums',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.uint32',
            'description': 'Indicates the serial number for accessories connected to the device. Each list element corresponds to a connector. For example, index 0 corresponds to connector 0. The list contains 0 for each connector with no accessory connected.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ACCESSORY_SERIAL_NUMS',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32[]'
        },
        12240: {
            'access': 'read',
            'c_function_name': 'DevAIBridgeRngs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates pairs of input voltage ratio ranges, in volts per volt, supported by devices that acquire using ratiometric measurements. Each pair consists of the low value followed by the high value.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_BRIDGE_RNGS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        12242: {
            'access': 'read',
            'c_function_name': 'DevAISupportedMeasTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the measurement types supported by the physical channels of the device. Refer to **ai_meas_types** for information on specific channels.',
            'enum': 'AIMeasurementType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_SUPPORTED_MEAS_TYPES',
            'python_class_name': 'Device',
            'python_data_type': 'AIMeasurementType',
            'resettable': False,
            'type': 'int32[]'
        },
        12243: {
            'access': 'read',
            'c_function_name': 'DevAOSupportedOutputTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the generation types supported by the physical channels of the device. Refer to **ao_output_types** for information on specific channels.',
            'enum': 'AOOutputChannelType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AO_SUPPORTED_OUTPUT_TYPES',
            'python_class_name': 'Device',
            'python_data_type': 'AOOutputChannelType',
            'resettable': False,
            'type': 'int32[]'
        },
        12244: {
            'access': 'read',
            'c_function_name': 'DevCISupportedMeasTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the measurement types supported by the physical channels of the device. Refer to **ci_meas_types** for information on specific channels.',
            'enum': 'CIMeasurementType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'CI_SUPPORTED_MEAS_TYPES',
            'python_class_name': 'Device',
            'python_data_type': 'CIMeasurementType',
            'resettable': False,
            'type': 'int32[]'
        },
        12245: {
            'access': 'read',
            'c_function_name': 'DevCOSupportedOutputTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the generation types supported by the physical channels of the device. Refer to **co_output_types** for information on specific channels.',
            'enum': 'COOutputType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'CO_SUPPORTED_OUTPUT_TYPES',
            'python_class_name': 'Device',
            'python_data_type': 'COOutputType',
            'resettable': False,
            'type': 'int32[]'
        },
        12246: {
            'access': 'read',
            'c_function_name': 'DevTEDSHWTEDSSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the device supports hardware TEDS.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TEDS_HWTEDS_SUPPORTED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12252: {
            'access': 'read',
            'c_function_name': 'DevAISampModes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates sample modes supported by devices that support sample clocked analog input.',
            'enum': 'AcquisitionType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_SAMP_MODES',
            'python_class_name': 'Device',
            'python_data_type': 'AcquisitionType',
            'resettable': False,
            'type': 'int32[]'
        },
        12253: {
            'access': 'read',
            'c_function_name': 'DevAOSampModes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates sample modes supported by devices that support sample clocked analog output.',
            'enum': 'AcquisitionType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AO_SAMP_MODES',
            'python_class_name': 'Device',
            'python_data_type': 'AcquisitionType',
            'resettable': False,
            'type': 'int32[]'
        },
        12254: {
            'access': 'read',
            'c_function_name': 'DevCISampModes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates sample modes supported by devices that support sample clocked counter input.',
            'enum': 'AcquisitionType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'CI_SAMP_MODES',
            'python_class_name': 'Device',
            'python_data_type': 'AcquisitionType',
            'resettable': False,
            'type': 'int32[]'
        },
        12255: {
            'access': 'read',
            'c_function_name': 'DevCOSampModes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates sample modes supported by devices that support sample clocked counter output.',
            'enum': 'AcquisitionType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'CO_SAMP_MODES',
            'python_class_name': 'Device',
            'python_data_type': 'AcquisitionType',
            'resettable': False,
            'type': 'int32[]'
        },
        12319: {
            'access': 'read',
            'c_function_name': 'DevTimeTrigSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the device supports time triggering.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TIME_TRIG_SUPPORTED',
            'python_class_name': 'Device',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12320: {
            'access': 'read',
            'c_function_name': 'DevCICurrentUTCOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the current UTC offset. This is used to convert from TAI to UTC time. TAI Time + UTC Offset = UTC.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_CURRENT_UTC_OFFSET',
            'python_class_name': 'N/A',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'int32'
        },
        12321: {
            'access': 'read',
            'c_function_name': 'DevCIUTCOffsetReady',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the device has the information necessary to scale time from UTC to TAI .',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CI_UTC_OFFSET_READY',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12322: {
            'access': 'read',
            'c_function_name': 'DevNavPhysicalChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates an list containing the names of the navigation physical channels available on the device .',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'NAV_PHYSICAL_CHANS',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'N/A',
            'python_data_type': 'PhysicalChannel',
            'resettable': False,
            'type': 'char[]'
        },
        12323: {
            'access': 'read',
            'c_function_name': 'DevNavSupportedMeasTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the measurement types supported by the physical channels of the device.',
            'enum': 'NavMeasurementType',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'NAV_SUPPORTED_MEAS_TYPES',
            'python_class_name': 'N/A',
            'python_data_type': 'NavMeasurementType',
            'resettable': False,
            'type': 'int32[]'
        },
        12324: {
            'access': 'read',
            'c_function_name': 'DevNavTrigUsage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the trigger types supported by the device for a given measurement type.',
            'enum': 'TriggerUsage',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'NAV_TRIG_USAGE',
            'python_class_name': 'N/A',
            'python_data_type': 'TriggerUsage',
            'resettable': False,
            'type': 'int32[]'
        },
        12325: {
            'access': 'read-write',
            'c_function_name': 'DevNavMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the mode of the navigation device. Changing this property will cause running tasks to abort. This property is persistent.',
            'enum': 'NavMode',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_MODE',
            'python_class_name': 'N/A',
            'python_data_type': 'NavMode',
            'resettable': False,
            'type': 'int32'
        },
        12326: {
            'access': 'read-write',
            'c_function_name': 'DevNavPresetLat',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the latitude location in degrees of the device to be used in stationary with preset location mode. This property is set by a user who knows the location and does not need a survey to occur. This property is persistent and will only take effect when the device is in stationary with preset mode.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_PRESET_LAT',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12327: {
            'access': 'read-write',
            'c_function_name': 'DevNavPresetLong',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the longitude location in degrees of the device to be used in stationary with preset location mode. This property is set by a user who knows the location and does not need a survey to occur. This property is persistent and will only take effect when the device is in stationary with preset mode.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_PRESET_LONG',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12328: {
            'access': 'read-write',
            'c_function_name': 'DevNavPresetAlt',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the altitude location in meters of the device to be used in stationary with preset location mode. This property is set by a user who knows the location and does not want a survey to occur. This property is persistent and will only take effect when the device is in stationary with preset mode.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_PRESET_ALT',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12329: {
            'access': 'read-write',
            'c_function_name': 'DevNavAltRef',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the method to use to calculate altitude. This property is persistent.',
            'enum': 'AltRef',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_ALT_REF',
            'python_class_name': 'N/A',
            'python_data_type': 'AltRef',
            'resettable': False,
            'type': 'int32'
        },
        12330: {
            'access': 'read-write',
            'c_function_name': 'DevNavPPSCompen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates in seconds the delay for the PPS (Pulse Per Second). To compensate for antenna delay, the amount should be negative. This property is persistent.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_PPS_COMPEN',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12331: {
            'access': 'read-write',
            'c_function_name': 'DevNavNumSurveyFixes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of fixes for a survey. The number of fixes is the same as seconds assuming the devices never loses a fix. This property is persistent.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_NUM_SURVEY_FIXES',
            'python_class_name': 'N/A',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12332: {
            'access': 'read',
            'c_function_name': 'DevNavRemainingSurveyFixes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the remaining number of fixes left for the survey. If a devices loses a fix, then it will pause the survey until it obtains a fix again and continues from where it left off.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_REMAINING_SURVEY_FIXES',
            'python_class_name': 'N/A',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12333: {
            'access': 'read',
            'c_function_name': 'DevNavHasFix',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the device currently has a fix.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_HAS_FIX',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12334: {
            'access': 'read',
            'c_function_name': 'DevNavAntStatus',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the status of the antenna.',
            'enum': 'AntStatus',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_ANT_STATUS',
            'python_class_name': 'N/A',
            'python_data_type': 'AntStatus',
            'resettable': False,
            'type': 'int32'
        },
        12335: {
            'access': 'read',
            'c_function_name': 'DevNavUTCOffsetReady',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the device has the information necessary to scale time from UTC to TAI.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_UTC_OFFSET_READY',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12336: {
            'access': 'read',
            'c_function_name': 'DevNavCurrentUTCOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the current UTC offset. This is used to convert from TAI to UTC time. TAI Time + UTC Offset = UTC.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_CURRENT_UTC_OFFSET',
            'python_class_name': 'N/A',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'int32'
        },
        12337: {
            'access': 'read',
            'c_function_name': 'DevNavNumSats',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the current UTC offset. This is used to convert from TAI to UTC time. TAI Time + UTC Offset = UTC.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_NUM_SATS',
            'python_class_name': 'N/A',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12338: {
            'access': 'read',
            'c_function_name': 'DevNavPDOP',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Position dilution of precision.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_PDOP',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12339: {
            'access': 'read',
            'c_function_name': 'DevNavHDOP',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Horizontal dilution of precision.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_HDOP',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12340: {
            'access': 'read',
            'c_function_name': 'DevNavVDOP',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Vertical dilution of precision.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_VDOP',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12488: {
            'access': 'read',
            'c_function_name': 'DevAIDigFltrLowpassCutoffFreqDiscreteVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the set of discrete lowpass cutoff frequencies supported by this device. If the device supports ranges of lowpass cutoff frequencies, use AI.DigFltr.Lowpass.CutoffFreq.RangeVals to determine supported frequencies.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_DIG_FLTR_LOWPASS_CUTOFF_FREQ_DISCRETE_VALS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        12489: {
            'access': 'read',
            'c_function_name': 'DevAIDigFltrLowpassCutoffFreqRangeVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates pairs of lowpass cutoff frequency ranges supported by this device. Each pair consists of the low value, followed by the high value. If the device supports a set of discrete lowpass cutoff frequencies, use AI.DigFltr.Lowpass.CutoffFreq.DiscreteVals to determine the supported frequencies.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_DIG_FLTR_LOWPASS_CUTOFF_FREQ_RANGE_VALS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        12551: {
            'access': 'read',
            'c_function_name': 'AIDigFltrTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the AI digital filter types supported by the device.',
            'enum': 'FilterType2',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_DIG_FLTR_TYPES',
            'python_class_name': 'Device',
            'python_data_type': 'FilterType2',
            'resettable': False,
            'type': 'int32[]'
        },
        12561: {
            'access': 'read',
            'c_function_name': 'DevAIChargeRngs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates in coulombs pairs of input charge ranges for the device. Each pair consists of the low value followed by the high value.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AI_CHARGE_RNGS',
            'python_class_name': 'Device',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        12609: {
            'access': 'read',
            'c_function_name': 'DevNumTimeTrigs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of time triggers available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NUM_TIME_TRIGS',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12610: {
            'access': 'read',
            'c_function_name': 'DevNumTimestampEngines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of timestamp engines available on the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NUM_TIMESTAMP_ENGINES',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12641: {
            'access': 'read',
            'c_function_name': 'DevCompactRIOChassisDevName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the CompactRIO chassis that contains this module.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'COMPACT_RIO_CHASSIS_DEV_NAME',
            'object_module_location': 'nidaqmx.system.device',
            'object_type': 'Device',
            'python_class_name': 'Device',
            'python_data_type': 'Device',
            'resettable': False,
            'type': 'char[]'
        },
        12642: {
            'access': 'read',
            'c_function_name': 'DevCompactRIOSlotNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the slot number of the CompactRIO chassis where this module is located.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'COMPACT_RIO_SLOT_NUM',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12643: {
            'access': 'read',
            'c_function_name': 'DevAINumSampTimingEngines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of Analog Input sample timing engines supported by the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_NUM_SAMP_TIMING_ENGINES',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12644: {
            'access': 'read',
            'c_function_name': 'DevAINumSyncPulseSrcs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of Analog Input synchronization pulse sources supported by the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_NUM_SYNC_PULSE_SRCS',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12645: {
            'access': 'read',
            'c_function_name': 'DevAONumSampTimingEngines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of Analog Output sample timing engines supported by the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_NUM_SAMP_TIMING_ENGINES',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12646: {
            'access': 'read',
            'c_function_name': 'DevAONumSyncPulseSrcs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of Analog Output synchronization pulse sources supported by the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_NUM_SYNC_PULSE_SRCS',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12647: {
            'access': 'read',
            'c_function_name': 'DevDINumSampTimingEngines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of Digital Input sample timing engines supported by the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DI_NUM_SAMP_TIMING_ENGINES',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12648: {
            'access': 'read',
            'c_function_name': 'DevDONumSampTimingEngines',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of Digital Output synchronization pulse sources supported by the device.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_NUM_SAMP_TIMING_ENGINES',
            'python_class_name': 'Device',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        12657: {
            'access': 'read',
            'c_function_name': 'FieldDAQDevName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the parent device which this bank is located in.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'FIELD_DAQ_DEV_NAME',
            'object_module_location': 'nidaqmx.system.device',
            'object_type': 'Device',
            'python_class_name': 'Device',
            'python_data_type': 'Device',
            'resettable': False,
            'type': 'char[]'
        },
        12664: {
            'access': 'read',
            'c_function_name': 'FieldDAQBankDevNames',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of the banks in the FieldDAQ.',
            'handle_parameters': {
                'deviceHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'deviceName'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'FIELD_DAQ_BANK_DEV_NAMES',
            'object_module_location': 'nidaqmx.system.device',
            'object_type': 'Device',
            'python_class_name': 'Device',
            'python_data_type': 'Device',
            'resettable': False,
            'type': 'char[]'
        }
    },
    'ExportSignal': {
        1409: {
            'access': 'read',
            'c_function_name': 'ExportedStartTrigDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_DELAY',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        1412: {
            'access': 'read-write',
            'c_function_name': 'ExportedStartTrigOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Start Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        1413: {
            'access': 'read-write',
            'c_function_name': 'ExportedStartTrigPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of the exported Start Trigger.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        1414: {
            'access': 'read',
            'c_function_name': 'ExportedStartTrigPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_PULSE_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        1424: {
            'access': 'read-write',
            'c_function_name': 'ExportedRefTrigOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Reference Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        1425: {
            'access': 'read-write',
            'c_function_name': 'ExportedRefTrigPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of the exported Reference Trigger.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        5634: {
            'access': 'read-write',
            'c_function_name': 'ExportedStartTrigPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The units of the width attribute',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_PULSE_WIDTH_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5641: {
            'access': 'read-write',
            'c_function_name': 'ExportedRdyForStartEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Ready for Start Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RDY_FOR_START_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5653: {
            'access': 'read-write',
            'c_function_name': 'ExportedPauseTrigOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Pause Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PAUSE_TRIG_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5654: {
            'access': 'read-write',
            'c_function_name': 'ExportedPauseTrigLvlActiveLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the active level of the exported Pause Trigger.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PAUSE_TRIG_LVL_ACTIVE_LVL',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        5666: {
            'access': 'read',
            'c_function_name': 'ExportedRdyForRefEventPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'blah blah',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RDY_FOR_REF_EVENT_PULSE_POLARITY',
            'python_class_name': 'N/A',
            'python_data_type': 'Polarity2',
            'resettable': False,
            'type': 'int32'
        },
        5667: {
            'access': 'read-write',
            'c_function_name': 'ExportedRdyForRefEventPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The units of the width attribute',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RDY_FOR_REF_EVENT_PULSE_WIDTH_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5668: {
            'access': 'read',
            'c_function_name': 'ExportedRdyForRefEventPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RDY_FOR_REF_EVENT_PULSE_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        5683: {
            'access': 'read-write',
            'c_function_name': 'ExportedDataActiveEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to export the Data Active Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DATA_ACTIVE_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5684: {
            'access': 'read-write',
            'c_function_name': 'ExportedDataActiveEventLvlActiveLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of the exported Data Active Event.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DATA_ACTIVE_EVENT_LVL_ACTIVE_LVL',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        5701: {
            'access': 'read-write',
            'c_function_name': 'ExportedAdvTrigOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Advance Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_TRIG_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5702: {
            'access': 'read',
            'c_function_name': 'ExportedAdvTrigPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the polarity of the exported Advance Trigger.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_TRIG_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': False,
            'type': 'int32'
        },
        5703: {
            'access': 'read-write',
            'c_function_name': 'ExportedAdvTrigPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **adv_trig_pulse_width**.',
            'enum': 'DigitalWidthUnits3',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_TRIG_PULSE_WIDTH_UNITS',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'DigitalWidthUnits3',
            'resettable': True,
            'type': 'int32'
        },
        5704: {
            'access': 'read-write',
            'c_function_name': 'ExportedAdvTrigPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the width of an exported Advance Trigger pulse. Specify this value in the units you specify with **adv_trig_pulse_width_units**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_TRIG_PULSE_WIDTH',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5706: {
            'access': 'read-write',
            'c_function_name': 'ExportedAdvCmpltEventEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_CMPLT_EVENT_ENABLE',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        5713: {
            'access': 'read-write',
            'c_function_name': 'ExportedAdvCmpltEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Advance Complete Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_CMPLT_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5714: {
            'access': 'read-write',
            'c_function_name': 'ExportedAdvCmpltEventPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of the exported Advance Complete Event.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_CMPLT_EVENT_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        5715: {
            'access': 'read-write',
            'c_function_name': 'ExportedAdvCmpltEventPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The units of the width attribute',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_CMPLT_EVENT_PULSE_WIDTH_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5716: {
            'access': 'read-write',
            'c_function_name': 'ExportedAdvCmpltEventPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the width of the exported Advance Complete Event pulse.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_CMPLT_EVENT_PULSE_WIDTH',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5718: {
            'access': 'read-write',
            'c_function_name': 'Exported20MHzTimebaseDivideDownByN',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': '20_MHZ_TIMEBASE_DIVIDE_DOWN_BY_N',
            'python_class_name': 'N/A',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        5719: {
            'access': 'read-write',
            'c_function_name': 'Exported20MHzTimebaseOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the 20MHz Timebase.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': '20_MHZ_TIMEBASE_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5720: {
            'access': 'read',
            'c_function_name': 'Exported20MHzTimebasePulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'blah blah',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': '20_MHZ_TIMEBASE_PULSE_POLARITY',
            'python_class_name': 'N/A',
            'python_data_type': 'Polarity2',
            'resettable': False,
            'type': 'int32'
        },
        5721: {
            'access': 'read-write',
            'c_function_name': 'Exported20MHzTimebasePulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The units of the width attribute',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': '20_MHZ_TIMEBASE_PULSE_WIDTH_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5728: {
            'access': 'read',
            'c_function_name': 'Exported20MHzTimebasePulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': '20_MHZ_TIMEBASE_PULSE_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        5731: {
            'access': 'read-write',
            'c_function_name': 'ExportedSampClkOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Sample Clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5732: {
            'access': 'read-write',
            'c_function_name': 'ExportedSampClkPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of the exported Sample Clock if **samp_clk_output_behavior** is **ExportActions3.PULSE**.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        5733: {
            'access': 'read-write',
            'c_function_name': 'ExportedSampClkPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The units of the width attribute',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_PULSE_WIDTH_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5734: {
            'access': 'read',
            'c_function_name': 'ExportedSampClkPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_PULSE_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        5767: {
            'access': 'read-write',
            'c_function_name': 'ExportedAIConvClkOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the AI Convert Clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_CLK_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5768: {
            'access': 'read',
            'c_function_name': 'ExportedAIConvClkPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the polarity of the exported AI Convert Clock. The polarity is fixed and independent of the active edge of the source of the AI Convert Clock.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_CLK_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': False,
            'type': 'int32'
        },
        5769: {
            'access': 'read-write',
            'c_function_name': 'ExportedAIConvClkPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **ai_conv_clk_pulse_width**.',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_CLK_PULSE_WIDTH_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5776: {
            'access': 'read',
            'c_function_name': 'ExportedAIConvClkPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the width of an exported AI Convert Clock pulse, in units specfied with **ai_conv_clk_pulse_width_units**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_CLK_PULSE_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        5906: {
            'access': 'read',
            'c_function_name': 'ExportedFreqOutClkPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'blah blah',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'FREQ_OUT_CLK_PULSE_POLARITY',
            'python_class_name': 'N/A',
            'python_data_type': 'Polarity2',
            'resettable': False,
            'type': 'int32'
        },
        5907: {
            'access': 'read-write',
            'c_function_name': 'ExportedFreqOutClkPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The units of the width attribute',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'FREQ_OUT_CLK_PULSE_WIDTH_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5908: {
            'access': 'read',
            'c_function_name': 'ExportedFreqOutClkPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'FREQ_OUT_CLK_PULSE_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        5911: {
            'access': 'read-write',
            'c_function_name': 'ExportedCtrOutEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Counter Output Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CTR_OUT_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5912: {
            'access': 'read-write',
            'c_function_name': 'ExportedCtrOutEventPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of the pulses at the output terminal of the counter when **ctr_out_event_output_behavior** is **ExportActions2.PULSE**. NI-DAQmx ignores this property if **ctr_out_event_output_behavior** is **ExportActions2.TOGGLE**.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CTR_OUT_EVENT_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        5913: {
            'access': 'read-write',
            'c_function_name': 'ExportedCtrOutEventPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The units of the width attribute',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CTR_OUT_EVENT_PULSE_WIDTH_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5920: {
            'access': 'read',
            'c_function_name': 'ExportedCtrOutEventPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CTR_OUT_EVENT_PULSE_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        5942: {
            'access': 'read',
            'c_function_name': 'ExportedRefClkPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'blah blah',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_CLK_PULSE_POLARITY',
            'python_class_name': 'N/A',
            'python_data_type': 'Polarity2',
            'resettable': False,
            'type': 'int32'
        },
        5943: {
            'access': 'read-write',
            'c_function_name': 'ExportedRefClkPulseWidthUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The units of the width attribute',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_CLK_PULSE_WIDTH_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5944: {
            'access': 'read',
            'c_function_name': 'ExportedRefClkPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'blah blah',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_CLK_PULSE_WIDTH',
            'python_class_name': 'N/A',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        5955: {
            'access': 'read-write',
            'c_function_name': 'ExportedStartTrigOutputBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The behavior of the output signal',
            'enum': 'ExportActions',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_OUTPUT_BEHAVIOR',
            'python_class_name': 'N/A',
            'python_data_type': 'ExportActions',
            'resettable': True,
            'type': 'int32'
        },
        5956: {
            'access': 'read-write',
            'c_function_name': 'ExportedStartTrigToggleInitialState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'The initial level of the output toggle',
            'enum': 'Level1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_TOGGLE_INITIAL_STATE',
            'python_class_name': 'N/A',
            'python_data_type': 'Level1',
            'resettable': True,
            'type': 'int32'
        },
        5965: {
            'access': 'read-write',
            'c_function_name': 'ExportedStartTrigDelayUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'blah blah',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_DELAY_UNITS',
            'python_class_name': 'N/A',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        5967: {
            'access': 'read-write',
            'c_function_name': 'ExportedCtrOutEventOutputBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the exported Counter Output Event pulses or changes from one state to the other when the counter reaches terminal count.',
            'enum': 'ExportActions2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CTR_OUT_EVENT_OUTPUT_BEHAVIOR',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'ExportActions2',
            'resettable': True,
            'type': 'int32'
        },
        5968: {
            'access': 'read',
            'c_function_name': 'ExportedCtrOutEventLvlPolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'blah blah',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CTR_OUT_EVENT_LVL_POLARITY',
            'python_class_name': 'N/A',
            'python_data_type': 'Polarity2',
            'resettable': False,
            'type': 'int32'
        },
        5969: {
            'access': 'read-write',
            'c_function_name': 'ExportedRdyForStartEventLvlActiveLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of the exported Ready for Start Event.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RDY_FOR_START_EVENT_LVL_ACTIVE_LVL',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        5975: {
            'access': 'read-write',
            'c_function_name': 'ExportedAdvCmpltEventDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the output signal delay in periods of the sample clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_CMPLT_EVENT_DELAY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6250: {
            'access': 'read-write',
            'c_function_name': 'ExportedCtrOutEventToggleIdleState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the initial state of the output terminal of the counter when **ctr_out_event_output_behavior** is **ExportActions2.TOGGLE**. The terminal enters this state when NI-DAQmx commits the task.',
            'enum': 'Level1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CTR_OUT_EVENT_TOGGLE_IDLE_STATE',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Level1',
            'resettable': True,
            'type': 'int32'
        },
        6251: {
            'access': 'read-write',
            'c_function_name': 'ExportedSampClkOutputBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the exported Sample Clock issues a pulse at the beginning of a sample or changes to a high state for the duration of the sample.',
            'enum': 'ExportActions3',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_OUTPUT_BEHAVIOR',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'ExportActions3',
            'resettable': True,
            'type': 'int32'
        },
        6381: {
            'access': 'read-write',
            'c_function_name': 'ExportedAIHoldCmpltEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the AI Hold Complete Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_HOLD_CMPLT_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6382: {
            'access': 'read-write',
            'c_function_name': 'ExportedAIHoldCmpltEventPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of an exported AI Hold Complete Event pulse.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_HOLD_CMPLT_EVENT_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        6393: {
            'access': 'read-write',
            'c_function_name': 'ExportedSampClkTimebaseOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Sample Clock Timebase.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_TIMEBASE_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8599: {
            'access': 'read-write',
            'c_function_name': 'ExportedChangeDetectEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Change Detection Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CHANGE_DETECT_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8609: {
            'access': 'read-write',
            'c_function_name': 'ExportedDividedSampClkTimebaseOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Divided Sample Clock Timebase.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIVIDED_SAMP_CLK_TIMEBASE_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8618: {
            'access': 'read-write',
            'c_function_name': 'ExportedWatchdogExpiredEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal  to which to route the Watchdog Timer Expired Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'WATCHDOG_EXPIRED_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8644: {
            'access': 'read-write',
            'c_function_name': 'ExportedSampClkDelayOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the amount of time to offset the exported Sample clock.  Refer to timing diagrams for generation applications in the device documentation for more information about this value.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_DELAY_OFFSET',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8764: {
            'access': 'read-write',
            'c_function_name': 'ExportedSyncPulseEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Synchronization Pulse Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8814: {
            'access': 'read-write',
            'c_function_name': 'Exported10MHzRefClkOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the 10MHz Clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': '10_MHZ_REF_CLK_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8885: {
            'access': 'read-write',
            'c_function_name': 'ExportedRdyForXferEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Ready for Transfer Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RDY_FOR_XFER_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8886: {
            'access': 'read-write',
            'c_function_name': 'ExportedRdyForXferEventLvlActiveLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the active level of the exported Ready for Transfer Event.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RDY_FOR_XFER_EVENT_LVL_ACTIVE_LVL',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        8890: {
            'access': 'read-write',
            'c_function_name': 'ExportedHshkEventOutputTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal to which to route the Handshake Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_EVENT_OUTPUT_TERM',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8891: {
            'access': 'read-write',
            'c_function_name': 'ExportedHshkEventOutputBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the output behavior of the Handshake Event.',
            'enum': 'ExportActions5',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_EVENT_OUTPUT_BEHAVIOR',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'ExportActions5',
            'resettable': True,
            'type': 'int32'
        },
        8892: {
            'access': 'read-write',
            'c_function_name': 'ExportedHshkEventDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the number of seconds to delay after the Handshake Trigger deasserts before asserting the Handshake Event.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_EVENT_DELAY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8893: {
            'access': 'read-write',
            'c_function_name': 'ExportedHshkEventInterlockedAssertedLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the asserted level of the exported Handshake Event if **hshk_event_output_behavior** is **ExportActions5.INTERLOCKED**.',
            'enum': 'Level1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_EVENT_INTERLOCKED_ASSERTED_LVL',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Level1',
            'resettable': True,
            'type': 'int32'
        },
        8894: {
            'access': 'read-write',
            'c_function_name': 'ExportedHshkEventInterlockedAssertOnStart',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies to assert the Handshake Event when the task starts if **hshk_event_output_behavior** is **ExportActions5.INTERLOCKED**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_EVENT_INTERLOCKED_ASSERT_ON_START',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8895: {
            'access': 'read-write',
            'c_function_name': 'ExportedHshkEventInterlockedDeassertDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the amount of time to wait after the Handshake Trigger asserts before deasserting the Handshake Event if **hshk_event_output_behavior** is **ExportActions5.INTERLOCKED**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_EVENT_INTERLOCKED_DEASSERT_DELAY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8896: {
            'access': 'read-write',
            'c_function_name': 'ExportedHshkEventPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of the exported Handshake Event if **hshk_event_output_behavior** is **ExportActions5.PULSE**.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_EVENT_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        8897: {
            'access': 'read-write',
            'c_function_name': 'ExportedHshkEventPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the pulse width of the exported Handshake Event if **hshk_event_output_behavior** is **ExportActions5.PULSE**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_EVENT_PULSE_WIDTH',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8963: {
            'access': 'read-write',
            'c_function_name': 'ExportedChangeDetectEventPulsePolarity',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the polarity of an exported Change Detection Event pulse.',
            'enum': 'Polarity2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CHANGE_DETECT_EVENT_PULSE_POLARITY',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'Polarity2',
            'resettable': True,
            'type': 'int32'
        },
        10595: {
            'access': 'read-write',
            'c_function_name': 'ExportedRdyForXferEventDeassertCond',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies when the ready for transfer event deasserts.',
            'enum': 'DeassertCondition',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RDY_FOR_XFER_EVENT_DEASSERT_COND',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'DeassertCondition',
            'resettable': True,
            'type': 'int32'
        },
        10596: {
            'access': 'read-write',
            'c_function_name': 'ExportedRdyForXferEventDeassertCondCustomThreshold',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies in samples the threshold below which the Ready for Transfer Event deasserts. This threshold is an amount of space available in the onboard memory of the device. **rdy_for_xfer_event_deassert_cond** must be **DeassertCondition.ONBRDMEMCUSTOMTHRESHOLD** to use a custom threshold.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RDY_FOR_XFER_EVENT_DEASSERT_COND_CUSTOM_THRESHOLD',
            'python_class_name': 'ExportSignals',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        }
    },
    'PersistedChannel': {
        8911: {
            'access': 'write',
            'c_function_name': 'PersistedChanActiveChan',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the saved global channel to which subsequent properties apply.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'ACTIVE_CHAN',
            'object_has_factory': True,
            'object_module_location': 'nidaqmx._task_modules.channels.channel',
            'object_type': 'Channel',
            'python_class_name': 'N/A',
            'python_data_type': 'Channel',
            'resettable': False,
            'type': 'char[]'
        },
        8912: {
            'access': 'read',
            'c_function_name': 'PersistedChanAuthor',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the author of the global channel.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AUTHOR',
            'python_class_name': 'SavedChannelInfo',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        8913: {
            'access': 'read',
            'c_function_name': 'PersistedChanAllowInteractiveEditing',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the global channel can be edited in the DAQ Assistant.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ALLOW_INTERACTIVE_EDITING',
            'python_class_name': 'SavedChannelInfo',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8914: {
            'access': 'read',
            'c_function_name': 'PersistedChanAllowInteractiveDeletion',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the global channel can be deleted through MAX.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ALLOW_INTERACTIVE_DELETION',
            'python_class_name': 'SavedChannelInfo',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        }
    },
    'PersistedScale': {
        8915: {
            'access': 'write',
            'c_function_name': 'PersistedScaleActiveScale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the saved custom scale to which subsequent properties apply.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'ACTIVE_SCALE',
            'object_module_location': 'nidaqmx.system.scale',
            'object_type': 'Scale',
            'python_class_name': 'N/A',
            'python_data_type': 'Scale',
            'resettable': False,
            'type': 'char[]'
        },
        8916: {
            'access': 'read',
            'c_function_name': 'PersistedScaleAuthor',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the author of the custom scale.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AUTHOR',
            'python_class_name': 'SavedScaleInfo',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        8917: {
            'access': 'read',
            'c_function_name': 'PersistedScaleAllowInteractiveEditing',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the custom scale can be edited in the DAQ Assistant.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ALLOW_INTERACTIVE_EDITING',
            'python_class_name': 'SavedScaleInfo',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8918: {
            'access': 'read',
            'c_function_name': 'PersistedScaleAllowInteractiveDeletion',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the custom scale can be deleted through MAX.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ALLOW_INTERACTIVE_DELETION',
            'python_class_name': 'SavedScaleInfo',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        }
    },
    'PersistedTask': {
        8907: {
            'access': 'write',
            'c_function_name': 'PersistedTaskActiveTask',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the saved task to which subsequent properties apply.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ACTIVE_TASK',
            'python_class_name': 'N/A',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        8908: {
            'access': 'read',
            'c_function_name': 'PersistedTaskAuthor',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the author of the task.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AUTHOR',
            'python_class_name': 'SavedTaskInfo',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        8909: {
            'access': 'read',
            'c_function_name': 'PersistedTaskAllowInteractiveEditing',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the task can be edited in the DAQ Assistant.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ALLOW_INTERACTIVE_EDITING',
            'python_class_name': 'SavedTaskInfo',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8910: {
            'access': 'read',
            'c_function_name': 'PersistedTaskAllowInteractiveDeletion',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the task can be deleted through MAX.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ALLOW_INTERACTIVE_DELETION',
            'python_class_name': 'SavedTaskInfo',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        }
    },
    'PhysicalChannel': {
        8666: {
            'access': 'read',
            'c_function_name': 'PhysicalChanTEDSMfgID',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the manufacturer ID of the sensor.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_TEDS_MFG_ID',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8667: {
            'access': 'read',
            'c_function_name': 'PhysicalChanTEDSModelNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the model number of the sensor.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_TEDS_MODEL_NUM',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8668: {
            'access': 'read',
            'c_function_name': 'PhysicalChanTEDSSerialNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the serial number of the sensor.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_TEDS_SERIAL_NUM',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8669: {
            'access': 'read',
            'c_function_name': 'PhysicalChanTEDSVersionNum',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the version number of the sensor.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_TEDS_VERSION_NUM',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8670: {
            'access': 'read',
            'c_function_name': 'PhysicalChanTEDSVersionLetter',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the version letter of the sensor.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_TEDS_VERSION_LETTER',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        8671: {
            'access': 'read',
            'c_function_name': 'PhysicalChanTEDSBitStream',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.uint8',
            'description': 'Indicates the TEDS binary bitstream without checksums.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_TEDS_BIT_STREAM',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt8[]'
        },
        8847: {
            'access': 'read',
            'c_function_name': 'PhysicalChanTEDSTemplateIDs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.uint32',
            'description': 'Indicates the IDs of the templates in the bitstream in **teds_bit_stream**.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_TEDS_TEMPLATE_I_DS',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32[]'
        },
        9026: {
            'access': 'read',
            'bitfield_enum': '_TermCfg',
            'c_function_name': 'PhysicalChanAITermCfgs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the list of terminal configurations supported by the channel.',
            'enum': 'InputTermCfg',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_TERM_CFGS',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'InputTermCfg',
            'resettable': False,
            'type': 'int32[]'
        },
        10659: {
            'access': 'read',
            'bitfield_enum': '_TermCfg',
            'c_function_name': 'PhysicalChanAOTermCfgs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the list of terminal configurations supported by the channel.',
            'enum': 'OutputTermCfg',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AO_TERM_CFGS',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'OutputTermCfg',
            'resettable': False,
            'type': 'int32[]'
        },
        10660: {
            'access': 'read',
            'c_function_name': 'PhysicalChanDIPortWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in bits the width of digital input port.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_DI_PORT_WIDTH',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        10661: {
            'access': 'read',
            'c_function_name': 'PhysicalChanDISampClkSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the sample clock timing type is supported for the digital input physical channel.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_DI_SAMP_CLK_SUPPORTED',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10662: {
            'access': 'read',
            'c_function_name': 'PhysicalChanDIChangeDetectSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the change detection timing type is supported for the digital input physical channel.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_DI_CHANGE_DETECT_SUPPORTED',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10663: {
            'access': 'read',
            'c_function_name': 'PhysicalChanDOPortWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in bits the width of digital output port.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_DO_PORT_WIDTH',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        10664: {
            'access': 'read',
            'c_function_name': 'PhysicalChanDOSampClkSupported',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the sample clock timing type is supported for the digital output physical channel.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_DO_SAMP_CLK_SUPPORTED',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10782: {
            'access': 'read-write',
            'c_function_name': 'PhysicalChanAOManualControlEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies if you can control the physical channel externally via a manual control located on the device. You cannot simultaneously control a channel manually and with NI-DAQmx.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AO_MANUAL_CONTROL_ENABLE',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        10783: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAOManualControlAmplitude',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the current value of the front panel amplitude control for the physical channel in volts.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AO_MANUAL_CONTROL_AMPLITUDE',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10784: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAOManualControlFreq',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the current value of the front panel frequency control for the physical channel in hertz.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AO_MANUAL_CONTROL_FREQ',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        11971: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAOManualControlShortDetected',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the physical channel is currently disabled due to a short detected on the channel.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AO_MANUAL_CONTROL_SHORT_DETECTED',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12247: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAISupportedMeasTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the measurement types supported by the channel.',
            'enum': 'AIMeasurementType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_SUPPORTED_MEAS_TYPES',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'AIMeasurementType',
            'resettable': False,
            'type': 'int32[]'
        },
        12248: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAIInputSrcs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the list of input sources supported by the channel. Channels may support using the signal from the I/O connector or one of several calibration signals.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_INPUT_SRCS',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12249: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAOSupportedOutputTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the output types supported by the channel.',
            'enum': 'AOOutputChannelType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AO_SUPPORTED_OUTPUT_TYPES',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'AOOutputChannelType',
            'resettable': False,
            'type': 'int32[]'
        },
        12250: {
            'access': 'read',
            'c_function_name': 'PhysicalChanCISupportedMeasTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the measurement types supported by the channel.',
            'enum': 'CIMeasurementType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_CI_SUPPORTED_MEAS_TYPES',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'CIMeasurementType',
            'resettable': False,
            'type': 'int32[]'
        },
        12251: {
            'access': 'read',
            'c_function_name': 'PhysicalChanCOSupportedOutputTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the output types supported by the channel.',
            'enum': 'COOutputType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_CO_SUPPORTED_OUTPUT_TYPES',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'COOutputType',
            'resettable': False,
            'type': 'int32[]'
        },
        12256: {
            'access': 'read',
            'c_function_name': 'PhysicalChanDISampModes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the sample modes supported by devices that support sample clocked digital input.',
            'enum': 'AcquisitionType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_DI_SAMP_MODES',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'AcquisitionType',
            'resettable': False,
            'type': 'int32[]'
        },
        12257: {
            'access': 'read',
            'c_function_name': 'PhysicalChanDOSampModes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the sample modes supported by devices that support sample clocked digital output.',
            'enum': 'AcquisitionType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_DO_SAMP_MODES',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'AcquisitionType',
            'resettable': False,
            'type': 'int32[]'
        },
        12343: {
            'access': 'read',
            'c_function_name': 'PhysicalChanNavSupportedMeasTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the measurement types supported by the channel.',
            'enum': 'NavMeasurementType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_NAV_SUPPORTED_MEAS_TYPES',
            'python_class_name': 'N/A',
            'python_data_type': 'NavMeasurementType',
            'resettable': False,
            'type': 'int32[]'
        },
        12366: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAOSupportedPowerUpOutputTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the power up output types supported by the channel.',
            'enum': 'AOPowerUpOutputBehavior',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AO_SUPPORTED_POWER_UP_OUTPUT_TYPES',
            'python_class_name': 'AOChannel',
            'python_data_type': 'AOPowerUpOutputBehavior',
            'resettable': False,
            'type': 'int32[]'
        },
        12386: {
            'access': 'read-write',
            'c_function_name': 'AOPowerAmpChannelEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable or disable a channel for amplification. This property can also be used to check if a channel is enabled.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_POWER_AMP_CHANNEL_ENABLE',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12387: {
            'access': 'read',
            'c_function_name': 'AOPowerAmpScalingCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates the coefficients of a polynomial equation used to scale from pre-amplified values.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AO_POWER_AMP_SCALING_COEFF',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        12388: {
            'access': 'read',
            'c_function_name': 'AOPowerAmpOvercurrent',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the channel detected an overcurrent condition.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_POWER_AMP_OVERCURRENT',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12389: {
            'access': 'read',
            'c_function_name': 'AOPowerAmpGain',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the calibrated gain of the channel.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_POWER_AMP_GAIN',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12390: {
            'access': 'read',
            'c_function_name': 'AOPowerAmpOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the calibrated offset of the channel in volts.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_POWER_AMP_OFFSET',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12652: {
            'access': 'read-write',
            'c_function_name': 'PhysicalChanAIPowerControlVoltage',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': "Specifies the voltage level for the sensor's power supply.",
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_POWER_CONTROL_VOLTAGE',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12653: {
            'access': 'read-write',
            'c_function_name': 'PhysicalChanAIPowerControlEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': "Specifies whether to turn on the sensor's power supply.",
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_POWER_CONTROL_ENABLE',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12654: {
            'access': 'read-write',
            'c_function_name': 'PhysicalChanAIPowerControlType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of power supplied to the sensor.',
            'enum': 'SensorPowerType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_POWER_CONTROL_TYPE',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'SensorPowerType',
            'resettable': True,
            'type': 'int32'
        },
        12665: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAISensorPowerTypes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Indicates the types of power supplied to the sensor supported by this channel.',
            'enum': 'SensorPowerType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_SENSOR_POWER_TYPES',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'SensorPowerType',
            'resettable': False,
            'type': 'int32[]'
        },
        12666: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAISensorPowerVoltageRangeVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Indicates pairs of sensor power voltage ranges supported by this channel. Each pair consists of the low value followed by the high value.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_SENSOR_POWER_VOLTAGE_RANGE_VALS',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        12668: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAISensorPowerOpenChan',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether there is an open channel or undercurrent condition on the channel.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_SENSOR_POWER_OPEN_CHAN',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12669: {
            'access': 'read',
            'c_function_name': 'PhysicalChanAISensorPowerOvercurrent',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether there is an overcurrent condition on the channel.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PHYSICAL_CHAN_AI_SENSOR_POWER_OVERCURRENT',
            'python_class_name': 'PhysicalChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        }
    },
    'Read': {
        4625: {
            'access': 'read-write',
            'c_function_name': 'ReadOverWrite',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether to overwrite samples in the buffer that you have not yet read.',
            'enum': 'OverwriteMode1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OVERWRITE',
            'python_class_name': 'DaqStream',
            'python_data_type': 'OverwriteMode1',
            'resettable': True,
            'type': 'int32'
        },
        4629: {
            'access': 'read-write',
            'c_function_name': 'ReadReadAllAvailSamp',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether subsequent read operations read all samples currently available in the buffer or wait for the buffer to become full before reading. NI-DAQmx uses this setting for finite acquisitions and only when the number of samples to read is -1. For continuous acquisitions when the number of samples to read is -1, a read operation always reads all samples currently available in the buffer.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'READ_ALL_AVAIL_SAMP',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        4641: {
            'access': 'read',
            'c_function_name': 'ReadCurrReadPos',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_ulonglong',
            'description': 'Indicates in samples per channel the current position in the buffer.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CURR_READ_POS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'long',
            'resettable': False,
            'type': 'uInt64'
        },
        4643: {
            'access': 'read',
            'c_function_name': 'ReadAvailSampPerChan',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of samples available to read per channel. This value is the same for all channels in the task.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AVAIL_SAMP_PER_CHAN',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        6179: {
            'access': 'read-write',
            'c_function_name': 'ReadChannelsToRead',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies a subset of channels in the task from which to read.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'CHANNELS_TO_READ',
            'object_constructor_params': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'object_has_factory': True,
            'object_module_location': 'nidaqmx._task_modules.channels.channel',
            'object_type': 'Channel',
            'python_class_name': 'DaqStream',
            'python_data_type': 'Channel',
            'resettable': True,
            'type': 'char[]'
        },
        6182: {
            'access': 'read-write',
            'c_function_name': 'ReadAutoStart',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies if DAQmx Read automatically starts the task  if you did not start the task explicitly by using DAQmx Start. The default value is True. When  DAQmx Read starts a finite acquisition task, it also stops the task after reading the last sample.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AUTO_START',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        6410: {
            'access': 'read-write',
            'c_function_name': 'ReadRelativeTo',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the point in the buffer at which to begin a read operation. If you also specify an offset with **offset**, the read operation begins at that offset relative to the point you select with this property. The default value is **ReadRelativeTo.CURRREADPOS** unless you configure a Reference Trigger for the task. If you configure a Reference Trigger, the default value is **ReadRelativeTo.FIRSTPRETRIGSAMP**.',
            'enum': 'ReadRelativeTo',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RELATIVE_TO',
            'python_class_name': 'DaqStream',
            'python_data_type': 'ReadRelativeTo',
            'resettable': True,
            'type': 'int32'
        },
        6411: {
            'access': 'read-write',
            'c_function_name': 'ReadOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies an offset in samples per channel at which to begin a read operation. This offset is relative to the location you specify with **relative_to**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OFFSET',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'int32'
        },
        6442: {
            'access': 'read',
            'c_function_name': 'ReadTotalSampPerChanAcquired',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_ulonglong',
            'description': 'Indicates the total number of samples acquired by each channel. NI-DAQmx returns a single value because this value is the same for all channels. For retriggered acquisitions, this value is the cumulative number of samples across all retriggered acquisitions.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TOTAL_SAMP_PER_CHAN_ACQUIRED',
            'python_class_name': 'DaqStream',
            'python_data_type': 'long',
            'resettable': False,
            'type': 'uInt64'
        },
        8564: {
            'access': 'read',
            'c_function_name': 'ReadOverloadedChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an overload in any virtual channel in the task. Reading this property clears the overload status for all channels in the task. You must read this property before you read **overloaded_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OVERLOADED_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8565: {
            'access': 'read',
            'c_function_name': 'ReadOverloadedChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any overloaded virtual channels in the task. You must read **overloaded_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OVERLOADED_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        8570: {
            'access': 'read',
            'c_function_name': 'ReadRawDataWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in bytes the size of a raw sample from the task.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RAW_DATA_WIDTH',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8571: {
            'access': 'read',
            'c_function_name': 'ReadNumChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of channels that DAQmx Read reads from the task. This value is the number of channels in the task or the number of channels you specify with **channels_to_read**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NUM_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8572: {
            'access': 'read',
            'c_function_name': 'ReadDigitalLinesBytesPerChan',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of booleans per channel that NI-DAQmx returns in a sample for line-based reads. If a channel has fewer lines than this number, the extra booleans are False.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIGITAL_LINES_BYTES_PER_CHAN',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8596: {
            'access': 'read',
            'c_function_name': 'ReadChangeDetectHasOverflowed',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if samples were missed because change detection events occurred faster than the device could handle them. Some devices detect overflows differently than others.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CHANGE_DETECT_HAS_OVERFLOWED',
            'python_class_name': 'Timing',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8754: {
            'access': 'read-write',
            'c_function_name': 'ReadWaitMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies how DAQmx Read waits for samples to become available.',
            'enum': 'WaitMode',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'WAIT_MODE',
            'python_class_name': 'DaqStream',
            'python_data_type': 'WaitMode',
            'resettable': True,
            'type': 'int32'
        },
        8880: {
            'access': 'read-write',
            'c_function_name': 'ReadSleepTime',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the amount of time to sleep after checking for available samples if **wait_mode** is **WaitMode.SLEEP**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SLEEP_TIME',
            'python_class_name': 'DaqStream',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10726: {
            'access': 'read',
            'c_function_name': 'ReadOvercurrentChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an overcurrent condition for any virtual channel in the task. Reading this property clears the overcurrent status for all channels in the task. You must read this property before you read **overcurrent_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OVERCURRENT_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10727: {
            'access': 'read',
            'c_function_name': 'ReadOvercurrentChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which the device(s) detected an overcurrent condition. You must read **overcurrent_chans_exist** before you read this property. Otherwise, you will receive an error. On some devices, you must restart the task for all overcurrent channels to recover.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OVERCURRENT_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        10761: {
            'access': 'read',
            'c_function_name': 'ReadOpenCurrentLoopChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an open current loop for any virtual channel in the task. Reading this property clears the open current loop status for all channels in the task. You must read this property before you read **open_current_loop_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OPEN_CURRENT_LOOP_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10762: {
            'access': 'read',
            'c_function_name': 'ReadOpenCurrentLoopChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which the device(s) detected an open current loop. You must read **open_current_loop_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OPEN_CURRENT_LOOP_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        10902: {
            'access': 'read',
            'c_function_name': 'ReadOpenThrmcplChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an open thermocouple connected to any virtual channel in the task. Reading this property clears the open thermocouple status for all channels in the task. You must read this property before you read **open_thrmcpl_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OPEN_THRMCPL_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10903: {
            'access': 'read',
            'c_function_name': 'ReadOpenThrmcplChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which the device(s) detected an open thermcouple. You must read **open_thrmcpl_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OPEN_THRMCPL_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        10904: {
            'access': 'read',
            'c_function_name': 'ReadCommonModeRangeErrorChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected a common mode range violation for any virtual channel in the task. Common mode range violation occurs when the voltage of either the positive terminal or negative terminal to ground are out of range. Reading this property clears the common mode range violation status for all channels in the task. You must read this property before you read **common_mode_range_error_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'COMMON_MODE_RANGE_ERROR_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10905: {
            'access': 'read',
            'c_function_name': 'ReadCommonModeRangeErrorChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which the device(s) detected a common mode range violation. You must read **common_mode_range_error_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'COMMON_MODE_RANGE_ERROR_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        11972: {
            'access': 'read-write',
            'c_function_name': 'LoggingFilePath',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the path to the TDMS file to which you want to log data.  If the file path is changed while the task is running, this takes effect on the next sample interval (if Logging.SampsPerFile has been set) or when DAQmx Start New File is called. New file paths can be specified by ending with "\\\\" or "/". Files created after specifying a new file path retain the same name and numbering sequence.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LOGGING_FILE_PATH',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        11973: {
            'access': 'read-write',
            'c_function_name': 'LoggingMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether to enable logging and whether to allow reading data while logging. Log mode allows for the best performance. However, you cannot read data while logging if you specify this mode. If you want to read data while logging, specify Log and Read mode.',
            'enum': 'LoggingMode',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LOGGING_MODE',
            'python_class_name': 'DaqStream',
            'python_data_type': 'LoggingMode',
            'resettable': True,
            'type': 'int32'
        },
        11974: {
            'access': 'read-write',
            'c_function_name': 'LoggingTDMSGroupName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of the group to create within the TDMS file for data from this task. If you append data to an existing file and the specified group already exists, NI-DAQmx appends a number symbol and a number to the group name, incrementing that number until finding a group name that does not exist. For example, if you specify a group name of Voltage Task, and that group already exists, NI-DAQmx assigns the group name Voltage Task #1, then Voltage Task #2.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LOGGING_TDMS_GROUP_NAME',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        11975: {
            'access': 'read-write',
            'c_function_name': 'LoggingTDMSOperation',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies how to open the TDMS file.',
            'enum': 'LoggingOperation',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LOGGING_TDMS_OPERATION',
            'python_class_name': 'DaqStream',
            'python_data_type': 'LoggingOperation',
            'resettable': True,
            'type': 'int32'
        },
        12144: {
            'access': 'read',
            'c_function_name': 'ReadAccessoryInsertionOrRemovalDetected',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if any device(s) in the task detected the insertion or removal of an accessory since the task started. Reading this property clears the accessory change status for all channels in the task. You must read this property before you read **devs_with_inserted_or_removed_accessories**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ACCESSORY_INSERTION_OR_REMOVAL_DETECTED',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12145: {
            'access': 'read',
            'c_function_name': 'ReadDevsWithInsertedOrRemovedAccessories',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the names of any devices that detected the insertion or removal of an accessory since the task started. You must read **accessory_insertion_or_removal_detected** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'DEVS_WITH_INSERTED_OR_REMOVED_ACCESSORIES',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12227: {
            'access': 'read-write',
            'c_function_name': 'LoggingFileWriteSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the size, in samples, in which data will be written to disk.  The size must be evenly divisible by the volume sector size, in bytes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LOGGING_FILE_WRITE_SIZE',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12230: {
            'access': 'read-write',
            'c_function_name': 'LoggingFilePreallocationSize',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_ulonglong',
            'description': 'Specifies a size in samples to be used to pre-allocate space on disk.  Pre-allocation can improve file I/O performance, especially in situations where multiple files are being written to disk.  For finite tasks, the default behavior is to pre-allocate the file based on the number of samples you configure the task to acquire.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LOGGING_FILE_PREALLOCATION_SIZE',
            'python_class_name': 'DaqStream',
            'python_data_type': 'long',
            'resettable': True,
            'type': 'uInt64'
        },
        12259: {
            'access': 'read-write',
            'c_function_name': 'LoggingPause',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether logging is paused while a task is executing. If **logging_mode** is set to Log and Read mode, this value is taken into consideration on the next call to DAQmx Read, where data is written to disk. If **logging_mode** is set to Log Only mode, this value is taken into consideration the next time that data is written to disk. A new TDMS group is written when logging is resumed from a paused state.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LOGGING_PAUSE',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12260: {
            'access': 'read-write',
            'c_function_name': 'LoggingSampsPerFile',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_ulonglong',
            'description': 'Specifies how many samples to write to each file. When the file reaches the number of samples specified, a new file is created with the naming convention of <filename>_####.tdms, where #### starts at 0001 and increments automatically with each new file. For example, if the file specified is C:\\\\data.tdms, the next file name used is C:\\\\data_0001.tdms. To disable file spanning behavior, set this attribute to 0. If **logging_file_path** is changed while this attribute is set, the new file path takes effect on the next file created.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LOGGING_SAMPS_PER_FILE',
            'python_class_name': 'DaqStream',
            'python_data_type': 'long',
            'resettable': True,
            'type': 'uInt64'
        },
        12341: {
            'access': 'read',
            'c_function_name': 'ReadNavFixLost',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether or not the fix was lost since the last read time the fix lost property was read.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAV_FIX_LOST',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12417: {
            'access': 'read',
            'c_function_name': 'ReadOvertemperatureChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an overtemperature condition in any virtual channel in the task. Reading this property clears the overtemperature status for all channels in the task. You must read this property before you read **overtemperature_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OVERTEMPERATURE_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12418: {
            'access': 'read',
            'c_function_name': 'ReadOvertemperatureChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any overtemperature virtual channels. You must read **overtemperature_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OVERTEMPERATURE_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12424: {
            'access': 'read',
            'c_function_name': 'ReadExcitFaultChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an excitation fault condition for any virtual channel in the task. Reading this property clears the excitation fault status for all channels in the task. You must read this property before you read **excit_fault_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'EXCIT_FAULT_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12425: {
            'access': 'read',
            'c_function_name': 'ReadExcitFaultChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which the device(s) detected an excitation fault condition. You must read **excit_fault_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'EXCIT_FAULT_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12544: {
            'access': 'read',
            'c_function_name': 'ReadOpenChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device or devices detected an open channel condition in any virtual channel in the task. Reading this property clears the open channel status for all channels in this task. You must read this property before you read **open_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OPEN_CHANS_EXIST',
            'python_class_name': 'AIChannel',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12545: {
            'access': 'read',
            'c_function_name': 'ReadOpenChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any open virtual channels. You must read **open_chans_exist** before you read this property. Otherwise you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OPEN_CHANS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12546: {
            'access': 'read',
            'c_function_name': 'ReadOpenChansDetails',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of details of any open virtual channels. You must read **open_chans_exist** before you read this property. Otherwise you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OPEN_CHANS_DETAILS',
            'python_class_name': 'AIChannel',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12568: {
            'access': 'read',
            'c_function_name': 'ReadPLLUnlockedChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the PLL is currently locked, or whether it became unlocked during the previous acquisition. Devices may report PLL Unlock either during acquisition or after acquisition.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PLL_UNLOCKED_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12569: {
            'access': 'read',
            'c_function_name': 'ReadPLLUnlockedChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the channels that had their PLLs unlock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'PLL_UNLOCKED_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12605: {
            'access': 'read',
            'c_function_name': 'ReadSyncUnlockedChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the target is currently locked to the grand master. Devices may report PLL Unlock either during acquisition or after acquisition.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_UNLOCKED_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12606: {
            'access': 'read',
            'c_function_name': 'ReadSyncUnlockedChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the channels from devices in an unlocked target.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'SYNC_UNLOCKED_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12687: {
            'access': 'read',
            'c_function_name': 'ReadInputLimitsFaultChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device or devices detected a sample that was outside the upper or lower limits configured for each channel in the task. Reading this property clears the input limits fault channel status for all channels in the task. You must read this property before you read **input_limits_fault_chans**. Otherwise, you will receive an error. Note: Fault detection applies to both positive and negative inputs. For instance, if you specify a lower limit of 2 mA and an upper limit of 12 mA, NI-DAQmx detects a fault at 15 mA and -15 mA, but not at -6 mA because it is in the range of -12 mA to -2 mA.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'INPUT_LIMITS_FAULT_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12688: {
            'access': 'read',
            'c_function_name': 'ReadInputLimitsFaultChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the virtual channels that have detected samples outside the upper or lower limits configured for each channel in the task. You must read **input_limits_fault_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'INPUT_LIMITS_FAULT_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12690: {
            'access': 'read',
            'c_function_name': 'ReadPowerSupplyFaultChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device or devices detected a power supply fault condition in any virtual channel in the task. Reading this property clears the power supply fault status for all channels in this task. You must read this property before you read **power_supply_fault_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'POWER_SUPPLY_FAULT_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12691: {
            'access': 'read',
            'c_function_name': 'ReadPowerSupplyFaultChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the virtual channels that have detected a power supply fault. You must read **power_supply_fault_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'POWER_SUPPLY_FAULT_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12765: {
            'access': 'read',
            'c_function_name': 'RemoteSenseErrorChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an error condition of the remote sense connection for any channel in the task. You must disable the output and resolve the hardware connection issue to clear the error condition. You must read this property before you read the Remote Sense Error Channels property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REMOTE_SENSE_ERROR_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12766: {
            'access': 'read',
            'c_function_name': 'RemoteSenseErrorChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which a remote sense connection error condition has been detected. You must read Remote Sense Error Channels Exist before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'REMOTE_SENSE_ERROR_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12767: {
            'access': 'read',
            'c_function_name': 'AuxPowerErrorChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an auxiliary power supply error condition for any channel in the task. Reading this property clears the error condition status for all channels in the task. You must read this property before you read the Aux Power Error Channels property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AUX_POWER_ERROR_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12768: {
            'access': 'read',
            'c_function_name': 'AuxPowerErrorChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which an auxiliary power supply error condition has been detected. You must read the Aux Power Error Channels Exist property before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'AUX_POWER_ERROR_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12774: {
            'access': 'read',
            'c_function_name': 'ReverseVoltageErrorChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected reverse voltage error for any of the channels in the task. Reverse voltage error occurs if the local voltage is equal to the negative saturated voltage. Reading this property clears the error condition status for all channels in the task. You must read this property before you read the Reverse Voltage Error Channels property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REVERSE_VOLTAGE_ERROR_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12775: {
            'access': 'read',
            'c_function_name': 'ReverseVoltageErrorChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of all virtual channels in the task for which reverse voltage error condition has been detected. You must read the Reverse Voltage Error Channels Exist property before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'REVERSE_VOLTAGE_ERROR_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        }
    },
    'RealTime': {
        8941: {
            'access': 'read-write',
            'c_function_name': 'RealTimeNumOfWarmupIters',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of loop iterations that must occur before DAQmx Waitfor Next SC and DAQmx Read return any late warnings or errors. The system needs a number of iterations to stabilize. During this period, a large amount of jitter occurs, potentially causing reads and writes to be late. The default number of warmup iterations is 100. Specify a larger number if needed to stabilize the system.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NUM_OF_WARMUP_ITERS',
            'python_class_name': 'SinglePoint',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        8942: {
            'access': 'read-write',
            'c_function_name': 'RealTimeConvLateErrorsToWarnings',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies if DAQmx Waitfor Next SC, DAQmx Read, and DAQmx Write convert late errors to warnings. NI-DAQmx returns no late warnings or errors until the number of warmup iterations you specify with **num_of_warmup_iters** execute.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CONV_LATE_ERRORS_TO_WARNINGS',
            'python_class_name': 'SinglePoint',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8943: {
            'access': 'read-write',
            'c_function_name': 'RealTimeWaitForNextSampClkWaitMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies how DAQmx Waitfor Next SC waits for the next Sample Clock pulse.',
            'enum': 'WaitMode3',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'WAIT_FOR_NEXT_SAMP_CLK_WAIT_MODE',
            'python_class_name': 'SinglePoint',
            'python_data_type': 'WaitMode3',
            'resettable': True,
            'type': 'int32'
        },
        8985: {
            'access': 'read-write',
            'c_function_name': 'RealTimeReportMissedSamp',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether DAQmx Read returns lateness errors or warnings when it detects missed Sample Clock pulses. This setting does not affect DAQmx Waitfor Next SC. Set this property to True for applications that need to detect lateness without using DAQmx Waitfor Next SC.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REPORT_MISSED_SAMP',
            'python_class_name': 'SinglePoint',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8986: {
            'access': 'read-write',
            'c_function_name': 'RealTimeWriteRecoveryMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies how NI-DAQmx attempts to recover after missing a Sample Clock pulse when performing counter writes.',
            'enum': 'WaitMode4',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'WRITE_RECOVERY_MODE',
            'python_class_name': 'SinglePoint',
            'python_data_type': 'WaitMode4',
            'resettable': True,
            'type': 'int32'
        }
    },
    'Scale': {
        4646: {
            'access': 'read-write',
            'c_function_name': 'ScaleDescr',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies a description for the scale.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DESCR',
            'python_class_name': 'Scale',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        4647: {
            'access': 'read-write',
            'c_function_name': 'ScaleLinSlope',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the slope, m, in the equation y=mx+b.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LIN_SLOPE',
            'python_class_name': 'LinearScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        4648: {
            'access': 'read-write',
            'c_function_name': 'ScaleLinYIntercept',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the y-intercept, b, in the equation y=mx+b.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'LIN_Y_INTERCEPT',
            'python_class_name': 'LinearScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        4649: {
            'access': 'read-write',
            'c_function_name': 'ScaleMapScaledMax',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the largest value in the range of scaled values. NI-DAQmx maps this value to **map_pre_scaled_max**. Reads coerce samples that are larger than this value to match this value. Writes generate errors for samples that are larger than this value.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'MAP_SCALED_MAX',
            'python_class_name': 'RangeMapScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        4656: {
            'access': 'read-write',
            'c_function_name': 'ScaleMapScaledMin',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the smallest value in the range of scaled values. NI-DAQmx maps this value to **map_pre_scaled_min**. Reads coerce samples that are smaller than this value to match this value. Writes generate errors for samples that are smaller than this value.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'MAP_SCALED_MIN',
            'python_class_name': 'RangeMapScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        4657: {
            'access': 'read-write',
            'c_function_name': 'ScaleMapPreScaledMax',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the largest value in the range of pre-scaled values. NI-DAQmx maps this value to **map_scaled_max**.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'MAP_PRE_SCALED_MAX',
            'python_class_name': 'RangeMapScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        4658: {
            'access': 'read-write',
            'c_function_name': 'ScaleMapPreScaledMin',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the smallest value in the range of pre-scaled values. NI-DAQmx maps this value to **map_scaled_min**.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'MAP_PRE_SCALED_MIN',
            'python_class_name': 'RangeMapScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        4660: {
            'access': 'read-write',
            'c_function_name': 'ScalePolyForwardCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies a list of coefficients for the polynomial that converts pre-scaled values to scaled values. Each element of the list corresponds to a term of the equation. For example, if index three of the list is 9, the fourth term of the equation is 9x^3.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'POLY_FORWARD_COEFF',
            'python_class_name': 'PolynomialScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        4661: {
            'access': 'read-write',
            'c_function_name': 'ScalePolyReverseCoeff',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies a list of coefficients for the polynomial that converts scaled values to pre-scaled values. Each element of the list corresponds to a term of the equation. For example, if index three of the list is 9, the fourth term of the equation is 9y^3.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'POLY_REVERSE_COEFF',
            'python_class_name': 'PolynomialScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        4662: {
            'access': 'read-write',
            'c_function_name': 'ScaleTableScaledVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies a list of scaled values. These values map directly to the values in **table_pre_scaled_vals**.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'TABLE_SCALED_VALS',
            'python_class_name': 'TableScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        4663: {
            'access': 'read-write',
            'c_function_name': 'ScaleTablePreScaledVals',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies a list of pre-scaled values. These values map directly to the values in **table_scaled_vals**.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'TABLE_PRE_SCALED_VALS',
            'python_class_name': 'TableScale',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64[]'
        },
        6391: {
            'access': 'read-write',
            'c_function_name': 'ScalePreScaledUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of the values that you want to scale.',
            'enum': 'UnitsPreScaled',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PRE_SCALED_UNITS',
            'python_class_name': 'Scale',
            'python_data_type': 'UnitsPreScaled',
            'resettable': False,
            'type': 'int32'
        },
        6427: {
            'access': 'read-write',
            'c_function_name': 'ScaleScaledUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the units to use for scaled values. You can use an arbitrary string.',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SCALED_UNITS',
            'python_class_name': 'Scale',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        6441: {
            'access': 'read',
            'c_function_name': 'ScaleType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Indicates the method or equation form that the custom scale uses.',
            'enum': 'ScaleType',
            'handle_parameters': {
                'genericNameHandle': {
                    'accessor': 'self._name',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'name'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TYPE',
            'python_class_name': 'N/A',
            'python_data_type': 'ScaleType',
            'resettable': False,
            'type': 'int32'
        }
    },
    'System': {
        4709: {
            'access': 'read',
            'c_function_name': 'SysGlobalChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list that contains the names of all global channels saved on the system.',
            'handle_parameters': {
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'GLOBAL_CHANS',
            'object_has_factory': True,
            'object_module_location': 'nidaqmx._task_modules.channels.channel',
            'object_type': 'Channel',
            'python_class_name': 'DaqSystem',
            'python_data_type': 'Channel',
            'resettable': False,
            'type': 'char[]'
        },
        4710: {
            'access': 'read',
            'c_function_name': 'SysScales',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list that contains the names of all custom scales saved on the system.',
            'handle_parameters': {
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'SCALES',
            'object_module_location': 'nidaqmx.system.scale',
            'object_type': 'Scale',
            'python_class_name': 'DaqSystem',
            'python_data_type': 'Scale',
            'resettable': False,
            'type': 'char[]'
        },
        4711: {
            'access': 'read',
            'c_function_name': 'SysTasks',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list that contains the names of all tasks saved on the system.',
            'handle_parameters': {
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'TASKS',
            'python_class_name': 'DaqSystem',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        4722: {
            'access': 'read',
            'c_function_name': 'SysNIDAQMajorVersion',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the major portion of the installed version of NI-DAQmx, such as 7 for version 7.0.',
            'handle_parameters': {
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NIDAQ_MAJOR_VERSION',
            'python_class_name': 'DaqSystem',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        6435: {
            'access': 'read',
            'c_function_name': 'SysNIDAQMinorVersion',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the minor portion of the installed version of NI-DAQmx, such as 0 for version 7.0.',
            'handle_parameters': {
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NIDAQ_MINOR_VERSION',
            'python_class_name': 'DaqSystem',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        6459: {
            'access': 'read',
            'c_function_name': 'SysDevNames',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the names of all devices installed in the system.',
            'handle_parameters': {
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'DEV_NAMES',
            'object_module_location': 'nidaqmx.system.device',
            'object_type': 'Device',
            'python_class_name': 'DaqSystem',
            'python_data_type': 'Device',
            'resettable': False,
            'type': 'char[]'
        },
        12066: {
            'access': 'read',
            'c_function_name': 'SysNIDAQUpdateVersion',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the update portion of the installed version of NI-DAQmx, such as 1 for version 9.0.1.',
            'handle_parameters': {
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NIDAQ_UPDATE_VERSION',
            'python_class_name': 'DaqSystem',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        }
    },
    'Task': {
        4723: {
            'access': 'read',
            'c_function_name': 'TaskChannels',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the names of all virtual channels in the task.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'CHANNELS',
            'object_has_factory': True,
            'object_module_location': 'nidaqmx._task_modules.channels.channel',
            'object_type': 'Channel',
            'python_class_name': 'N/A',
            'python_data_type': 'Channel',
            'resettable': False,
            'type': 'char[]'
        },
        4724: {
            'access': 'read',
            'c_function_name': 'TaskComplete',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the task completed execution.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'COMPLETE',
            'python_class_name': 'Task',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        4726: {
            'access': 'read',
            'c_function_name': 'TaskName',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the task.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NAME',
            'python_class_name': 'N/A',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        8577: {
            'access': 'read',
            'c_function_name': 'TaskNumChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of virtual channels in the task.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NUM_CHANS',
            'python_class_name': 'N/A',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8974: {
            'access': 'read',
            'c_function_name': 'TaskDevices',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list containing the names of all devices in the task.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': True,
            'name': 'DEVICES',
            'object_module_location': 'nidaqmx.system.device',
            'object_type': 'Device',
            'python_class_name': 'Task',
            'python_data_type': 'Device',
            'resettable': False,
            'type': 'char[]'
        },
        10682: {
            'access': 'read',
            'c_function_name': 'TaskNumDevices',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of devices in the task.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NUM_DEVICES',
            'python_class_name': 'N/A',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        }
    },
    'Timing': {
        4864: {
            'access': 'read-write',
            'c_function_name': 'SampQuantSampMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies if a task acquires or generates a finite number of samples or if it continuously acquires or generates samples.',
            'enum': 'AcquisitionType',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_QUANT_SAMP_MODE',
            'python_class_name': 'Timing',
            'python_data_type': 'AcquisitionType',
            'resettable': True,
            'type': 'int32'
        },
        4865: {
            'access': 'read-write',
            'c_function_name': 'SampClkActiveEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of a clock pulse sampling takes place. This property is useful primarily when the signal you use as the Sample Clock is not a periodic clock.',
            'enum': 'Edge1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_ACTIVE_EDGE',
            'python_class_name': 'Timing',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        4867: {
            'access': 'read-write',
            'c_function_name': 'SampClkTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the rate of the Sample Clock Timebase. Some applications require that you specify a rate when you use any signal other than the onboard Sample Clock Timebase. NI-DAQmx requires this rate to calculate other timing parameters.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_TIMEBASE_RATE',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4868: {
            'access': 'read-write',
            'c_function_name': 'DelayFromSampClkDelayUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **delay_from_samp_clk_delay**.',
            'enum': 'DigitalWidthUnits2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DELAY_FROM_SAMP_CLK_DELAY_UNITS',
            'python_class_name': 'Timing',
            'python_data_type': 'DigitalWidthUnits2',
            'resettable': True,
            'type': 'int32'
        },
        4869: {
            'access': 'read-write',
            'c_function_name': 'SampClkTimebaseMasterTimebaseDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of pulses of the Master Timebase needed to produce a single pulse of the Sample Clock Timebase.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_TIMEBASE_MASTER_TIMEBASE_DIV',
            'python_class_name': 'Timing',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        4872: {
            'access': 'read-write',
            'c_function_name': 'SampClkTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the Sample Clock Timebase.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_TIMEBASE_SRC',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        4880: {
            'access': 'read-write',
            'c_function_name': 'SampQuantSampPerChan',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_ulonglong',
            'description': 'Specifies the number of samples to acquire or generate for each channel if **samp_quant_samp_mode** is **AcquisitionType.FINITESAMPS**. If **samp_quant_samp_mode** is **AcquisitionType.CONTSAMPS**, NI-DAQmx uses this value to determine the buffer size.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_QUANT_SAMP_PER_CHAN',
            'python_class_name': 'Timing',
            'python_data_type': 'long',
            'resettable': True,
            'type': 'uInt64'
        },
        4885: {
            'access': 'read-write',
            'c_function_name': 'RefClkRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the frequency of the Reference Clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_CLK_RATE',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4886: {
            'access': 'read-write',
            'c_function_name': 'RefClkSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the Reference Clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_CLK_SRC',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        4887: {
            'access': 'read-write',
            'c_function_name': 'DelayFromSampClkDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the amount of time to wait after receiving a Sample Clock edge before beginning to acquire the sample. This value is in the units you specify with **delay_from_samp_clk_delay_units**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DELAY_FROM_SAMP_CLK_DELAY',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4917: {
            'access': 'read-write',
            'c_function_name': 'AIConvTimebaseDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of AI Convert Clock Timebase pulses needed to produce a single AI Convert Clock pulse.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_TIMEBASE_DIV',
            'python_class_name': 'Timing',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        4921: {
            'access': 'read-write',
            'c_function_name': 'AIConvTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the terminal  of the signal to use as the AI Convert Clock Timebase.',
            'enum': 'MIOAIConvertTbSrc',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_TIMEBASE_SRC',
            'python_class_name': 'Timing',
            'python_data_type': 'MIOAIConvertTbSrc',
            'resettable': True,
            'type': 'int32'
        },
        4931: {
            'access': 'read-write',
            'c_function_name': 'MasterTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the Master Timebase. On an E Series device, you can choose only between the onboard 20MHz Timebase or the RTSI7 terminal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'MASTER_TIMEBASE_SRC',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        4932: {
            'access': 'read-write',
            'c_function_name': 'SampClkRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the sampling rate in samples per channel per second. If you use an external source for the Sample Clock, set this input to the maximum expected rate of that clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_RATE',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4935: {
            'access': 'read-write',
            'c_function_name': 'SampTimingType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of sample timing to use for the task.',
            'enum': 'SampleTimingType',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_TIMING_TYPE',
            'python_class_name': 'Timing',
            'python_data_type': 'SampleTimingType',
            'resettable': True,
            'type': 'int32'
        },
        5269: {
            'access': 'read-write',
            'c_function_name': 'MasterTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the rate of the Master Timebase.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'MASTER_TIMEBASE_RATE',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5378: {
            'access': 'read-write',
            'c_function_name': 'AIConvSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the AI Convert Clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_SRC',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6216: {
            'access': 'read-write',
            'c_function_name': 'AIConvRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in Hertz the rate at which to clock the analog-to-digital converter. This clock is specific to the analog input section of multiplexed devices.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_RATE',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6226: {
            'access': 'read-write',
            'c_function_name': 'SampClkSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the Sample Clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_SRC',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        6227: {
            'access': 'read-write',
            'c_function_name': 'AIConvActiveEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the clock pulse an analog-to-digital conversion takes place.',
            'enum': 'Edge1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_ACTIVE_EDGE',
            'python_class_name': 'Timing',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        6379: {
            'access': 'read-write',
            'c_function_name': 'SampClkTimebaseDiv',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the number of Sample Clock Timebase pulses needed to produce a single Sample Clock pulse.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_TIMEBASE_DIV',
            'python_class_name': 'Timing',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        6380: {
            'access': 'read-write',
            'c_function_name': 'SampClkTimebaseActiveEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge to recognize a Sample Clock Timebase pulse. This property is useful primarily when the signal you use as the Sample Clock Timebase is not a periodic clock.',
            'enum': 'Edge1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_TIMEBASE_ACTIVE_EDGE',
            'python_class_name': 'Timing',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        8597: {
            'access': 'read-write',
            'c_function_name': 'ChangeDetectDIRisingEdgePhysicalChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the names of the digital lines or ports on which to detect rising edges. The lines or ports must be used by virtual channels in the task. You also can specify a string that contains a list or range of digital lines or ports.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'CHANGE_DETECT_DI_RISING_EDGE_PHYSICAL_CHANS',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Timing',
            'python_data_type': 'PhysicalChannel',
            'resettable': True,
            'type': 'char[]'
        },
        8598: {
            'access': 'read-write',
            'c_function_name': 'ChangeDetectDIFallingEdgePhysicalChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the names of the digital lines or ports on which to detect falling edges. The lines or ports must be used by virtual channels in the task. You also can specify a string that contains a list or range of digital lines or ports.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'CHANGE_DETECT_DI_FALLING_EDGE_PHYSICAL_CHANS',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'Timing',
            'python_data_type': 'PhysicalChannel',
            'resettable': True,
            'type': 'char[]'
        },
        8608: {
            'access': 'read-write',
            'c_function_name': 'OnDemandSimultaneousAOEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to update all channels in the task simultaneously, rather than updating channels independently when you write a sample to that channel.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ON_DEMAND_SIMULTANEOUS_AO_ENABLE',
            'python_class_name': 'Timing',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8734: {
            'access': 'read-write',
            'c_function_name': 'SampClkDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_DIG_FLTR_ENABLE',
            'python_class_name': 'Timing',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8735: {
            'access': 'read-write',
            'c_function_name': 'SampClkDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8736: {
            'access': 'read-write',
            'c_function_name': 'SampClkDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8737: {
            'access': 'read-write',
            'c_function_name': 'SampClkDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8738: {
            'access': 'read-write',
            'c_function_name': 'SampClkDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_DIG_SYNC_ENABLE',
            'python_class_name': 'Timing',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8765: {
            'access': 'read-write',
            'c_function_name': 'SyncPulseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the synchronization pulse. The synchronization pulse resets the clock dividers and the ADCs/DACs on the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_SRC',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8766: {
            'access': 'read',
            'c_function_name': 'SyncPulseSyncTime',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates in seconds the delay required to reset the ADCs/DACs after the device receives the synchronization pulse.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_SYNC_TIME',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        8767: {
            'access': 'read-write',
            'c_function_name': 'SyncPulseMinDelayToStart',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the amount of time that elapses after the master device issues the synchronization pulse before the task starts.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_MIN_DELAY_TO_START',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8898: {
            'access': 'read-write',
            'c_function_name': 'HshkDelayAfterXfer',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the number of seconds to wait after a handshake cycle before starting a new handshake cycle.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_DELAY_AFTER_XFER',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8899: {
            'access': 'read-write',
            'c_function_name': 'HshkStartCond',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the point in the handshake cycle that the device is in when the task starts.',
            'enum': 'HandshakeStartCondition',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_START_COND',
            'python_class_name': 'Timing',
            'python_data_type': 'HandshakeStartCondition',
            'resettable': True,
            'type': 'int32'
        },
        8900: {
            'access': 'read-write',
            'c_function_name': 'HshkSampleInputDataWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of the Handshake Trigger an input task latches the data from the peripheral device.',
            'enum': 'SampleInputDataWhen',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_SAMPLE_INPUT_DATA_WHEN',
            'python_class_name': 'Timing',
            'python_data_type': 'SampleInputDataWhen',
            'resettable': True,
            'type': 'int32'
        },
        8904: {
            'access': 'read',
            'c_function_name': 'SampClkMaxRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the maximum Sample Clock rate supported by the task, based on other timing settings. For output tasks, the maximum Sample Clock rate is the maximum rate of the DAC. For input tasks, NI-DAQmx calculates the maximum sampling rate differently for multiplexed devices than simultaneous sampling devices.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_MAX_RATE',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        8905: {
            'access': 'read',
            'c_function_name': 'AIConvMaxRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates the maximum convert rate supported by the task, given the current devices and channel count.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_MAX_RATE',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        10593: {
            'access': 'read-write',
            'c_function_name': 'SampClkUnderflowBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the action to take when the onboard memory of the device becomes empty. In either case, the sample clock does not stop.',
            'enum': 'UnderflowBehavior',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_UNDERFLOW_BEHAVIOR',
            'python_class_name': 'Timing',
            'python_data_type': 'UnderflowBehavior',
            'resettable': True,
            'type': 'int32'
        },
        10790: {
            'access': 'read-write',
            'c_function_name': 'SampTimingEngine',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies which timing engine to use for the task.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_TIMING_ENGINE',
            'python_class_name': 'Timing',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        11996: {
            'access': 'read-write',
            'c_function_name': 'AIConvDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the AI Convert Clock.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_DIG_FLTR_ENABLE',
            'python_class_name': 'Timing',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        11997: {
            'access': 'read-write',
            'c_function_name': 'AIConvDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        11998: {
            'access': 'read-write',
            'c_function_name': 'AIConvDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        11999: {
            'access': 'read-write',
            'c_function_name': 'AIConvDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12000: {
            'access': 'read-write',
            'c_function_name': 'AIConvDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AI_CONV_DIG_SYNC_ENABLE',
            'python_class_name': 'Timing',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12026: {
            'access': 'read-write',
            'c_function_name': 'ChangeDetectDITristate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to tristate lines specified with **change_detectdi_rising_edge_physical_chans** and **change_detectdi_falling_edge_physical_chans** that are not in a virtual channel in the task. If you set this property to True, NI-DAQmx tristates rising/falling edge lines that are not in a virtual channel in the task. If you set this property to False, NI-DAQmx does not modify the configuration of rising/falling edge lines that are not in a virtual channel in the task, even if the lines were previously tristated. Set this property to False to detect changes on lines in other tasks or to detect changes on output-only lines.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CHANGE_DETECT_DI_TRISTATE',
            'python_class_name': 'Timing',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12028: {
            'access': 'read-write',
            'c_function_name': 'SampClkOverrunBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the action to take if Sample Clock edges occur faster than the device can handle them.',
            'enum': 'OverflowBehavior',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_OVERRUN_BEHAVIOR',
            'python_class_name': 'Timing',
            'python_data_type': 'OverflowBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12029: {
            'access': 'read-write',
            'c_function_name': 'ImplicitUnderflowBehavior',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the action to take when the onboard memory of the device becomes empty.',
            'enum': 'UnderflowBehavior',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'IMPLICIT_UNDERFLOW_BEHAVIOR',
            'python_class_name': 'Timing',
            'python_data_type': 'UnderflowBehavior',
            'resettable': True,
            'type': 'int32'
        },
        12059: {
            'access': 'read',
            'c_function_name': 'SampClkTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the internal Sample Clock terminal for the task. This property does not return the name of the Sample Clock source terminal specified with **samp_clk_src**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_TERM',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12060: {
            'access': 'read',
            'c_function_name': 'SampClkTimebaseTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the internal Sample Clock Timebase terminal for the task. This property does not return the name of the Sample Clock Timebase source terminal specified with **samp_clk_timebase_src**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_TIMEBASE_TERM',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12156: {
            'access': 'read',
            'c_function_name': 'SyncPulseResetTime',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Indicates in seconds the amount of time required for the ADCs or DACs on the device to reset. When synchronizing devices, query this property on all devices and note the largest reset time. Then, for each device, subtract the value of this property from the largest reset time and set **sync_pulse_reset_delay** to the resulting value.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_RESET_TIME',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': False,
            'type': 'float64'
        },
        12157: {
            'access': 'read-write',
            'c_function_name': 'SyncPulseResetDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the amount of time to wait after the Synchronization Pulse before resetting the ADCs or DACs on the device. When synchronizing devices, query **sync_pulse_reset_time** on all devices and note the largest reset time. Then, for each device, subtract the reset time from the largest reset time and set this property to the resulting value.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_RESET_DELAY',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12158: {
            'access': 'read-write',
            'c_function_name': 'SyncClkInterval',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the interval, in Sample Clock periods, between each internal Synchronization Clock pulse. NI-DAQmx uses this pulse for synchronization of triggers between multiple devices at different rates. Refer to device documentation for information about how to calculate this value.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_CLK_INTERVAL',
            'python_class_name': 'Timing',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12165: {
            'access': 'read',
            'c_function_name': 'SyncPulseTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the internal Synchronization Pulse terminal for the task. This property does not return the name of the source terminal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_TERM',
            'python_class_name': 'Timing',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12474: {
            'access': 'read-write',
            'c_function_name': 'TimingSyncPulseForce',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': "Specifies whether a synchronization pulse should be generated at start regardless of whether devices in the task are synchronized. When set to false, a synchronization pulse will be generated only if all devices in the task are not synchronized. Some DSA AO devices have unexpected behavior during DAC synchronization. Refer to your device's documentation for more information.",
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TIMING_SYNC_PULSE_FORCE',
            'python_class_name': 'Timing',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12540: {
            'access': 'read-write',
            'c_function_name': 'SampClkWriteWfmUseInitialWfmDT',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies that the value of **samp_clk_rate** will be determined by the dt component of the initial DAQmx Write waveform input for Output tasks.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SAMP_CLK_WRITE_WFM_USE_INITIAL_WFM_DT',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12598: {
            'access': 'read-write',
            'c_function_name': 'SyncPulseType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of sync pulse used in the task.',
            'enum': 'SyncPulseType',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_TYPE',
            'python_class_name': 'Timing',
            'python_data_type': 'SyncPulseType',
            'resettable': True,
            'type': 'int32'
        },
        12599: {
            'access': 'read-write',
            'c_function_name': 'SyncPulseTimeWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.CVIAbsoluteTime',
            'description': 'Specifies the start time of the sync pulse.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_TIME_WHEN',
            'python_class_name': 'Timing',
            'python_data_type': 'unknown',
            'resettable': True,
            'type': 'CVIAbsoluteTime'
        },
        12600: {
            'access': 'read-write',
            'c_function_name': 'SyncPulseTimeTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the timescale to be used for timestamps for a sync pulse.',
            'enum': 'Timescale2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_PULSE_TIME_TIMESCALE',
            'python_class_name': 'Timing',
            'python_data_type': 'Timescale2',
            'resettable': True,
            'type': 'int32'
        },
        12601: {
            'access': 'read-write',
            'c_function_name': 'FirstSampTimestampEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to enable the first sample timestamp.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'FIRST_SAMP_TIMESTAMP_ENABLE',
            'python_class_name': 'Timing',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12602: {
            'access': 'read',
            'c_function_name': 'FirstSampTimestampVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.CVIAbsoluteTime',
            'description': 'Indicates the timestamp of the first sample.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'FIRST_SAMP_TIMESTAMP_VAL',
            'python_class_name': 'Timing',
            'python_data_type': 'unknown',
            'resettable': False,
            'type': 'CVIAbsoluteTime'
        },
        12603: {
            'access': 'read-write',
            'c_function_name': 'FirstSampTimestampTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the timescale to be used for the first sample timestamp.',
            'enum': 'Timescale2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'FIRST_SAMP_TIMESTAMP_TIMESCALE',
            'python_class_name': 'Timing',
            'python_data_type': 'Timescale2',
            'resettable': True,
            'type': 'int32'
        },
        12674: {
            'access': 'read-write',
            'c_function_name': 'FirstSampClkWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.CVIAbsoluteTime',
            'description': 'Specifies the time of the first sample clock pulse.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'FIRST_SAMP_CLK_WHEN',
            'python_class_name': 'Timing',
            'python_data_type': 'unknown',
            'resettable': True,
            'type': 'CVIAbsoluteTime'
        },
        12675: {
            'access': 'read-write',
            'c_function_name': 'FirstSampClkTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the timescale to be used for the value of **first_samp_clk_when**.',
            'enum': 'Timescale2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'FIRST_SAMP_CLK_TIMESCALE',
            'python_class_name': 'Timing',
            'python_data_type': 'Timescale2',
            'resettable': True,
            'type': 'int32'
        },
        12714: {
            'access': 'read-write',
            'c_function_name': 'FirstSampClkOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies, in seconds, the offset to apply to the **first_samp_clk_when** value. This offset modifies when the first sample clock occurs and is used to account for known delays in the signal path.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'FIRST_SAMP_CLK_OFFSET',
            'python_class_name': 'Timing',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        }
    },
    'Trigger': {
        4960: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeAdvTrigEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': '(Deprecated) Specifies on which edge of a digital signal to advance to the next entry in a scan list.',
            'enum': 'Edge1',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ADV_TRIG_EDGE',
            'python_class_name': 'N/A',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        4962: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeAdvTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': '(Deprecated) Specifies the name of a terminal where there is a digital signal to use as the source of the Advance Trigger.',
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ADV_TRIG_SRC',
            'python_class_name': 'N/A',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        4965: {
            'access': 'read-write',
            'c_function_name': 'AdvTrigType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': '(Deprecated) Specifies the type of trigger to use to advance to the next entry in a switch scan list.',
            'enum': 'TriggerType5',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ADV_TRIG_TYPE',
            'python_class_name': 'N/A',
            'python_data_type': 'TriggerType5',
            'resettable': True,
            'type': 'int32'
        },
        4966: {
            'access': 'read-write',
            'c_function_name': 'PauseTrigType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of trigger to use to pause a task.',
            'enum': 'TriggerType6',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PAUSE_TRIG_TYPE',
            'python_class_name': 'PauseTrigger',
            'python_data_type': 'TriggerType6',
            'resettable': True,
            'type': 'int32'
        },
        4968: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a hysteresis level in the units of the measurement or generation. If **pause_anlg_lvl_when** is **ActiveLevel.ABOVELVL**, the trigger does not deassert until the source signal passes below **pause_anlg_lvl_lvl** minus the hysteresis. If **pause_anlg_lvl_when** is **ActiveLevel.BELOWLVL**, the trigger does not deassert until the source signal passes above **pause_anlg_lvl_lvl** plus the hysteresis. Hysteresis is always enabled. Set this property to a non-zero value to use hysteresis.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_HYST',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4969: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the threshold at which to pause the task. Specify this value in the units of the measurement or generation. Use **pause_anlg_lvl_when** to specify whether the task pauses above or below this threshold.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_LVL',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4976: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a virtual channel or terminal where there is an analog signal to use as the source of the trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_SRC',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        4977: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the task pauses above or below the threshold you specify with **pause_anlg_lvl_lvl**.',
            'enum': 'ActiveLevel',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_WHEN',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'ActiveLevel',
            'resettable': True,
            'type': 'int32'
        },
        4979: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a virtual channel or terminal where there is an analog signal to use as the source of the trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_SRC',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        4980: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the task pauses while the trigger signal is inside or outside the window you specify with **pause_anlg_win_btm** and **pause_anlg_win_top**.',
            'enum': 'WindowTriggerCondition2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_WHEN',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'WindowTriggerCondition2',
            'resettable': True,
            'type': 'int32'
        },
        4981: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigBtm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the lower limit of the window. Specify this value in the units of the measurement or generation.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_BTM',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4982: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigTop',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the upper limit of the window. Specify this value in the units of the measurement or generation.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_TOP',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        4985: {
            'access': 'read-write',
            'c_function_name': 'DigLvlPauseTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a terminal where there is a digital signal to use as the source of the Pause Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_LVL_PAUSE_TRIG_SRC',
            'python_class_name': 'DigitalLevelPauseTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        4992: {
            'access': 'read-write',
            'c_function_name': 'DigLvlPauseTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the task pauses while the signal is high or low.',
            'enum': 'Level1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_LVL_PAUSE_TRIG_WHEN',
            'python_class_name': 'DigitalLevelPauseTrigger',
            'python_data_type': 'Level1',
            'resettable': True,
            'type': 'int32'
        },
        5011: {
            'access': 'read-write',
            'c_function_name': 'StartTrigType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of trigger to use to start a task.',
            'enum': 'TriggerType10',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_TYPE',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'TriggerType10',
            'resettable': True,
            'type': 'int32'
        },
        5013: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a hysteresis level in the units of the measurement or generation. If **start_anlg_edge_slope** is **Slope1.RISINGSLOPE**, the trigger does not deassert until the source signal passes below  **start_anlg_edge_lvl** minus the hysteresis. If **start_anlg_edge_slope** is **Slope1.FALLINGSLOPE**, the trigger does not deassert until the source signal passes above **start_anlg_edge_lvl** plus the hysteresis. Hysteresis is always enabled. Set this property to a non-zero value to use hysteresis.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_HYST',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5014: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies at what threshold in the units of the measurement or generation to start acquiring or generating samples. Use **start_anlg_edge_slope** to specify on which slope to trigger on this threshold.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_LVL',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5015: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigSlope',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which slope of the trigger signal to start acquiring or generating samples.',
            'enum': 'Slope1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_SLOPE',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'Slope1',
            'resettable': True,
            'type': 'int32'
        },
        5016: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a virtual channel or terminal where there is an analog signal to use as the source of the Start Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_SRC',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5120: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a virtual channel or terminal where there is an analog signal to use as the source of the Start Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_SRC',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5121: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the task starts acquiring or generating samples when the signal enters or leaves the window you specify with **start_anlg_win_btm** and **start_anlg_win_top**.',
            'enum': 'WindowTriggerCondition1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_WHEN',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'WindowTriggerCondition1',
            'resettable': True,
            'type': 'int32'
        },
        5122: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigBtm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the lower limit of the window. Specify this value in the units of the measurement or generation.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_BTM',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5123: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigTop',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the upper limit of the window. Specify this value in the units of the measurement or generation.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_TOP',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5124: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeStartTrigEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of a digital pulse to start acquiring or generating samples.',
            'enum': 'Edge1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_START_TRIG_EDGE',
            'python_class_name': 'DigitalEdgeStartTrigger',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        5127: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeStartTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a terminal where there is a digital signal to use as the source of the Start Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_START_TRIG_SRC',
            'python_class_name': 'DigitalEdgeStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5136: {
            'access': 'read-write',
            'c_function_name': 'DigPatternStartTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the physical channels to use for pattern matching. The order of the physical channels determines the order of the pattern. If a port is included, the order of the physical channels within the port is in ascending order.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'DIG_PATTERN_START_TRIG_SRC',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'DigitalPatternStartTrigger',
            'python_data_type': 'PhysicalChannel',
            'resettable': True,
            'type': 'char[]'
        },
        5137: {
            'access': 'read-write',
            'c_function_name': 'DigPatternStartTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the Start Trigger occurs when the physical channels specified with **start_dig_pattern_src** match or differ from the digital pattern specified with **start_dig_pattern_pattern**.',
            'enum': 'DigitalPatternCondition1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_PATTERN_START_TRIG_WHEN',
            'python_class_name': 'DigitalPatternStartTrigger',
            'python_data_type': 'DigitalPatternCondition1',
            'resettable': True,
            'type': 'int32'
        },
        5140: {
            'access': 'read-write',
            'c_function_name': 'ArmStartTrigType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of trigger to use to arm the task for a Start Trigger. If you configure an Arm Start Trigger, the task does not respond to a Start Trigger until the device receives the Arm Start Trigger.',
            'enum': 'TriggerType4',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ARM_START_TRIG_TYPE',
            'python_class_name': 'ArmStartTrigger',
            'python_data_type': 'TriggerType4',
            'resettable': True,
            'type': 'int32'
        },
        5141: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeArmStartTrigEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of a digital signal to arm the task for a Start Trigger.',
            'enum': 'Edge1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ARM_START_TRIG_EDGE',
            'python_class_name': 'DigitalEdgeArmStartTrigger',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        5143: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeArmStartTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a terminal where there is a digital signal to use as the source of the Arm Start Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ARM_START_TRIG_SRC',
            'python_class_name': 'DigitalEdgeArmStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5145: {
            'access': 'read-write',
            'c_function_name': 'RefTrigType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of trigger to use to mark a reference point for the measurement.',
            'enum': 'TriggerType8',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_TYPE',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'TriggerType8',
            'resettable': True,
            'type': 'int32'
        },
        5153: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigHyst',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies a hysteresis level in the units of the measurement. If **ref_anlg_edge_slope** is **Slope1.RISINGSLOPE**, the trigger does not deassert until the source signal passes below **ref_anlg_edge_lvl** minus the hysteresis. If **ref_anlg_edge_slope** is **Slope1.FALLINGSLOPE**, the trigger does not deassert until the source signal passes above **ref_anlg_edge_lvl** plus the hysteresis. Hysteresis is always enabled. Set this property to a non-zero value to use hysteresis.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_HYST',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5154: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in the units of the measurement the threshold at which the Reference Trigger occurs.  Use **ref_anlg_edge_slope** to specify on which slope to trigger at this threshold.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_LVL',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5155: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigSlope',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which slope of the source signal the Reference Trigger occurs.',
            'enum': 'Slope1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_SLOPE',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'Slope1',
            'resettable': True,
            'type': 'int32'
        },
        5156: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a virtual channel or terminal where there is an analog signal to use as the source of the Reference Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_SRC',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5158: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a virtual channel or terminal where there is an analog signal to use as the source of the Reference Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_SRC',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5159: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the Reference Trigger occurs when the source signal enters the window or when it leaves the window. Use **ref_anlg_win_btm** and **ref_anlg_win_top** to specify the window.',
            'enum': 'WindowTriggerCondition1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_WHEN',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'WindowTriggerCondition1',
            'resettable': True,
            'type': 'int32'
        },
        5160: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigBtm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the lower limit of the window. Specify this value in the units of the measurement.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_BTM',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5161: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigTop',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the upper limit of the window. Specify this value in the units of the measurement.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_TOP',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        5168: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeRefTrigEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on what edge of a digital pulse the Reference Trigger occurs.',
            'enum': 'Edge1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_REF_TRIG_EDGE',
            'python_class_name': 'DigitalEdgeReferenceTrigger',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        5172: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeRefTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a terminal where there is a digital signal to use as the source of the Reference Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_REF_TRIG_SRC',
            'python_class_name': 'DigitalEdgeReferenceTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        5175: {
            'access': 'read-write',
            'c_function_name': 'DigPatternRefTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the physical channels to use for pattern matching. The order of the physical channels determines the order of the pattern. If a port is included, the order of the physical channels within the port is in ascending order.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'DIG_PATTERN_REF_TRIG_SRC',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'DigitalPatternReferenceTrigger',
            'python_data_type': 'PhysicalChannel',
            'resettable': True,
            'type': 'char[]'
        },
        5176: {
            'access': 'read-write',
            'c_function_name': 'DigPatternRefTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether the Reference Trigger occurs when the physical channels specified with **ref_dig_pattern_src** match or differ from the digital pattern specified with **ref_dig_pattern_pattern**.',
            'enum': 'DigitalPatternCondition1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_PATTERN_REF_TRIG_WHEN',
            'python_class_name': 'DigitalPatternReferenceTrigger',
            'python_data_type': 'DigitalPatternCondition1',
            'resettable': True,
            'type': 'int32'
        },
        5189: {
            'access': 'read-write',
            'c_function_name': 'RefTrigPretrigSamples',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the minimum number of pretrigger samples to acquire from each channel before recognizing the reference trigger. Post-trigger samples per channel are equal to **samp_quant_samp_per_chan** minus the number of pretrigger samples per channel.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_PRETRIG_SAMPLES',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        5251: {
            'access': 'read-write',
            'c_function_name': 'RefTrigDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the time to wait after the device receives the Reference Trigger before switching from pretrigger to posttrigger samples.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_DELAY',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6230: {
            'access': 'read-write',
            'c_function_name': 'StartTrigDelay',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies an amount of time to wait after the Start Trigger is received before acquiring or generating the first sample. This value is in the units you specify with **start_delay_units**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_DELAY',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        6231: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigCoupling',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the coupling for the source signal of the trigger if the source is a terminal rather than a virtual channel.',
            'enum': 'Coupling2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_COUPLING',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'Coupling2',
            'resettable': True,
            'type': 'int32'
        },
        6344: {
            'access': 'read-write',
            'c_function_name': 'StartTrigDelayUnits',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the units of **start_delay**.',
            'enum': 'DigitalWidthUnits1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_DELAY_UNITS',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'DigitalWidthUnits1',
            'resettable': True,
            'type': 'int32'
        },
        6415: {
            'access': 'read-write',
            'c_function_name': 'StartTrigRetriggerable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether a finite task resets and waits for another Start Trigger after the task completes. When you set this property to True, the device performs a finite acquisition or generation each time the Start Trigger occurs until the task stops. The device ignores a trigger if it is in the process of acquiring or generating signals.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_RETRIGGERABLE',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8559: {
            'access': 'read-write',
            'c_function_name': 'DigPatternPauseTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the physical channels to use for pattern matching. The order of the physical channels determines the order of the pattern. If a port is included, the lines within the port are in ascending order.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': True,
            'name': 'DIG_PATTERN_PAUSE_TRIG_SRC',
            'object_module_location': 'nidaqmx.system.physical_channel',
            'object_type': 'PhysicalChannel',
            'python_class_name': 'DigitalPatternPauseTrigger',
            'python_data_type': 'PhysicalChannel',
            'resettable': True,
            'type': 'char[]'
        },
        8560: {
            'access': 'read-write',
            'c_function_name': 'DigPatternPauseTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies if the Pause Trigger occurs when the physical channels specified with **pause_dig_pattern_src** match or differ from the digital pattern specified with **pause_dig_pattern_pattern**.',
            'enum': 'DigitalPatternCondition1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_PATTERN_PAUSE_TRIG_WHEN',
            'python_class_name': 'DigitalPatternPauseTrigger',
            'python_data_type': 'DigitalPatternCondition1',
            'resettable': True,
            'type': 'int32'
        },
        8582: {
            'access': 'read-write',
            'c_function_name': 'DigPatternStartTrigPattern',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the digital pattern that must be met for the Start Trigger to occur.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_PATTERN_START_TRIG_PATTERN',
            'python_class_name': 'DigitalPatternStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8583: {
            'access': 'read-write',
            'c_function_name': 'DigPatternRefTrigPattern',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the digital pattern that must be met for the Reference Trigger to occur.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_PATTERN_REF_TRIG_PATTERN',
            'python_class_name': 'DigitalPatternReferenceTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8584: {
            'access': 'read-write',
            'c_function_name': 'DigPatternPauseTrigPattern',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the digital pattern that must be met for the Pause Trigger to occur.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_PATTERN_PAUSE_TRIG_PATTERN',
            'python_class_name': 'DigitalPatternPauseTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8739: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeStartTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the trigger signal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_START_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'DigitalEdgeStartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8740: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeStartTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_START_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'DigitalEdgeStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8741: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeStartTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_START_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'DigitalEdgeStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8742: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeStartTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_START_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'DigitalEdgeStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8743: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeStartTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device. If you set this property to True, the device does not recognize and act upon the trigger until the next pulse of the internal timebase.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_START_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'DigitalEdgeStartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8744: {
            'access': 'read-write',
            'c_function_name': 'DigLvlPauseTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the trigger signal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_LVL_PAUSE_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'DigitalLevelPauseTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8745: {
            'access': 'read-write',
            'c_function_name': 'DigLvlPauseTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_LVL_PAUSE_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'DigitalLevelPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8746: {
            'access': 'read-write',
            'c_function_name': 'DigLvlPauseTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_LVL_PAUSE_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'DigitalLevelPauseTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8747: {
            'access': 'read-write',
            'c_function_name': 'DigLvlPauseTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_LVL_PAUSE_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'DigitalLevelPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8748: {
            'access': 'read-write',
            'c_function_name': 'DigLvlPauseTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_LVL_PAUSE_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'DigitalLevelPauseTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8749: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeArmStartTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply the pulse width filter to the signal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ARM_START_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'DigitalEdgeArmStartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8750: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeArmStartTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ARM_START_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'DigitalEdgeArmStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8751: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeArmStartTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the input terminal of the signal to use as the timebase of the pulse width filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ARM_START_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'DigitalEdgeArmStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8752: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeArmStartTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the pulse width filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ARM_START_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'DigitalEdgeArmStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        8753: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeArmStartTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ARM_START_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'DigitalEdgeArmStartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8755: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigCoupling',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the coupling for the source signal of the trigger if the source is a terminal rather than a virtual channel.',
            'enum': 'Coupling2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_COUPLING',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'Coupling2',
            'resettable': True,
            'type': 'int32'
        },
        8756: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigCoupling',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the coupling for the source signal of the trigger if the source is a terminal rather than a virtual channel.',
            'enum': 'Coupling2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_COUPLING',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'Coupling2',
            'resettable': True,
            'type': 'int32'
        },
        8757: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigCoupling',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the coupling for the source signal of the trigger if the source is a terminal rather than a virtual channel.',
            'enum': 'Coupling2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_COUPLING',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'Coupling2',
            'resettable': True,
            'type': 'int32'
        },
        8758: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigCoupling',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the coupling for the source signal of the trigger if the source is a terminal rather than a virtual channel.',
            'enum': 'Coupling2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_COUPLING',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'Coupling2',
            'resettable': True,
            'type': 'int32'
        },
        8759: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigCoupling',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the coupling for the source signal of the terminal if the source is a terminal rather than a virtual channel.',
            'enum': 'Coupling2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_COUPLING',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'Coupling2',
            'resettable': True,
            'type': 'int32'
        },
        8760: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeAdvTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': '(Deprecated) Specifies whether to apply the pulse width filter to the signal.',
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_ADV_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'N/A',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        8887: {
            'access': 'read-write',
            'c_function_name': 'HshkTrigType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of Handshake Trigger to use.',
            'enum': 'TriggerType9',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HSHK_TRIG_TYPE',
            'python_class_name': 'HandshakeTrigger',
            'python_data_type': 'TriggerType9',
            'resettable': True,
            'type': 'int32'
        },
        8888: {
            'access': 'read-write',
            'c_function_name': 'InterlockedHshkTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the source terminal of the Handshake Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'INTERLOCKED_HSHK_TRIG_SRC',
            'python_class_name': 'InterlockedHandshakeTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8889: {
            'access': 'read-write',
            'c_function_name': 'InterlockedHshkTrigAssertedLvl',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the asserted level of the Handshake Trigger.',
            'enum': 'Level1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'INTERLOCKED_HSHK_TRIG_ASSERTED_LVL',
            'python_class_name': 'InterlockedHandshakeTrigger',
            'python_data_type': 'Level1',
            'resettable': True,
            'type': 'int32'
        },
        11969: {
            'access': 'read-write',
            'c_function_name': 'RefTrigAutoTrigEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to send a software trigger to the device when a hardware trigger is no longer active in order to prevent a timeout.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_AUTO_TRIG_ENABLE',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        11970: {
            'access': 'read',
            'c_function_name': 'RefTrigAutoTriggered',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether a completed acquisition was triggered by the auto trigger. If an acquisition has not completed after the task starts, this property returns False. This property is only applicable when **ref_auto_trig_enable**  is True.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_AUTO_TRIGGERED',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        11991: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeRefTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the trigger signal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_REF_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'DigitalEdgeReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        11992: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeRefTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_REF_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'DigitalEdgeReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        11993: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeRefTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_REF_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'DigitalEdgeReferenceTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        11994: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeRefTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_REF_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'DigitalEdgeReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        11995: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeRefTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_REF_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'DigitalEdgeReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12001: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the digital output of the analog triggering circuitry (the Analog Comparison Event). When enabled, the analog signal must stay above or below the trigger level for the minimum pulse width before being recognized. Use filtering  for noisy trigger signals that transition in and out of the hysteresis window rapidly.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12002: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12003: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12004: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12005: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeStartTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_START_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'AnalogEdgeStartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12006: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the digital output of the analog triggering circuitry (the Analog Comparison Event). When enabled, the analog signal must stay above or below the trigger level for the minimum pulse width before being recognized. Use filtering  for noisy trigger signals that transition in and out of the hysteresis window rapidly.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12007: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width thefilter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12008: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12009: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12010: {
            'access': 'read-write',
            'c_function_name': 'AnlgEdgeRefTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_EDGE_REF_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'AnalogEdgeReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12011: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the digital output of the analog triggering circuitry (the Analog Comparison Event). When enabled, the analog signal must stay within the trigger window for the minimum pulse width before being recognized. Use filtering for noisy trigger signals that transition in and out of the window rapidly.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12012: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12013: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12014: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12015: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinRefTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_REF_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'AnalogWindowReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12016: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the digital output of the analog triggering circuitry (the Analog Comparison Event). When enabled, the analog signal must stay above or below the trigger level for the minimum pulse width before being recognized. Use filtering  for noisy trigger signals that transition in and out of the hysteresis window rapidly.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12017: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12018: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12019: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12020: {
            'access': 'read-write',
            'c_function_name': 'AnlgLvlPauseTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_LVL_PAUSE_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'AnalogLevelPauseTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12021: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the digital output of the analog triggering circuitry (the Analog Comparison Event). When enabled, the analog signal must stay within the trigger window for the minimum pulse width before being recognized. Use filtering for noisy trigger signals that transition in and out of the window rapidly.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12022: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12023: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12024: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12025: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinPauseTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_PAUSE_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'AnalogWindowPauseTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12031: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigDigFltrEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to apply a digital filter to the digital output of the analog triggering circuitry (the Analog Comparison Event). When enabled, the analog signal must stay within the trigger window for the minimum pulse width before being recognized. Use filtering for noisy trigger signals that transition in and out of the window rapidly.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_DIG_FLTR_ENABLE',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12032: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigDigFltrMinPulseWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the minimum pulse width the filter recognizes.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_DIG_FLTR_MIN_PULSE_WIDTH',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12033: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigDigFltrTimebaseSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the terminal of the signal to use as the timebase of the digital filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_DIG_FLTR_TIMEBASE_SRC',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12034: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigDigFltrTimebaseRate',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in hertz the rate of the digital filter timebase. NI-DAQmx uses this value to compute settings for the filter.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_DIG_FLTR_TIMEBASE_RATE',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12035: {
            'access': 'read-write',
            'c_function_name': 'AnlgWinStartTrigDigSyncEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether to synchronize recognition of transitions in the signal to the internal timebase of the device.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_WIN_START_TRIG_DIG_SYNC_ENABLE',
            'python_class_name': 'AnalogWindowStartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12062: {
            'access': 'read',
            'c_function_name': 'StartTrigTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the internal Start Trigger terminal for the task. This property does not return the name of the trigger source terminal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_TERM',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12063: {
            'access': 'read',
            'c_function_name': 'RefTrigTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the internal Reference Trigger terminal for the task. This property does not return the name of the trigger source terminal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_TERM',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12064: {
            'access': 'read',
            'c_function_name': 'PauseTrigTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the internal Pause Trigger terminal for the task. This property does not return the name of the trigger source terminal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'PAUSE_TRIG_TERM',
            'python_class_name': 'PauseTrigger',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12159: {
            'access': 'read',
            'c_function_name': 'ArmStartTerm',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the name of the internal Arm Start Trigger terminal for the task. This property does not return the name of the trigger source terminal.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ARM_START_TERM',
            'python_class_name': 'ArmStartTrigger',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12160: {
            'access': 'read-write',
            'c_function_name': 'TriggerSyncType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the role of the device in a synchronized system. Setting this value to  **SyncType.MASTER** or  **SyncType.SLAVE** enables trigger skew correction. If you enable trigger skew correction, set this property to **SyncType.MASTER** on only one device, and set this property to **SyncType.SLAVE** on the other devices.',
            'enum': 'SyncType',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TRIGGER_SYNC_TYPE',
            'python_class_name': 'Triggers',
            'python_data_type': 'SyncType',
            'resettable': True,
            'type': 'int32'
        },
        12317: {
            'access': 'read-write',
            'c_function_name': 'TimeStartTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the terminal to be used for start time triggering ',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TIME_START_TRIG_SRC',
            'python_class_name': 'N/A',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12342: {
            'access': 'read-write',
            'c_function_name': 'StartTrigTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the timescale to be used for timestamps used in a time trigger.',
            'enum': 'Timescale2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_TIMESCALE',
            'python_class_name': 'TimeStartTrigger',
            'python_data_type': 'Timescale2',
            'resettable': True,
            'type': 'int32'
        },
        12365: {
            'access': 'read-write',
            'c_function_name': 'StartTrigTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.CVIAbsoluteTime',
            'description': 'Specifies when to trigger the start trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_TRIG_WHEN',
            'python_class_name': 'TimeStartTrigger',
            'python_data_type': 'unknown',
            'resettable': True,
            'type': 'CVIAbsoluteTime'
        },
        12570: {
            'access': 'read-write',
            'c_function_name': 'StartTrigTrigWin',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the period of time in seconds after the task starts during which the device may trigger. Once the window has expired, the device stops detecting triggers, and the task will finish after the device finishes acquiring post-trigger samples for any triggers detected. If no triggers are detected during the entire period, then no data will be returned. Ensure the period of time specified covers the entire time span desired for trigger detection to avoid missed triggers. Specifying a Trigger Window of -1 causes the window to be infinite.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_TRIG_WIN',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12571: {
            'access': 'read-write',
            'c_function_name': 'StartTrigRetriggerWin',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the period of time in seconds after each trigger during which the device may trigger. Once the window has expired, the device stops detecting triggers, and the task will finish after the device finishes acquiring post-trigger samples that it already started. Ensure the period of time specified covers the entire time span desired for retrigger detection to avoid missed triggers. Specifying a Retrigger Window of -1 causes the window to be infinite.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_RETRIGGER_WIN',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12572: {
            'access': 'read-write',
            'c_function_name': 'StartTrigMaxNumTrigsToDetect',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum number of times the task will detect a start trigger during the task. The number of times a trigger is detected and acted upon by the module may be less than the specified amount if the task stops early because of trigger/retrigger window expiration. Specifying the Maximum Number of Triggers to Detect to be 0 causes the driver to automatically set this value to the maximum possible number of triggers detectable by the device and configuration combination. Note: The number of detected triggers may be less than number of trigger events occurring, because the devices were unable to respond to the trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_MAX_NUM_TRIGS_TO_DETECT',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12573: {
            'access': 'read-write',
            'c_function_name': 'RefTrigRetriggerable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether a finite task resets, acquires pretrigger samples, and waits for another Reference Trigger after the task completes. When you set this property to True, the device will acquire post-trigger samples, reset, and acquire pretrigger samples each time the Reference Trigger occurs until the task stops. The device ignores a trigger if it is in the process of acquiring signals.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_RETRIGGERABLE',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12574: {
            'access': 'read-write',
            'c_function_name': 'RefTrigTrigWin',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the duration in seconds after the task starts during which the device may trigger. Once the window has passed, the device stops detecting triggers, and the task will stop after the device finishes acquiring post-trigger samples that it already started. If no triggers are detected during the entire period, then no data will be returned. Specifying a Trigger Window of -1 causes the window to be infinite.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_TRIG_WIN',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12575: {
            'access': 'read-write',
            'c_function_name': 'RefTrigRetriggerWin',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the duration in seconds after each trigger during which the device may trigger. Once the window has passed, the device stops detecting triggers, and the task will stop after the device finishes acquiring post-trigger samples that it already started. Specifying a Retrigger Window of -1 causes the window to be infinite.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_RETRIGGER_WIN',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12576: {
            'access': 'read-write',
            'c_function_name': 'RefTrigMaxNumTrigsToDetect',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Specifies the maximum number of times the task will detect a reference trigger during the task. The number of times a trigger is detected and acted upon by the module may be less than the specified amount if the task stops early because of trigger/retrigger window expiration. Specifying the Maximum Number of Triggers to Detect to be 0 causes the driver to automatically set this value to the maximum possible number of triggers detectable by the device and configuration combination. Note: The number of detected triggers may be less than number of trigger events occurring, because the devices were unable to respond to the trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_MAX_NUM_TRIGS_TO_DETECT',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'uInt32'
        },
        12577: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeStartTrigSrcs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies a list and/or range of analog sources that are going to be used for Analog triggering. Each source corresponds to an element in each of the Analog Multi Edge property lists, if they are not empty.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_START_TRIG_SRCS',
            'python_class_name': 'AnalogMultiEdgeStartTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12578: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeStartTrigSlopes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Specifies an list of slopes on which to trigger task to start generating or acquiring samples. Each element of the list corresponds to a source in Start.AnlgMultiEdge.Srcs and an element in each of the other Analog Multi Edge property lists, if they are not empty.',
            'enum': 'Slope1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_START_TRIG_SLOPES',
            'python_class_name': 'AnalogMultiEdgeStartTrigger',
            'python_data_type': 'Slope1',
            'resettable': True,
            'type': 'int32[]'
        },
        12579: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeStartTrigLvls',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies an list of thresholds in the units of the measurement or generation to start acquiring or generating samples. Each element of the list corresponds to a source in Start.AnlgMultiEdge.Srcs and an element in each of the other Analog Multi Edge property lists, if they are not empty.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_START_TRIG_LVLS',
            'python_class_name': 'AnalogMultiEdgeStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        12580: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeStartTrigHysts',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies an list of hysteresis levels in the units of the measurement or generation. If the corresponding element of Start.AnlgMultiEdge.Slopes is Rising, the trigger does not deassert until the source signal passes below the corresponding element of Start.AnlgMultiEdge.Lvls minus the hysteresis. If Start.AnlgEdge.Slope is Falling, the trigger does not deassert until the source signal passes above Start.AnlgEdge.Lvl plus the hysteresis. Hysteresis is always enabled. Set this property to a non-zero value to use hysteresis. Each element of the list corresponds to a source in Start.AnlgMultiEdge.Srcs and an element in each of the other Analog Multi Edge property lists, if they are not empty.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_START_TRIG_HYSTS',
            'python_class_name': 'AnalogMultiEdgeStartTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        12581: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeStartTrigCouplings',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Specifies an list that describes the couplings for the corresponding source signal of the trigger if the source is a terminal rather than a virtual channel. Each element of the list corresponds to a source in Start.AnlgMultiEdge.Srcs and an element in each of the other Analog Multi Edge property lists, if they are not empty.',
            'enum': 'Coupling2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_START_TRIG_COUPLINGS',
            'python_class_name': 'AnalogMultiEdgeStartTrigger',
            'python_data_type': 'Coupling2',
            'resettable': True,
            'type': 'int32[]'
        },
        12582: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeRefTrigSrcs',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies a List and/or range of analog sources that are going to be used for Analog triggering. Each source corresponds to an element in each of the Analog Multi Edge property lists, if they are not empty.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_REF_TRIG_SRCS',
            'python_class_name': 'AnalogMultiEdgeReferenceTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        12583: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeRefTrigSlopes',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Specifies an list of slopes on which to trigger task to start generating or acquiring samples. Each element of the list corresponds to a source in Ref.AnlgMultiEdge.Srcs and an element in each of the other Analog Multi Edge property lists, if they are not empty.',
            'enum': 'Slope1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_REF_TRIG_SLOPES',
            'python_class_name': 'AnalogMultiEdgeReferenceTrigger',
            'python_data_type': 'Slope1',
            'resettable': True,
            'type': 'int32[]'
        },
        12584: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeRefTrigLvls',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies an list of thresholds in the units of the measurement or generation to start acquiring or generating samples. Each element of the list corresponds to a source in Ref.AnlgMultiEdge.Srcs and an element in each of the other Analog Multi Edge property lists, if they are not empty.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_REF_TRIG_LVLS',
            'python_class_name': 'AnalogMultiEdgeReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        12585: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeRefTrigHysts',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.float64',
            'description': 'Specifies an list of hysteresis levels in the units of the measurement or generation. If the corresponding element of Ref.AnlgMultiEdge.Slopes is Rising, the trigger does not deassert until the source signal passes below the corresponding element of Ref.AnlgMultiEdge.Lvls minus the hysteresis. If Ref.AnlgEdge.Slope is Falling, the trigger does not deassert until the source signal passes above Ref.AnlgEdge.Lvl plus the hysteresis. Hysteresis is always enabled. Set this property to a non-zero value to use hysteresis. Each element of the list corresponds to a source in Ref.AnlgMultiEdge.Srcs and an element in each of the other Analog Multi Edge property lists, if they are not empty.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_REF_TRIG_HYSTS',
            'python_class_name': 'AnalogMultiEdgeReferenceTrigger',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64[]'
        },
        12586: {
            'access': 'read-write',
            'c_function_name': 'AnlgMultiEdgeRefTrigCouplings',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'numpy.int32',
            'description': 'Specifies an list that describes the couplings for the corresponding source signal of the trigger if the source is a terminal rather than a virtual channel. Each element of the list corresponds to a source in Ref.AnlgMultiEdge.Srcs and an element in each of the other Analog Multi Edge property lists, if they are not empty.',
            'enum': 'Coupling2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'ANLG_MULTI_EDGE_REF_TRIG_COUPLINGS',
            'python_class_name': 'AnalogMultiEdgeReferenceTrigger',
            'python_data_type': 'Coupling2',
            'resettable': True,
            'type': 'int32[]'
        },
        12589: {
            'access': 'read-write',
            'c_function_name': 'StartTrigTimestampTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the start trigger timestamp timescale.',
            'enum': 'Timescale2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_TIMESTAMP_TIMESCALE',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'Timescale2',
            'resettable': True,
            'type': 'int32'
        },
        12590: {
            'access': 'read-write',
            'c_function_name': 'RefTrigTimestampEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether the reference trigger timestamp is enabled. If the timestamp is enabled but no resources are available, an error will be returned at run time.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_TIMESTAMP_ENABLE',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12591: {
            'access': 'read',
            'c_function_name': 'RefTrigTimestampVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.CVIAbsoluteTime',
            'description': 'Indicates the reference trigger timestamp value.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_TIMESTAMP_VAL',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'unknown',
            'resettable': False,
            'type': 'CVIAbsoluteTime'
        },
        12592: {
            'access': 'read-write',
            'c_function_name': 'RefTrigTimestampTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the reference trigger timestamp timescale.',
            'enum': 'Timescale2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REF_TRIG_TIMESTAMP_TIMESCALE',
            'python_class_name': 'ReferenceTrigger',
            'python_data_type': 'Timescale2',
            'resettable': True,
            'type': 'int32'
        },
        12593: {
            'access': 'read-write',
            'c_function_name': 'ArmStartTrigTrigWhen',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.CVIAbsoluteTime',
            'description': 'Specifies when to trigger the arm start trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ARM_START_TRIG_TRIG_WHEN',
            'python_class_name': 'TimeArmStartTrigger',
            'python_data_type': 'unknown',
            'resettable': True,
            'type': 'CVIAbsoluteTime'
        },
        12594: {
            'access': 'read-write',
            'c_function_name': 'ArmStartTrigTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the timescale to be used for timestamps used in an arm start time trigger.',
            'enum': 'Timescale2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ARM_START_TRIG_TIMESCALE',
            'python_class_name': 'TimeArmStartTrigger',
            'python_data_type': 'Timescale2',
            'resettable': True,
            'type': 'int32'
        },
        12595: {
            'access': 'read-write',
            'c_function_name': 'ArmStartTrigTimestampEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether the arm start trigger timestamp is enabled. If the timestamp is enabled but no resources are available, an error will be returned at run time.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ARM_START_TRIG_TIMESTAMP_ENABLE',
            'python_class_name': 'ArmStartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12596: {
            'access': 'read',
            'c_function_name': 'ArmStartTrigTimestampVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.CVIAbsoluteTime',
            'description': 'Indicates the arm start trigger timestamp value.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ARM_START_TRIG_TIMESTAMP_VAL',
            'python_class_name': 'ArmStartTrigger',
            'python_data_type': 'unknown',
            'resettable': False,
            'type': 'CVIAbsoluteTime'
        },
        12597: {
            'access': 'read-write',
            'c_function_name': 'ArmStartTrigTimestampTimescale',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the arm start trigger timestamp timescale.',
            'enum': 'Timescale2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ARM_START_TRIG_TIMESTAMP_TIMESCALE',
            'python_class_name': 'ArmStartTrigger',
            'python_data_type': 'Timescale2',
            'resettable': True,
            'type': 'int32'
        },
        12618: {
            'access': 'read-write',
            'c_function_name': 'StartTrigTimestampEnable',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies whether the start trigger timestamp is enabled. If the timestamp is enabled but no resources are available, an error will be returned at run time.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_TIMESTAMP_ENABLE',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12619: {
            'access': 'read',
            'c_function_name': 'StartTrigTimestampVal',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.CVIAbsoluteTime',
            'description': 'Indicates the start trigger timestamp value.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'START_TRIG_TIMESTAMP_VAL',
            'python_class_name': 'StartTrigger',
            'python_data_type': 'unknown',
            'resettable': False,
            'type': 'CVIAbsoluteTime'
        }
    },
    'Watchdog': {
        8611: {
            'access': 'read-write',
            'c_function_name': 'WatchdogExpirTrigType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the type of trigger to use to expire a watchdog task.',
            'enum': 'TriggerType4',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'EXPIR_TRIG_TYPE',
            'python_class_name': 'WatchdogExpirationTrigger',
            'python_data_type': 'TriggerType4',
            'resettable': True,
            'type': 'int32'
        },
        8612: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeWatchdogExpirTrigSrc',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Specifies the name of a terminal where a digital signal exists to use as the source of the Expiration Trigger.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_WATCHDOG_EXPIR_TRIG_SRC',
            'python_class_name': 'DigitalEdgeWatchdogExpirationTrigger',
            'python_data_type': 'str',
            'resettable': True,
            'type': 'char[]'
        },
        8613: {
            'access': 'read-write',
            'c_function_name': 'DigEdgeWatchdogExpirTrigEdge',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies on which edge of a digital signal to expire the watchdog task.',
            'enum': 'Edge1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIG_EDGE_WATCHDOG_EXPIR_TRIG_EDGE',
            'python_class_name': 'DigitalEdgeWatchdogExpirationTrigger',
            'python_data_type': 'Edge1',
            'resettable': True,
            'type': 'int32'
        },
        8615: {
            'access': 'read-write',
            'c_function_name': 'WatchdogDOExpirState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the state to which to set the digital physical channels when the watchdog task expires.  You cannot modify the expiration state of dedicated digital input physical channels.',
            'enum': 'DigitalLineState',
            'handle_parameters': {
                'expirationStateHandle': {
                    'accessor': 'self._physical_channel',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'physicalChannel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DO_EXPIR_STATE',
            'python_class_name': 'Watchdog',
            'python_data_type': 'DigitalLineState',
            'resettable': True,
            'type': 'int32'
        },
        8616: {
            'access': 'read',
            'c_function_name': 'WatchdogHasExpired',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the watchdog timer expired. You can read this property only while the task is running.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'HAS_EXPIRED',
            'python_class_name': 'Watchdog',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        8617: {
            'access': 'read-write',
            'c_function_name': 'WatchdogTimeout',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the amount of time until the watchdog timer expires. A value of -1 means the internal timer never expires. Set this input to -1 if you use an Expiration Trigger to expire the watchdog task.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TIMEOUT',
            'python_class_name': 'Watchdog',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12381: {
            'access': 'read-write',
            'c_function_name': 'WatchdogExpirTrigTrigOnNetworkConnLoss',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies the watchdog timer behavior when the network connection is lost between the host and the chassis. If set to true, the watchdog timer expires when the chassis detects the loss of network connection.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'EXPIR_TRIG_TRIG_ON_NETWORK_CONN_LOSS',
            'python_class_name': 'WatchdogExpirationTrigger',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        12382: {
            'access': 'read-write',
            'c_function_name': 'WatchdogAOOutputType',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the output type of the analog output physical channels when the watchdog task expires.',
            'enum': 'WatchdogAOExpirState',
            'handle_parameters': {
                'expirationStateHandle': {
                    'accessor': 'self._physical_channel',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'physicalChannel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_OUTPUT_TYPE',
            'python_class_name': 'Watchdog',
            'python_data_type': 'WatchdogAOExpirState',
            'resettable': True,
            'type': 'int32'
        },
        12383: {
            'access': 'read-write',
            'c_function_name': 'WatchdogAOExpirState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies the state to set the analog output physical channels when the watchdog task expires.',
            'handle_parameters': {
                'expirationStateHandle': {
                    'accessor': 'self._physical_channel',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'physicalChannel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'AO_EXPIR_STATE',
            'python_class_name': 'Watchdog',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        12384: {
            'access': 'read-write',
            'c_function_name': 'WatchdogCOExpirState',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the state to set the counter output channel terminal when the watchdog task expires.',
            'enum': 'WatchdogCOExpirState',
            'handle_parameters': {
                'expirationStateHandle': {
                    'accessor': 'self._physical_channel',
                    'ctypes_data_type': 'ctypes.c_char_p',
                    'cvi_name': 'physicalChannel'
                },
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CO_EXPIR_STATE',
            'python_class_name': 'Watchdog',
            'python_data_type': 'WatchdogCOExpirState',
            'resettable': True,
            'type': 'int32'
        }
    },
    'Write': {
        5203: {
            'access': 'read-write',
            'c_function_name': 'WriteRegenMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies whether to allow NI-DAQmx to generate the same data multiple times.',
            'enum': 'RegenerationMode1',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'REGEN_MODE',
            'python_class_name': 'DaqStream',
            'python_data_type': 'RegenerationMode1',
            'resettable': True,
            'type': 'int32'
        },
        5208: {
            'access': 'read',
            'c_function_name': 'WriteCurrWritePos',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_ulonglong',
            'description': 'Indicates the position in the buffer of the next sample to generate. This value is identical for all channels in the task.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'CURR_WRITE_POS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'long',
            'resettable': False,
            'type': 'uInt64'
        },
        5216: {
            'access': 'read',
            'c_function_name': 'WriteSpaceAvail',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in samples per channel the amount of available space in the buffer.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SPACE_AVAIL',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        6412: {
            'access': 'read-write',
            'c_function_name': 'WriteRelativeTo',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies the point in the buffer at which to write data. If you also specify an offset with **offset**, the write operation begins at that offset relative to this point you select with this property.',
            'enum': 'WriteRelativeTo',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RELATIVE_TO',
            'python_class_name': 'DaqStream',
            'python_data_type': 'WriteRelativeTo',
            'resettable': True,
            'type': 'int32'
        },
        6413: {
            'access': 'read-write',
            'c_function_name': 'WriteOffset',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies in samples per channel an offset at which a write operation begins. This offset is relative to the location you specify with **relative_to**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OFFSET',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': True,
            'type': 'int32'
        },
        6443: {
            'access': 'read',
            'c_function_name': 'WriteTotalSampPerChanGenerated',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_ulonglong',
            'description': 'Indicates the total number of samples generated by each channel in the task. This value is identical for all channels in the task.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'TOTAL_SAMP_PER_CHAN_GENERATED',
            'python_class_name': 'DaqStream',
            'python_data_type': 'long',
            'resettable': False,
            'type': 'uInt64'
        },
        8573: {
            'access': 'read',
            'c_function_name': 'WriteRawDataWidth',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates in bytes the required size of a raw sample to write to the task.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'RAW_DATA_WIDTH',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8574: {
            'access': 'read',
            'c_function_name': 'WriteNumChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of channels that DAQmx Write writes to the task. This value is the number of channels in the task.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NUM_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8575: {
            'access': 'read',
            'c_function_name': 'WriteDigitalLinesBytesPerChan',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_uint',
            'description': 'Indicates the number of Boolean values expected per channel in a sample for line-based writes. This property is determined by the channel in the task with the most digital lines. If a channel has fewer lines than this number, NI-DAQmx ignores the extra Boolean values.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'DIGITAL_LINES_BYTES_PER_CHAN',
            'python_class_name': 'DaqStream',
            'python_data_type': 'int',
            'resettable': False,
            'type': 'uInt32'
        },
        8881: {
            'access': 'read-write',
            'c_function_name': 'WriteWaitMode',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_int',
            'description': 'Specifies how DAQmx Write waits for space to become available in the buffer.',
            'enum': 'WaitMode2',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'WAIT_MODE',
            'python_class_name': 'DaqStream',
            'python_data_type': 'WaitMode2',
            'resettable': True,
            'type': 'int32'
        },
        8882: {
            'access': 'read-write',
            'c_function_name': 'WriteSleepTime',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_double',
            'description': 'Specifies in seconds the amount of time to sleep after checking for available buffer space if **wait_mode** is **WaitMode2.SLEEP**.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SLEEP_TIME',
            'python_class_name': 'DaqStream',
            'python_data_type': 'float',
            'resettable': True,
            'type': 'float64'
        },
        10604: {
            'access': 'read-write',
            'c_function_name': 'WriteNextWriteIsLast',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Specifies that the next samples written are the last samples you want to generate. Use this property when performing continuous generation to prevent underflow errors after writing the last sample. **regen_mode** must be **RegenerationMode1.DONOTALLOWREGEN** to use this property.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'NEXT_WRITE_IS_LAST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': True,
            'type': 'bool32'
        },
        10728: {
            'access': 'read',
            'c_function_name': 'WriteOvercurrentChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an overcurrent condition for any channel in the task. Reading this property clears the overcurrent status for all channels in the task. You must read this property before you read **overcurrent_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OVERCURRENT_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10729: {
            'access': 'read',
            'c_function_name': 'WriteOvercurrentChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which an overcurrent condition has been detected. You must read **overcurrent_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OVERCURRENT_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        10730: {
            'access': 'read',
            'c_function_name': 'WriteOpenCurrentLoopChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an open current loop for any channel in the task. Reading this property clears the open current loop status for all channels in the task. You must read this property before you read **open_current_loop_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OPEN_CURRENT_LOOP_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10731: {
            'access': 'read',
            'c_function_name': 'WriteOpenCurrentLoopChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which the device(s) detected an open current loop. You must read **open_current_loop_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OPEN_CURRENT_LOOP_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        10732: {
            'access': 'read',
            'c_function_name': 'WritePowerSupplyFaultChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected a power supply fault for any channel in the task. Reading this property clears the power supply fault status for all channels in the task. You must read this property before you read **power_supply_fault_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'POWER_SUPPLY_FAULT_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        10733: {
            'access': 'read',
            'c_function_name': 'WritePowerSupplyFaultChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task that have a power supply fault. You must read **power_supply_fault_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'POWER_SUPPLY_FAULT_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        10884: {
            'access': 'read',
            'c_function_name': 'WriteOvertemperatureChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an overtemperature condition in any virtual channel in the task. Reading this property clears the overtemperature status for all channels in the task. You must read this property before you read **overtemperature_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OVERTEMPERATURE_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12371: {
            'access': 'read',
            'c_function_name': 'WriteAccessoryInsertionOrRemovalDetected',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if any devices in the task detected the insertion or removal of an accessory since the task started. Reading this property clears the accessory change status for all channels in the task. You must read this property before you read **devs_with_inserted_or_removed_accessories**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'ACCESSORY_INSERTION_OR_REMOVAL_DETECTED',
            'python_class_name': 'Task',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12372: {
            'access': 'read',
            'c_function_name': 'WriteDevsWithInsertedOrRemovedAccessories',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the names of any devices that detected the insertion or removal of an accessory since the task started. You must read **accessory_insertion_or_removal_detected** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'DEVS_WITH_INSERTED_OR_REMOVED_ACCESSORIES',
            'python_class_name': 'Task',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12419: {
            'access': 'read',
            'c_function_name': 'WriteOvertemperatureChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any overtemperature virtual channels. You must read **overtemperature_chans_exist** before you read this property. Otherwise, you will receive an error. The list of names may be empty if the device cannot determine the source of the overtemperature.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OVERTEMPERATURE_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12420: {
            'access': 'read',
            'c_function_name': 'WriteOverloadedChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an overload in any virtual channel in the task. Reading this property clears the overload status for all channels in the task. You must read this property before you read **overloaded_chans**. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'OVERLOADED_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12421: {
            'access': 'read',
            'c_function_name': 'WriteOverloadedChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any overloaded virtual channels in the task. You must read **overloaded_chans_exist** before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'OVERLOADED_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12475: {
            'access': 'read',
            'c_function_name': 'WriteExternalOvervoltageChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates if the device(s) detected an External Overvoltage condition for any channel in the task. Reading this property clears the External Overvoltage status for all channels in the task. You must read this property before you read External OvervoltageChans. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'EXTERNAL_OVERVOLTAGE_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12476: {
            'access': 'read',
            'c_function_name': 'WriteExternalOvervoltageChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates a list of names of any virtual channels in the task for which an External Overvoltage condition has been detected. You must read External OvervoltageChansExist before you read this property. Otherwise, you will receive an error.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'EXTERNAL_OVERVOLTAGE_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        },
        12607: {
            'access': 'read',
            'c_function_name': 'WriteSyncUnlockedChansExist',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'c_bool32',
            'description': 'Indicates whether the target is currently locked to the grand master. Devices may report PLL Unlock either during acquisition or after acquisition.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': False,
            'has_explicit_write_buffer_size': False,
            'is_list': False,
            'is_object': False,
            'name': 'SYNC_UNLOCKED_CHANS_EXIST',
            'python_class_name': 'DaqStream',
            'python_data_type': 'bool',
            'resettable': False,
            'type': 'bool32'
        },
        12608: {
            'access': 'read',
            'c_function_name': 'WriteSyncUnlockedChans',
            'calling_convention': 'StdCall',
            'ctypes_data_type': 'ctypes.c_char_p',
            'description': 'Indicates the channels from devices in an unlocked target.',
            'handle_parameters': {
                'taskHandle': {
                    'accessor': 'self._handle',
                    'ctypes_data_type': 'lib_importer.task_handle',
                    'cvi_name': 'taskHandle'
                }
            },
            'has_explicit_read_buffer_size': True,
            'has_explicit_write_buffer_size': True,
            'is_list': True,
            'is_object': False,
            'name': 'SYNC_UNLOCKED_CHANS',
            'python_class_name': 'DaqStream',
            'python_data_type': 'str',
            'resettable': False,
            'type': 'char[]'
        }
    }
}
