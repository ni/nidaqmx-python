<%
    from codegen.utilities.interpreter_helpers import (
        get_interpreter_functions,
        get_interpreter_parameter_signature,
        get_params_for_function_signature,
        INCLUDE_SIZE_HINT_FUNCTIONS
    )
    from codegen.utilities.function_helpers import order_function_parameters_by_optional
    from codegen.utilities.text_wrappers import wrap, docstring_wrap
    functions = get_interpreter_functions(data)
%>\
# Do not edit this file; it was automatically generated.
from __future__ import annotations

import abc
import numpy
from nitypes.waveform import AnalogWaveform, DigitalWaveform
from typing import Any, Sequence
from nidaqmx.constants import WaveformAttributeMode


class BaseEventHandler(abc.ABC):
    """Interpreter-specific object that is returned from register_*_event()."""
    __slots__ = ()

    @abc.abstractmethod
    def close(self) -> None:
        """Release resources used by the event handler.

        After releasing the resources, this method may report handler-specific errors
        (e.g. gRPC stream errors) by raising an exception.
        """
        raise NotImplementedError


class BaseInterpreter(abc.ABC):
    """
    Contains signature of functions for all DAQmx APIs.
    """
    __slots__ = ()

% for func in functions:
<%
    params = get_params_for_function_signature(func)
    sorted_params = order_function_parameters_by_optional(params)
    parameter_signature = get_interpreter_parameter_signature(is_python_factory, sorted_params)
    if func.function_name in INCLUDE_SIZE_HINT_FUNCTIONS:
        parameter_signature = ", ".join([parameter_signature, "size_hint=0"])
%>\
    @abc.abstractmethod
%if (len(func.function_name) + len(parameter_signature)) > 68:
    def ${func.function_name}(
            ${parameter_signature + '):' | wrap(12, 12)}
%else:
    def ${func.function_name}(${parameter_signature}):
%endif
        raise NotImplementedError

% endfor
    @abc.abstractmethod
    def hash_task_handle(self, task_handle):
        raise NotImplementedError

    @abc.abstractmethod
    def read_analog_waveform(
        self,
        task_handle: object,
        number_of_samples_per_channel: int,
        timeout: float,
        waveform: AnalogWaveform[numpy.float64],
        waveform_attribute_mode: WaveformAttributeMode
    ) -> int:
        raise NotImplementedError

    @abc.abstractmethod
    def read_analog_waveforms(
        self,
        task_handle: object,
        number_of_samples_per_channel: int,
        timeout: float,
        waveforms: Sequence[AnalogWaveform[numpy.float64]],
        waveform_attribute_mode: WaveformAttributeMode
    ) -> int:
        raise NotImplementedError
        
    @abc.abstractmethod
    def read_digital_waveform(
        self,
        task_handle: object,
        number_of_samples_per_channel: int,
        timeout: float,
        waveform: DigitalWaveform[Any],
        waveform_attribute_mode: WaveformAttributeMode
    ) -> int:
        raise NotImplementedError

    @abc.abstractmethod
    def read_digital_waveforms(
        self,
        task_handle: object,
        channel_count: int,
        number_of_samples_per_channel: int,
        number_of_signals_per_sample: int,
        timeout: float,
        waveforms: Sequence[DigitalWaveform[Any]],
        waveform_attribute_mode: WaveformAttributeMode,
    ) -> int:
        raise NotImplementedError

    @abc.abstractmethod
    def read_new_digital_waveforms(
        self,
        task_handle: object,
        channel_count: int,
        number_of_samples_per_channel: int,
        number_of_signals_per_sample: int,
        timeout: float,
        waveform_attribute_mode: WaveformAttributeMode,
    ) -> Sequence[DigitalWaveform[numpy.uint8]]:
        raise NotImplementedError

    @abc.abstractmethod
    def write_analog_waveform(
        self,
        task_handle: object,
        waveform: AnalogWaveform[Any],
        auto_start: bool,
        timeout: float
    ) -> int:
        raise NotImplementedError

    @abc.abstractmethod
    def write_analog_waveforms(
        self,
        task_handle: object,
        waveforms: Sequence[AnalogWaveform[Any]],
        auto_start: bool,
        timeout: float
    ) -> int:
        raise NotImplementedError
        
    @abc.abstractmethod
    def write_digital_waveform(
        self,
        task_handle: object,
        waveform: DigitalWaveform[Any],
        auto_start: bool,
        timeout: float,
    ) -> int:
        raise NotImplementedError
        
    def write_digital_waveforms(
        self,
        task_handle: object,
        waveform: Sequence[DigitalWaveform[Any]],
        auto_start: bool,
        timeout: float,
    ) -> int:
        raise NotImplementedError
