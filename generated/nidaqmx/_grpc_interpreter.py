# Do not edit this file; it was automatically generated.

import grpc
import threading
import warnings

from . import errors as errors
from nidaqmx._base_interpreter import BaseInterpreter
from nidaqmx._stubs import nidaqmx_pb2 as grpc_types
from nidaqmx._stubs import nidaqmx_pb2_grpc as nidaqmx_grpc
from nidaqmx._stubs import session_pb2 as session_grpc_types



class GrpcStubInterpreter(BaseInterpreter):
    '''Interpreter for interacting with a gRPC Stub class'''

    def __init__(self, grpc_options):
        self._grpc_options = grpc_options
        self._lock = threading.RLock()
        self._client = nidaqmx_grpc.NiDAQmxStub(grpc_options.grpc_channel)

    def _invoke(self, func, request, metadata=None):
        try:
            response = func(request, metadata=metadata)
            error_code = response.status
            error_message = ''
        #Todo: AB 2325876: The error handling logic will be updated.
        except grpc.RpcError as rpc_error:
            raise rpc_error
        return response

    def add_cdaq_sync_connection(self, port_list):
        response = self._invoke(
            self._client.AddCDAQSyncConnection,
            grpc_types.AddCDAQSyncConnectionRequest(self, port_list),
        )

    def add_global_chans_to_task(self, task, channel_names):
        response = self._invoke(
            self._client.AddGlobalChansToTask,
            grpc_types.AddGlobalChansToTaskRequest(self, task, channel_names),
        )

    def add_network_device(
            self, ip_address, device_name_out, device_name,
            attempt_reservation, timeout):
        response = self._invoke(
            self._client.AddNetworkDevice,
            grpc_types.AddNetworkDeviceRequest(self, ip_address, device_name_out, device_name, attempt_reservation, timeout),
        )
        return response.device_name_out

    def are_configured_cdaq_sync_ports_disconnected(
            self, disconnected_ports_exist, chassis_devices_ports, timeout):
        response = self._invoke(
            self._client.AreConfiguredCDAQSyncPortsDisconnected,
            grpc_types.AreConfiguredCDAQSyncPortsDisconnectedRequest(self, disconnected_ports_exist, chassis_devices_ports, timeout),
        )
        return response.disconnected_ports_exist

    def auto_configure_cdaq_sync_connections(
            self, chassis_devices_ports, timeout):
        response = self._invoke(
            self._client.AutoConfigureCDAQSyncConnections,
            grpc_types.AutoConfigureCDAQSyncConnectionsRequest(self, chassis_devices_ports, timeout),
        )

    def calculate_reverse_poly_coeff(
            self, forward_coeffs, num_forward_coeffs_in, reverse_coeffs,
            min_val_x, max_val_x, num_points_to_compute, reverse_poly_order):
        response = self._invoke(
            self._client.CalculateReversePolyCoeff,
            grpc_types.CalculateReversePolyCoeffRequest(self, forward_coeffs, num_forward_coeffs_in, reverse_coeffs, min_val_x, max_val_x, num_points_to_compute, reverse_poly_order),
        )
        return response.reverse_coeffs

    def cfg_anlg_edge_ref_trig(
            self, task, trigger_source, pretrigger_samples, trigger_slope,
            trigger_level):
        response = self._invoke(
            self._client.CfgAnlgEdgeRefTrig,
            grpc_types.CfgAnlgEdgeRefTrigRequest(self, task, trigger_source, pretrigger_samples, trigger_slope, trigger_level),
        )

    def cfg_anlg_edge_start_trig(
            self, task, trigger_source, trigger_slope, trigger_level):
        response = self._invoke(
            self._client.CfgAnlgEdgeStartTrig,
            grpc_types.CfgAnlgEdgeStartTrigRequest(self, task, trigger_source, trigger_slope, trigger_level),
        )

    def cfg_anlg_window_ref_trig(
            self, task, trigger_source, window_top, window_bottom,
            pretrigger_samples, trigger_when):
        response = self._invoke(
            self._client.CfgAnlgWindowRefTrig,
            grpc_types.CfgAnlgWindowRefTrigRequest(self, task, trigger_source, window_top, window_bottom, pretrigger_samples, trigger_when),
        )

    def cfg_anlg_window_start_trig(
            self, task, window_top, window_bottom, trigger_source,
            trigger_when):
        response = self._invoke(
            self._client.CfgAnlgWindowStartTrig,
            grpc_types.CfgAnlgWindowStartTrigRequest(self, task, window_top, window_bottom, trigger_source, trigger_when),
        )

    def cfg_burst_handshaking_timing_export_clock(
            self, task, sample_clk_rate, sample_clk_outp_term, sample_mode,
            samps_per_chan, sample_clk_pulse_polarity, pause_when,
            ready_event_active_level):
        response = self._invoke(
            self._client.CfgBurstHandshakingTimingExportClock,
            grpc_types.CfgBurstHandshakingTimingExportClockRequest(self, task, sample_clk_rate, sample_clk_outp_term, sample_mode, samps_per_chan, sample_clk_pulse_polarity, pause_when, ready_event_active_level),
        )

    def cfg_burst_handshaking_timing_import_clock(
            self, task, sample_clk_rate, sample_clk_src, sample_mode,
            samps_per_chan, sample_clk_active_edge, pause_when,
            ready_event_active_level):
        response = self._invoke(
            self._client.CfgBurstHandshakingTimingImportClock,
            grpc_types.CfgBurstHandshakingTimingImportClockRequest(self, task, sample_clk_rate, sample_clk_src, sample_mode, samps_per_chan, sample_clk_active_edge, pause_when, ready_event_active_level),
        )

    def cfg_change_detection_timing(
            self, task, rising_edge_chan, falling_edge_chan, sample_mode,
            samps_per_chan):
        response = self._invoke(
            self._client.CfgChangeDetectionTiming,
            grpc_types.CfgChangeDetectionTimingRequest(self, task, rising_edge_chan, falling_edge_chan, sample_mode, samps_per_chan),
        )

    def cfg_dig_edge_ref_trig(
            self, task, trigger_source, pretrigger_samples, trigger_edge):
        response = self._invoke(
            self._client.CfgDigEdgeRefTrig,
            grpc_types.CfgDigEdgeRefTrigRequest(self, task, trigger_source, pretrigger_samples, trigger_edge),
        )

    def cfg_dig_edge_start_trig(self, task, trigger_source, trigger_edge):
        response = self._invoke(
            self._client.CfgDigEdgeStartTrig,
            grpc_types.CfgDigEdgeStartTrigRequest(self, task, trigger_source, trigger_edge),
        )

    def cfg_dig_pattern_ref_trig(
            self, task, trigger_source, trigger_pattern, pretrigger_samples,
            trigger_when):
        response = self._invoke(
            self._client.CfgDigPatternRefTrig,
            grpc_types.CfgDigPatternRefTrigRequest(self, task, trigger_source, trigger_pattern, pretrigger_samples, trigger_when),
        )

    def cfg_dig_pattern_start_trig(
            self, task, trigger_source, trigger_pattern, trigger_when):
        response = self._invoke(
            self._client.CfgDigPatternStartTrig,
            grpc_types.CfgDigPatternStartTrigRequest(self, task, trigger_source, trigger_pattern, trigger_when),
        )

    def cfg_handshaking_timing(self, task, sample_mode, samps_per_chan):
        response = self._invoke(
            self._client.CfgHandshakingTiming,
            grpc_types.CfgHandshakingTimingRequest(self, task, sample_mode, samps_per_chan),
        )

    def cfg_implicit_timing(self, task, sample_mode, samps_per_chan):
        response = self._invoke(
            self._client.CfgImplicitTiming,
            grpc_types.CfgImplicitTimingRequest(self, task, sample_mode, samps_per_chan),
        )

    def cfg_pipelined_samp_clk_timing(
            self, task, rate, source, active_edge, sample_mode,
            samps_per_chan):
        response = self._invoke(
            self._client.CfgPipelinedSampClkTiming,
            grpc_types.CfgPipelinedSampClkTimingRequest(self, task, rate, source, active_edge, sample_mode, samps_per_chan),
        )

    def cfg_samp_clk_timing(
            self, task, rate, source, active_edge, sample_mode,
            samps_per_chan):
        response = self._invoke(
            self._client.CfgSampClkTiming,
            grpc_types.CfgSampClkTimingRequest(self, task, rate, source, active_edge, sample_mode, samps_per_chan),
        )

    def cfg_watchdog_ao_expir_states(
            self, task, channel_names, expir_state_array, output_type_array,
            array_size):
        response = self._invoke(
            self._client.CfgWatchdogAOExpirStates,
            grpc_types.CfgWatchdogAOExpirStatesRequest(self, task, channel_names, expir_state_array, output_type_array, array_size),
        )

    def cfg_watchdog_co_expir_states(
            self, task, channel_names, expir_state_array, array_size):
        response = self._invoke(
            self._client.CfgWatchdogCOExpirStates,
            grpc_types.CfgWatchdogCOExpirStatesRequest(self, task, channel_names, expir_state_array, array_size),
        )

    def cfg_watchdog_do_expir_states(
            self, task, channel_names, expir_state_array, array_size):
        response = self._invoke(
            self._client.CfgWatchdogDOExpirStates,
            grpc_types.CfgWatchdogDOExpirStatesRequest(self, task, channel_names, expir_state_array, array_size),
        )

    def clear_task(self, task):
        response = self._invoke(
            self._client.ClearTask,
            grpc_types.ClearTaskRequest(self, task),
        )

    def clear_teds(self, physical_channel):
        response = self._invoke(
            self._client.ClearTEDS,
            grpc_types.ClearTEDSRequest(self, physical_channel),
        )

    def configure_logging(
            self, task, file_path, logging_mode, group_name, operation):
        response = self._invoke(
            self._client.ConfigureLogging,
            grpc_types.ConfigureLoggingRequest(self, task, file_path, logging_mode, group_name, operation),
        )

    def configure_teds(self, physical_channel, file_path):
        response = self._invoke(
            self._client.ConfigureTEDS,
            grpc_types.ConfigureTEDSRequest(self, physical_channel, file_path),
        )

    def connect_terms(
            self, source_terminal, destination_terminal, signal_modifiers):
        response = self._invoke(
            self._client.ConnectTerms,
            grpc_types.ConnectTermsRequest(self, source_terminal, destination_terminal, signal_modifiers),
        )

    def control_watchdog_task(self, task, action):
        response = self._invoke(
            self._client.ControlWatchdogTask,
            grpc_types.ControlWatchdogTaskRequest(self, task, action),
        )

    def create_ai_accel4_wire_dc_voltage_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, sensitivity,
            sensitivity_units, voltage_excit_source, voltage_excit_val,
            use_excit_for_scaling, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIAccel4WireDCVoltageChan,
            grpc_types.CreateAIAccel4WireDCVoltageChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, use_excit_for_scaling, custom_scale_name),
        )

    def create_ai_accel_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, sensitivity,
            sensitivity_units, current_excit_source, current_excit_val,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateAIAccelChan,
            grpc_types.CreateAIAccelChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name),
        )

    def create_ai_accel_charge_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, sensitivity,
            sensitivity_units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIAccelChargeChan,
            grpc_types.CreateAIAccelChargeChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, custom_scale_name),
        )

    def create_ai_bridge_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, bridge_config, voltage_excit_source,
            voltage_excit_val, nominal_bridge_resistance, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIBridgeChan,
            grpc_types.CreateAIBridgeChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, custom_scale_name),
        )

    def create_ai_charge_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIChargeChan,
            grpc_types.CreateAIChargeChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name),
        )

    def create_ai_current_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, shunt_resistor_loc,
            ext_shunt_resistor_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateAICurrentChan,
            grpc_types.CreateAICurrentChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name),
        )

    def create_ai_current_rms_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, shunt_resistor_loc,
            ext_shunt_resistor_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateAICurrentRMSChan,
            grpc_types.CreateAICurrentRMSChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name),
        )

    def create_ai_force_bridge_polynomial_chan(
            self, task, physical_channel, num_forward_coeffs,
            num_reverse_coeffs, name_to_assign_to_channel, min_val, max_val,
            units, bridge_config, voltage_excit_source, voltage_excit_val,
            nominal_bridge_resistance, forward_coeffs, reverse_coeffs,
            electrical_units, physical_units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIForceBridgePolynomialChan,
            grpc_types.CreateAIForceBridgePolynomialChanRequest(self, task, physical_channel, num_forward_coeffs, num_reverse_coeffs, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, reverse_coeffs, electrical_units, physical_units, custom_scale_name),
        )

    def create_ai_force_bridge_table_chan(
            self, task, physical_channel, num_electrical_vals,
            num_physical_vals, name_to_assign_to_channel, min_val, max_val,
            units, bridge_config, voltage_excit_source, voltage_excit_val,
            nominal_bridge_resistance, electrical_vals, electrical_units,
            physical_vals, physical_units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIForceBridgeTableChan,
            grpc_types.CreateAIForceBridgeTableChanRequest(self, task, physical_channel, num_electrical_vals, num_physical_vals, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, electrical_units, physical_vals, physical_units, custom_scale_name),
        )

    def create_ai_force_bridge_two_point_lin_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, bridge_config, voltage_excit_source,
            voltage_excit_val, nominal_bridge_resistance,
            first_electrical_val, second_electrical_val, electrical_units,
            first_physical_val, second_physical_val, physical_units,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateAIForceBridgeTwoPointLinChan,
            grpc_types.CreateAIForceBridgeTwoPointLinChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name),
        )

    def create_ai_force_iepe_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, sensitivity,
            sensitivity_units, current_excit_source, current_excit_val,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateAIForceIEPEChan,
            grpc_types.CreateAIForceIEPEChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name),
        )

    def create_ai_freq_voltage_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, threshold_level, hysteresis, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIFreqVoltageChan,
            grpc_types.CreateAIFreqVoltageChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, threshold_level, hysteresis, custom_scale_name),
        )

    def create_ai_microphone_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, units, mic_sensitivity, max_snd_press_level,
            current_excit_source, current_excit_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIMicrophoneChan,
            grpc_types.CreateAIMicrophoneChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, units, mic_sensitivity, max_snd_press_level, current_excit_source, current_excit_val, custom_scale_name),
        )

    def create_ai_pos_eddy_curr_prox_probe_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, sensitivity, sensitivity_units,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateAIPosEddyCurrProxProbeChan,
            grpc_types.CreateAIPosEddyCurrProxProbeChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, custom_scale_name),
        )

    def create_ai_pos_lvdt_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, sensitivity, sensitivity_units,
            voltage_excit_source, voltage_excit_val, voltage_excit_freq,
            ac_excit_wire_mode, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIPosLVDTChan,
            grpc_types.CreateAIPosLVDTChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name),
        )

    def create_ai_pos_rvdt_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, sensitivity, sensitivity_units,
            voltage_excit_source, voltage_excit_val, voltage_excit_freq,
            ac_excit_wire_mode, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIPosRVDTChan,
            grpc_types.CreateAIPosRVDTChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, sensitivity, sensitivity_units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name),
        )

    def create_ai_power_chan(
            self, task, physical_channel, voltage_setpoint, current_setpoint,
            output_enable, name_to_assign_to_channel):
        response = self._invoke(
            self._client.CreateAIPowerChan,
            grpc_types.CreateAIPowerChanRequest(self, task, physical_channel, voltage_setpoint, current_setpoint, output_enable, name_to_assign_to_channel),
        )

    def create_ai_pressure_bridge_polynomial_chan(
            self, task, physical_channel, num_forward_coeffs,
            num_reverse_coeffs, name_to_assign_to_channel, min_val, max_val,
            units, bridge_config, voltage_excit_source, voltage_excit_val,
            nominal_bridge_resistance, forward_coeffs, reverse_coeffs,
            electrical_units, physical_units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIPressureBridgePolynomialChan,
            grpc_types.CreateAIPressureBridgePolynomialChanRequest(self, task, physical_channel, num_forward_coeffs, num_reverse_coeffs, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, reverse_coeffs, electrical_units, physical_units, custom_scale_name),
        )

    def create_ai_pressure_bridge_table_chan(
            self, task, physical_channel, num_electrical_vals,
            num_physical_vals, name_to_assign_to_channel, min_val, max_val,
            units, bridge_config, voltage_excit_source, voltage_excit_val,
            nominal_bridge_resistance, electrical_vals, electrical_units,
            physical_vals, physical_units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIPressureBridgeTableChan,
            grpc_types.CreateAIPressureBridgeTableChanRequest(self, task, physical_channel, num_electrical_vals, num_physical_vals, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, electrical_units, physical_vals, physical_units, custom_scale_name),
        )

    def create_ai_pressure_bridge_two_point_lin_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, bridge_config, voltage_excit_source,
            voltage_excit_val, nominal_bridge_resistance,
            first_electrical_val, second_electrical_val, electrical_units,
            first_physical_val, second_physical_val, physical_units,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateAIPressureBridgeTwoPointLinChan,
            grpc_types.CreateAIPressureBridgeTwoPointLinChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name),
        )

    def create_ai_resistance_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, resistance_config, current_excit_source,
            current_excit_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIResistanceChan,
            grpc_types.CreateAIResistanceChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, custom_scale_name),
        )

    def create_ai_rosette_strain_gage_chan(
            self, task, physical_channel, rosette_type, gage_orientation,
            rosette_meas_types, num_rosette_meas_types,
            name_to_assign_to_channel, min_val, max_val, strain_config,
            voltage_excit_source, voltage_excit_val, gage_factor,
            nominal_gage_resistance, poisson_ratio, lead_wire_resistance):
        response = self._invoke(
            self._client.CreateAIRosetteStrainGageChan,
            grpc_types.CreateAIRosetteStrainGageChanRequest(self, task, physical_channel, rosette_type, gage_orientation, rosette_meas_types, num_rosette_meas_types, name_to_assign_to_channel, min_val, max_val, strain_config, voltage_excit_source, voltage_excit_val, gage_factor, nominal_gage_resistance, poisson_ratio, lead_wire_resistance),
        )

    def create_ai_strain_gage_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, strain_config, voltage_excit_source,
            voltage_excit_val, gage_factor, initial_bridge_voltage,
            nominal_gage_resistance, poisson_ratio, lead_wire_resistance,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateAIStrainGageChan,
            grpc_types.CreateAIStrainGageChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, strain_config, voltage_excit_source, voltage_excit_val, gage_factor, initial_bridge_voltage, nominal_gage_resistance, poisson_ratio, lead_wire_resistance, custom_scale_name),
        )

    def create_ai_temp_built_in_sensor_chan(
            self, task, physical_channel, name_to_assign_to_channel, units):
        response = self._invoke(
            self._client.CreateAITempBuiltInSensorChan,
            grpc_types.CreateAITempBuiltInSensorChanRequest(self, task, physical_channel, name_to_assign_to_channel, units),
        )

    def create_ai_thrmcpl_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, thermocouple_type, cjc_source, cjc_val,
            cjc_channel):
        response = self._invoke(
            self._client.CreateAIThrmcplChan,
            grpc_types.CreateAIThrmcplChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, thermocouple_type, cjc_source, cjc_val, cjc_channel),
        )

    def create_ai_thrmstr_chan_iex(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, resistance_config, current_excit_source,
            current_excit_val, a, b, c):
        response = self._invoke(
            self._client.CreateAIThrmstrChanIex,
            grpc_types.CreateAIThrmstrChanIexRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, a, b, c),
        )

    def create_ai_thrmstr_chan_vex(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, resistance_config, voltage_excit_source,
            voltage_excit_val, a, b, c, r_1):
        response = self._invoke(
            self._client.CreateAIThrmstrChanVex,
            grpc_types.CreateAIThrmstrChanVexRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, voltage_excit_source, voltage_excit_val, a, b, c, r_1),
        )

    def create_ai_torque_bridge_polynomial_chan(
            self, task, physical_channel, num_forward_coeffs,
            num_reverse_coeffs, name_to_assign_to_channel, min_val, max_val,
            units, bridge_config, voltage_excit_source, voltage_excit_val,
            nominal_bridge_resistance, forward_coeffs, reverse_coeffs,
            electrical_units, physical_units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAITorqueBridgePolynomialChan,
            grpc_types.CreateAITorqueBridgePolynomialChanRequest(self, task, physical_channel, num_forward_coeffs, num_reverse_coeffs, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, forward_coeffs, reverse_coeffs, electrical_units, physical_units, custom_scale_name),
        )

    def create_ai_torque_bridge_table_chan(
            self, task, physical_channel, num_electrical_vals,
            num_physical_vals, name_to_assign_to_channel, min_val, max_val,
            units, bridge_config, voltage_excit_source, voltage_excit_val,
            nominal_bridge_resistance, electrical_vals, electrical_units,
            physical_vals, physical_units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAITorqueBridgeTableChan,
            grpc_types.CreateAITorqueBridgeTableChanRequest(self, task, physical_channel, num_electrical_vals, num_physical_vals, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, electrical_vals, electrical_units, physical_vals, physical_units, custom_scale_name),
        )

    def create_ai_torque_bridge_two_point_lin_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, bridge_config, voltage_excit_source,
            voltage_excit_val, nominal_bridge_resistance,
            first_electrical_val, second_electrical_val, electrical_units,
            first_physical_val, second_physical_val, physical_units,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateAITorqueBridgeTwoPointLinChan,
            grpc_types.CreateAITorqueBridgeTwoPointLinChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, nominal_bridge_resistance, first_electrical_val, second_electrical_val, electrical_units, first_physical_val, second_physical_val, physical_units, custom_scale_name),
        )

    def create_ai_velocity_iepe_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, sensitivity,
            sensitivity_units, current_excit_source, current_excit_val,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateAIVelocityIEPEChan,
            grpc_types.CreateAIVelocityIEPEChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, sensitivity, sensitivity_units, current_excit_source, current_excit_val, custom_scale_name),
        )

    def create_ai_voltage_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIVoltageChan,
            grpc_types.CreateAIVoltageChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name),
        )

    def create_ai_voltage_chan_with_excit(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, bridge_config,
            voltage_excit_source, voltage_excit_val, use_excit_for_scaling,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateAIVoltageChanWithExcit,
            grpc_types.CreateAIVoltageChanWithExcitRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, bridge_config, voltage_excit_source, voltage_excit_val, use_excit_for_scaling, custom_scale_name),
        )

    def create_ai_voltage_rms_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAIVoltageRMSChan,
            grpc_types.CreateAIVoltageRMSChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name),
        )

    def create_airtd_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, rtd_type, resistance_config, current_excit_source,
            current_excit_val, r_0):
        response = self._invoke(
            self._client.CreateAIRTDChan,
            grpc_types.CreateAIRTDChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, rtd_type, resistance_config, current_excit_source, current_excit_val, r_0),
        )

    def create_ao_current_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAOCurrentChan,
            grpc_types.CreateAOCurrentChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name),
        )

    def create_ao_func_gen_chan(
            self, task, physical_channel, name_to_assign_to_channel, type,
            freq, amplitude, offset):
        response = self._invoke(
            self._client.CreateAOFuncGenChan,
            grpc_types.CreateAOFuncGenChanRequest(self, task, physical_channel, name_to_assign_to_channel, type, freq, amplitude, offset),
        )

    def create_ao_voltage_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, custom_scale_name):
        response = self._invoke(
            self._client.CreateAOVoltageChan,
            grpc_types.CreateAOVoltageChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name),
        )

    def create_ci_ang_encoder_chan(
            self, task, counter, name_to_assign_to_channel, decoding_type,
            zidx_enable, zidx_val, zidx_phase, units, pulses_per_rev,
            initial_angle, custom_scale_name):
        response = self._invoke(
            self._client.CreateCIAngEncoderChan,
            grpc_types.CreateCIAngEncoderChanRequest(self, task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, pulses_per_rev, initial_angle, custom_scale_name),
        )

    def create_ci_ang_velocity_chan(
            self, task, counter, name_to_assign_to_channel, min_val, max_val,
            decoding_type, units, pulses_per_rev, custom_scale_name):
        response = self._invoke(
            self._client.CreateCIAngVelocityChan,
            grpc_types.CreateCIAngVelocityChanRequest(self, task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, pulses_per_rev, custom_scale_name),
        )

    def create_ci_count_edges_chan(
            self, task, counter, name_to_assign_to_channel, edge,
            initial_count, count_direction):
        response = self._invoke(
            self._client.CreateCICountEdgesChan,
            grpc_types.CreateCICountEdgesChanRequest(self, task, counter, name_to_assign_to_channel, edge, initial_count, count_direction),
        )

    def create_ci_duty_cycle_chan(
            self, task, counter, name_to_assign_to_channel, min_freq,
            max_freq, edge, custom_scale_name):
        response = self._invoke(
            self._client.CreateCIDutyCycleChan,
            grpc_types.CreateCIDutyCycleChanRequest(self, task, counter, name_to_assign_to_channel, min_freq, max_freq, edge, custom_scale_name),
        )

    def create_ci_freq_chan(
            self, task, counter, name_to_assign_to_channel, min_val, max_val,
            units, edge, meas_method, meas_time, divisor, custom_scale_name):
        response = self._invoke(
            self._client.CreateCIFreqChan,
            grpc_types.CreateCIFreqChanRequest(self, task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name),
        )

    def create_ci_lin_encoder_chan(
            self, task, counter, name_to_assign_to_channel, decoding_type,
            zidx_enable, zidx_val, zidx_phase, units, dist_per_pulse,
            initial_pos, custom_scale_name):
        response = self._invoke(
            self._client.CreateCILinEncoderChan,
            grpc_types.CreateCILinEncoderChanRequest(self, task, counter, name_to_assign_to_channel, decoding_type, zidx_enable, zidx_val, zidx_phase, units, dist_per_pulse, initial_pos, custom_scale_name),
        )

    def create_ci_lin_velocity_chan(
            self, task, counter, name_to_assign_to_channel, min_val, max_val,
            decoding_type, units, dist_per_pulse, custom_scale_name):
        response = self._invoke(
            self._client.CreateCILinVelocityChan,
            grpc_types.CreateCILinVelocityChanRequest(self, task, counter, name_to_assign_to_channel, min_val, max_val, decoding_type, units, dist_per_pulse, custom_scale_name),
        )

    def create_ci_period_chan(
            self, task, counter, name_to_assign_to_channel, min_val, max_val,
            units, edge, meas_method, meas_time, divisor, custom_scale_name):
        response = self._invoke(
            self._client.CreateCIPeriodChan,
            grpc_types.CreateCIPeriodChanRequest(self, task, counter, name_to_assign_to_channel, min_val, max_val, units, edge, meas_method, meas_time, divisor, custom_scale_name),
        )

    def create_ci_pulse_chan_freq(
            self, task, counter, name_to_assign_to_channel, min_val, max_val,
            units):
        response = self._invoke(
            self._client.CreateCIPulseChanFreq,
            grpc_types.CreateCIPulseChanFreqRequest(self, task, counter, name_to_assign_to_channel, min_val, max_val, units),
        )

    def create_ci_pulse_chan_ticks(
            self, task, counter, name_to_assign_to_channel, source_terminal,
            min_val, max_val):
        response = self._invoke(
            self._client.CreateCIPulseChanTicks,
            grpc_types.CreateCIPulseChanTicksRequest(self, task, counter, name_to_assign_to_channel, source_terminal, min_val, max_val),
        )

    def create_ci_pulse_chan_time(
            self, task, counter, name_to_assign_to_channel, min_val, max_val,
            units):
        response = self._invoke(
            self._client.CreateCIPulseChanTime,
            grpc_types.CreateCIPulseChanTimeRequest(self, task, counter, name_to_assign_to_channel, min_val, max_val, units),
        )

    def create_ci_pulse_width_chan(
            self, task, counter, name_to_assign_to_channel, min_val, max_val,
            units, starting_edge, custom_scale_name):
        response = self._invoke(
            self._client.CreateCIPulseWidthChan,
            grpc_types.CreateCIPulseWidthChanRequest(self, task, counter, name_to_assign_to_channel, min_val, max_val, units, starting_edge, custom_scale_name),
        )

    def create_ci_semi_period_chan(
            self, task, counter, name_to_assign_to_channel, min_val, max_val,
            units, custom_scale_name):
        response = self._invoke(
            self._client.CreateCISemiPeriodChan,
            grpc_types.CreateCISemiPeriodChanRequest(self, task, counter, name_to_assign_to_channel, min_val, max_val, units, custom_scale_name),
        )

    def create_ci_two_edge_sep_chan(
            self, task, counter, name_to_assign_to_channel, min_val, max_val,
            units, first_edge, second_edge, custom_scale_name):
        response = self._invoke(
            self._client.CreateCITwoEdgeSepChan,
            grpc_types.CreateCITwoEdgeSepChanRequest(self, task, counter, name_to_assign_to_channel, min_val, max_val, units, first_edge, second_edge, custom_scale_name),
        )

    def create_cigps_timestamp_chan(
            self, task, counter, name_to_assign_to_channel, units,
            sync_method, custom_scale_name):
        response = self._invoke(
            self._client.CreateCIGPSTimestampChan,
            grpc_types.CreateCIGPSTimestampChanRequest(self, task, counter, name_to_assign_to_channel, units, sync_method, custom_scale_name),
        )

    def create_co_pulse_chan_freq(
            self, task, counter, name_to_assign_to_channel, units, idle_state,
            initial_delay, freq, duty_cycle):
        response = self._invoke(
            self._client.CreateCOPulseChanFreq,
            grpc_types.CreateCOPulseChanFreqRequest(self, task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, freq, duty_cycle),
        )

    def create_co_pulse_chan_ticks(
            self, task, counter, source_terminal, name_to_assign_to_channel,
            idle_state, initial_delay, low_ticks, high_ticks):
        response = self._invoke(
            self._client.CreateCOPulseChanTicks,
            grpc_types.CreateCOPulseChanTicksRequest(self, task, counter, source_terminal, name_to_assign_to_channel, idle_state, initial_delay, low_ticks, high_ticks),
        )

    def create_co_pulse_chan_time(
            self, task, counter, name_to_assign_to_channel, units, idle_state,
            initial_delay, low_time, high_time):
        response = self._invoke(
            self._client.CreateCOPulseChanTime,
            grpc_types.CreateCOPulseChanTimeRequest(self, task, counter, name_to_assign_to_channel, units, idle_state, initial_delay, low_time, high_time),
        )

    def create_di_chan(
            self, task, lines, name_to_assign_to_lines, line_grouping):
        response = self._invoke(
            self._client.CreateDIChan,
            grpc_types.CreateDIChanRequest(self, task, lines, name_to_assign_to_lines, line_grouping),
        )

    def create_do_chan(
            self, task, lines, name_to_assign_to_lines, line_grouping):
        response = self._invoke(
            self._client.CreateDOChan,
            grpc_types.CreateDOChanRequest(self, task, lines, name_to_assign_to_lines, line_grouping),
        )

    def create_lin_scale(
            self, name, slope, y_intercept, pre_scaled_units, scaled_units):
        response = self._invoke(
            self._client.CreateLinScale,
            grpc_types.CreateLinScaleRequest(self, name, slope, y_intercept, pre_scaled_units, scaled_units),
        )

    def create_map_scale(
            self, name, prescaled_min, prescaled_max, scaled_min, scaled_max,
            pre_scaled_units, scaled_units):
        response = self._invoke(
            self._client.CreateMapScale,
            grpc_types.CreateMapScaleRequest(self, name, prescaled_min, prescaled_max, scaled_min, scaled_max, pre_scaled_units, scaled_units),
        )

    def create_polynomial_scale(
            self, name, forward_coeffs, num_forward_coeffs_in, reverse_coeffs,
            num_reverse_coeffs_in, pre_scaled_units, scaled_units):
        response = self._invoke(
            self._client.CreatePolynomialScale,
            grpc_types.CreatePolynomialScaleRequest(self, name, forward_coeffs, num_forward_coeffs_in, reverse_coeffs, num_reverse_coeffs_in, pre_scaled_units, scaled_units),
        )

    def create_table_scale(
            self, name, prescaled_vals, num_prescaled_vals_in, scaled_vals,
            num_scaled_vals_in, pre_scaled_units, scaled_units):
        response = self._invoke(
            self._client.CreateTableScale,
            grpc_types.CreateTableScaleRequest(self, name, prescaled_vals, num_prescaled_vals_in, scaled_vals, num_scaled_vals_in, pre_scaled_units, scaled_units),
        )

    def create_task(self, task, session_name):
        response = self._invoke(
            self._client.CreateTask,
            grpc_types.CreateTaskRequest(self, task, session_name),
        )
        return response.task

    def create_tedsai_accel_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, current_excit_source,
            current_excit_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIAccelChan,
            grpc_types.CreateTEDSAIAccelChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, current_excit_source, current_excit_val, custom_scale_name),
        )

    def create_tedsai_bridge_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, voltage_excit_source, voltage_excit_val,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIBridgeChan,
            grpc_types.CreateTEDSAIBridgeChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name),
        )

    def create_tedsai_current_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, shunt_resistor_loc,
            ext_shunt_resistor_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAICurrentChan,
            grpc_types.CreateTEDSAICurrentChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, shunt_resistor_loc, ext_shunt_resistor_val, custom_scale_name),
        )

    def create_tedsai_force_bridge_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, voltage_excit_source, voltage_excit_val,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIForceBridgeChan,
            grpc_types.CreateTEDSAIForceBridgeChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name),
        )

    def create_tedsai_force_iepe_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, current_excit_source,
            current_excit_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIForceIEPEChan,
            grpc_types.CreateTEDSAIForceIEPEChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, current_excit_source, current_excit_val, custom_scale_name),
        )

    def create_tedsai_microphone_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, units, max_snd_press_level, current_excit_source,
            current_excit_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIMicrophoneChan,
            grpc_types.CreateTEDSAIMicrophoneChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, units, max_snd_press_level, current_excit_source, current_excit_val, custom_scale_name),
        )

    def create_tedsai_pos_lvdt_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, voltage_excit_source, voltage_excit_val,
            voltage_excit_freq, ac_excit_wire_mode, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIPosLVDTChan,
            grpc_types.CreateTEDSAIPosLVDTChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name),
        )

    def create_tedsai_pos_rvdt_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, voltage_excit_source, voltage_excit_val,
            voltage_excit_freq, ac_excit_wire_mode, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIPosRVDTChan,
            grpc_types.CreateTEDSAIPosRVDTChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, voltage_excit_freq, ac_excit_wire_mode, custom_scale_name),
        )

    def create_tedsai_pressure_bridge_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, voltage_excit_source, voltage_excit_val,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIPressureBridgeChan,
            grpc_types.CreateTEDSAIPressureBridgeChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name),
        )

    def create_tedsai_resistance_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, resistance_config, current_excit_source,
            current_excit_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIResistanceChan,
            grpc_types.CreateTEDSAIResistanceChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val, custom_scale_name),
        )

    def create_tedsai_strain_gage_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, voltage_excit_source, voltage_excit_val,
            initial_bridge_voltage, lead_wire_resistance, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIStrainGageChan,
            grpc_types.CreateTEDSAIStrainGageChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, initial_bridge_voltage, lead_wire_resistance, custom_scale_name),
        )

    def create_tedsai_thrmcpl_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, cjc_source, cjc_val, cjc_channel):
        response = self._invoke(
            self._client.CreateTEDSAIThrmcplChan,
            grpc_types.CreateTEDSAIThrmcplChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, cjc_source, cjc_val, cjc_channel),
        )

    def create_tedsai_thrmstr_chan_iex(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, resistance_config, current_excit_source,
            current_excit_val):
        response = self._invoke(
            self._client.CreateTEDSAIThrmstrChanIex,
            grpc_types.CreateTEDSAIThrmstrChanIexRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val),
        )

    def create_tedsai_thrmstr_chan_vex(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, resistance_config, voltage_excit_source,
            voltage_excit_val, r_1):
        response = self._invoke(
            self._client.CreateTEDSAIThrmstrChanVex,
            grpc_types.CreateTEDSAIThrmstrChanVexRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, voltage_excit_source, voltage_excit_val, r_1),
        )

    def create_tedsai_torque_bridge_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, voltage_excit_source, voltage_excit_val,
            custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAITorqueBridgeChan,
            grpc_types.CreateTEDSAITorqueBridgeChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name),
        )

    def create_tedsai_voltage_chan(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIVoltageChan,
            grpc_types.CreateTEDSAIVoltageChanRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, custom_scale_name),
        )

    def create_tedsai_voltage_chan_with_excit(
            self, task, physical_channel, name_to_assign_to_channel,
            terminal_config, min_val, max_val, units, voltage_excit_source,
            voltage_excit_val, custom_scale_name):
        response = self._invoke(
            self._client.CreateTEDSAIVoltageChanWithExcit,
            grpc_types.CreateTEDSAIVoltageChanWithExcitRequest(self, task, physical_channel, name_to_assign_to_channel, terminal_config, min_val, max_val, units, voltage_excit_source, voltage_excit_val, custom_scale_name),
        )

    def create_tedsairtd_chan(
            self, task, physical_channel, name_to_assign_to_channel, min_val,
            max_val, units, resistance_config, current_excit_source,
            current_excit_val):
        response = self._invoke(
            self._client.CreateTEDSAIRTDChan,
            grpc_types.CreateTEDSAIRTDChanRequest(self, task, physical_channel, name_to_assign_to_channel, min_val, max_val, units, resistance_config, current_excit_source, current_excit_val),
        )

    def create_watchdog_timer_task_ex(
            self, device_name, session_name, task, timeout):
        response = self._invoke(
            self._client.CreateWatchdogTimerTaskEx,
            grpc_types.CreateWatchdogTimerTaskExRequest(self, device_name, session_name, task, timeout),
        )
        return response.task

    def delete_network_device(self, device_name):
        response = self._invoke(
            self._client.DeleteNetworkDevice,
            grpc_types.DeleteNetworkDeviceRequest(self, device_name),
        )

    def disable_ref_trig(self, task):
        response = self._invoke(
            self._client.DisableRefTrig,
            grpc_types.DisableRefTrigRequest(self, task),
        )

    def disable_start_trig(self, task):
        response = self._invoke(
            self._client.DisableStartTrig,
            grpc_types.DisableStartTrigRequest(self, task),
        )

    def disconnect_terms(self, source_terminal, destination_terminal):
        response = self._invoke(
            self._client.DisconnectTerms,
            grpc_types.DisconnectTermsRequest(self, source_terminal, destination_terminal),
        )

    def export_signal(self, task, signal_id, output_terminal):
        response = self._invoke(
            self._client.ExportSignal,
            grpc_types.ExportSignalRequest(self, task, signal_id, output_terminal),
        )

    def get_analog_power_up_states(
            self, device_name, channel_name, state, channel_type):
        response = self._invoke(
            self._client.GetAnalogPowerUpStates,
            grpc_types.GetAnalogPowerUpStatesRequest(self, device_name, channel_name, state, channel_type),
        )
        return response.state,response.power_up_states

    def get_analog_power_up_states_with_output_type(
            self, channel_names, state_array, channel_type_array, array_size):
        response = self._invoke(
            self._client.GetAnalogPowerUpStatesWithOutputType,
            grpc_types.GetAnalogPowerUpStatesWithOutputTypeRequest(self, channel_names, state_array, channel_type_array, array_size),
        )
        return response.state_array,response.channel_type_array

    def get_auto_configured_cdaq_sync_connections(self, port_list):
        response = self._invoke(
            self._client.GetAutoConfiguredCDAQSyncConnections,
            grpc_types.GetAutoConfiguredCDAQSyncConnectionsRequest(self, port_list),
        )
        return response.port_list

    def get_digital_logic_family_power_up_state(
            self, device_name, logic_family):
        response = self._invoke(
            self._client.GetDigitalLogicFamilyPowerUpState,
            grpc_types.GetDigitalLogicFamilyPowerUpStateRequest(self, device_name, logic_family),
        )
        return response.logic_family

    def get_digital_power_up_states(self, device_name, channel_name, state):
        response = self._invoke(
            self._client.GetDigitalPowerUpStates,
            grpc_types.GetDigitalPowerUpStatesRequest(self, device_name, channel_name, state),
        )
        return response.state,response.power_up_states

    def get_digital_pull_up_pull_down_states(
            self, device_name, channel_name, state):
        response = self._invoke(
            self._client.GetDigitalPullUpPullDownStates,
            grpc_types.GetDigitalPullUpPullDownStatesRequest(self, device_name, channel_name, state),
        )
        return response.state,response.pull_up_pull_down_states

    def get_disconnected_cdaq_sync_ports(self, port_list):
        response = self._invoke(
            self._client.GetDisconnectedCDAQSyncPorts,
            grpc_types.GetDisconnectedCDAQSyncPortsRequest(self, port_list),
        )
        return response.port_list

    def is_task_done(self, task, is_task_done):
        response = self._invoke(
            self._client.IsTaskDone,
            grpc_types.IsTaskDoneRequest(self, task, is_task_done),
        )
        return response.is_task_done

    def load_task(self, session_name, task):
        response = self._invoke(
            self._client.LoadTask,
            grpc_types.LoadTaskRequest(self, session_name, task),
        )
        return response.task

    def read_analog_f64(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadAnalogF64,
            grpc_types.ReadAnalogF64Request(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_analog_scalar_f64(self, task, timeout, value):
        response = self._invoke(
            self._client.ReadAnalogScalarF64,
            grpc_types.ReadAnalogScalarF64Request(self, task, timeout, value),
        )
        return response.value

    def read_binary_i16(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadBinaryI16,
            grpc_types.ReadBinaryI16Request(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_binary_i32(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadBinaryI32,
            grpc_types.ReadBinaryI32Request(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_binary_u16(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadBinaryU16,
            grpc_types.ReadBinaryU16Request(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_binary_u32(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadBinaryU32,
            grpc_types.ReadBinaryU32Request(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_counter_f64(
            self, task, num_samps_per_chan, timeout, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadCounterF64,
            grpc_types.ReadCounterF64Request(self, task, num_samps_per_chan, timeout, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_counter_f64_ex(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadCounterF64Ex,
            grpc_types.ReadCounterF64ExRequest(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_counter_scalar_f64(self, task, timeout, value):
        response = self._invoke(
            self._client.ReadCounterScalarF64,
            grpc_types.ReadCounterScalarF64Request(self, task, timeout, value),
        )
        return response.value

    def read_counter_scalar_u32(self, task, timeout, value):
        response = self._invoke(
            self._client.ReadCounterScalarU32,
            grpc_types.ReadCounterScalarU32Request(self, task, timeout, value),
        )
        return response.value

    def read_counter_u32(
            self, task, num_samps_per_chan, timeout, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadCounterU32,
            grpc_types.ReadCounterU32Request(self, task, num_samps_per_chan, timeout, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_counter_u32_ex(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadCounterU32Ex,
            grpc_types.ReadCounterU32ExRequest(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_ctr_freq(
            self, task, num_samps_per_chan, timeout, interleaved,
            read_array_frequency, read_array_duty_cycle, samps_per_chan_read):
        response = self._invoke(
            self._client.ReadCtrFreq,
            grpc_types.ReadCtrFreqRequest(self, task, num_samps_per_chan, timeout, interleaved, read_array_frequency, read_array_duty_cycle, samps_per_chan_read),
        )
        return response.read_array_frequency,response.read_array_duty_cycle,response.samps_per_chan_read

    def read_ctr_freq_scalar(self, task, timeout, frequency, duty_cycle):
        response = self._invoke(
            self._client.ReadCtrFreqScalar,
            grpc_types.ReadCtrFreqScalarRequest(self, task, timeout, frequency, duty_cycle),
        )
        return response.frequency,response.duty_cycle

    def read_ctr_ticks(
            self, task, num_samps_per_chan, timeout, interleaved,
            read_array_high_ticks, read_array_low_ticks, samps_per_chan_read):
        response = self._invoke(
            self._client.ReadCtrTicks,
            grpc_types.ReadCtrTicksRequest(self, task, num_samps_per_chan, timeout, interleaved, read_array_high_ticks, read_array_low_ticks, samps_per_chan_read),
        )
        return response.read_array_high_ticks,response.read_array_low_ticks,response.samps_per_chan_read

    def read_ctr_ticks_scalar(self, task, timeout, high_ticks, low_ticks):
        response = self._invoke(
            self._client.ReadCtrTicksScalar,
            grpc_types.ReadCtrTicksScalarRequest(self, task, timeout, high_ticks, low_ticks),
        )
        return response.high_ticks,response.low_ticks

    def read_ctr_time(
            self, task, num_samps_per_chan, timeout, interleaved,
            read_array_high_time, read_array_low_time, samps_per_chan_read):
        response = self._invoke(
            self._client.ReadCtrTime,
            grpc_types.ReadCtrTimeRequest(self, task, num_samps_per_chan, timeout, interleaved, read_array_high_time, read_array_low_time, samps_per_chan_read),
        )
        return response.read_array_high_time,response.read_array_low_time,response.samps_per_chan_read

    def read_ctr_time_scalar(self, task, timeout, high_time, low_time):
        response = self._invoke(
            self._client.ReadCtrTimeScalar,
            grpc_types.ReadCtrTimeScalarRequest(self, task, timeout, high_time, low_time),
        )
        return response.high_time,response.low_time

    def read_digital_lines(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read, num_bytes_per_samp):
        response = self._invoke(
            self._client.ReadDigitalLines,
            grpc_types.ReadDigitalLinesRequest(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read, num_bytes_per_samp),
        )
        return response.read_array,response.samps_per_chan_read,response.num_bytes_per_samp

    def read_digital_scalar_u32(self, task, timeout, value):
        response = self._invoke(
            self._client.ReadDigitalScalarU32,
            grpc_types.ReadDigitalScalarU32Request(self, task, timeout, value),
        )
        return response.value

    def read_digital_u16(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadDigitalU16,
            grpc_types.ReadDigitalU16Request(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_digital_u32(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadDigitalU32,
            grpc_types.ReadDigitalU32Request(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_digital_u8(
            self, task, num_samps_per_chan, timeout, fill_mode, read_array,
            samps_per_chan_read):
        response = self._invoke(
            self._client.ReadDigitalU8,
            grpc_types.ReadDigitalU8Request(self, task, num_samps_per_chan, timeout, fill_mode, read_array, samps_per_chan_read),
        )
        return response.read_array,response.samps_per_chan_read

    def read_power_scalar_f64(self, task, timeout, voltage, current):
        response = self._invoke(
            self._client.ReadPowerScalarF64,
            grpc_types.ReadPowerScalarF64Request(self, task, timeout, voltage, current),
        )
        return response.voltage,response.current

    def remove_cdaq_sync_connection(self, port_list):
        response = self._invoke(
            self._client.RemoveCDAQSyncConnection,
            grpc_types.RemoveCDAQSyncConnectionRequest(self, port_list),
        )

    def reserve_network_device(self, device_name, override_reservation):
        response = self._invoke(
            self._client.ReserveNetworkDevice,
            grpc_types.ReserveNetworkDeviceRequest(self, device_name, override_reservation),
        )

    def reset_device(self, device_name):
        response = self._invoke(
            self._client.ResetDevice,
            grpc_types.ResetDeviceRequest(self, device_name),
        )

    def self_test_device(self, device_name):
        response = self._invoke(
            self._client.SelfTestDevice,
            grpc_types.SelfTestDeviceRequest(self, device_name),
        )

    def set_analog_power_up_states(
            self, device_name, channel_names, state, channel_type):
        response = self._invoke(
            self._client.SetAnalogPowerUpStates,
            grpc_types.SetAnalogPowerUpStatesRequest(self, device_name, channel_names, state, channel_type),
        )

    def set_analog_power_up_states_with_output_type(
            self, channel_names, state_array, channel_type_array, array_size):
        response = self._invoke(
            self._client.SetAnalogPowerUpStatesWithOutputType,
            grpc_types.SetAnalogPowerUpStatesWithOutputTypeRequest(self, channel_names, state_array, channel_type_array, array_size),
        )

    def set_digital_logic_family_power_up_state(
            self, device_name, logic_family):
        response = self._invoke(
            self._client.SetDigitalLogicFamilyPowerUpState,
            grpc_types.SetDigitalLogicFamilyPowerUpStateRequest(self, device_name, logic_family),
        )

    def set_digital_power_up_states(self, device_name, channel_names, state):
        response = self._invoke(
            self._client.SetDigitalPowerUpStates,
            grpc_types.SetDigitalPowerUpStatesRequest(self, device_name, channel_names, state),
        )

    def set_digital_pull_up_pull_down_states(
            self, device_name, channel_names, state):
        response = self._invoke(
            self._client.SetDigitalPullUpPullDownStates,
            grpc_types.SetDigitalPullUpPullDownStatesRequest(self, device_name, channel_names, state),
        )

    def start_new_file(self, task, file_path):
        response = self._invoke(
            self._client.StartNewFile,
            grpc_types.StartNewFileRequest(self, task, file_path),
        )

    def start_task(self, task):
        response = self._invoke(
            self._client.StartTask,
            grpc_types.StartTaskRequest(self, task),
        )

    def stop_task(self, task):
        response = self._invoke(
            self._client.StopTask,
            grpc_types.StopTaskRequest(self, task),
        )

    def task_control(self, task, action):
        response = self._invoke(
            self._client.TaskControl,
            grpc_types.TaskControlRequest(self, task, action),
        )

    def tristate_output_term(self, output_terminal):
        response = self._invoke(
            self._client.TristateOutputTerm,
            grpc_types.TristateOutputTermRequest(self, output_terminal),
        )

    def unreserve_network_device(self, device_name):
        response = self._invoke(
            self._client.UnreserveNetworkDevice,
            grpc_types.UnreserveNetworkDeviceRequest(self, device_name),
        )

    def wait_until_task_done(self, task, time_to_wait):
        response = self._invoke(
            self._client.WaitUntilTaskDone,
            grpc_types.WaitUntilTaskDoneRequest(self, task, time_to_wait),
        )

    def write_analog_f64(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            write_array, samps_per_chan_written):
        response = self._invoke(
            self._client.WriteAnalogF64,
            grpc_types.WriteAnalogF64Request(self, task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, samps_per_chan_written),
        )
        return response.samps_per_chan_written

    def write_analog_scalar_f64(self, task, auto_start, timeout, value):
        response = self._invoke(
            self._client.WriteAnalogScalarF64,
            grpc_types.WriteAnalogScalarF64Request(self, task, auto_start, timeout, value),
        )

    def write_binary_i16(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            write_array, samps_per_chan_written):
        response = self._invoke(
            self._client.WriteBinaryI16,
            grpc_types.WriteBinaryI16Request(self, task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, samps_per_chan_written),
        )
        return response.samps_per_chan_written

    def write_binary_i32(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            write_array, samps_per_chan_written):
        response = self._invoke(
            self._client.WriteBinaryI32,
            grpc_types.WriteBinaryI32Request(self, task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, samps_per_chan_written),
        )
        return response.samps_per_chan_written

    def write_binary_u16(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            write_array, samps_per_chan_written):
        response = self._invoke(
            self._client.WriteBinaryU16,
            grpc_types.WriteBinaryU16Request(self, task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, samps_per_chan_written),
        )
        return response.samps_per_chan_written

    def write_binary_u32(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            write_array, samps_per_chan_written):
        response = self._invoke(
            self._client.WriteBinaryU32,
            grpc_types.WriteBinaryU32Request(self, task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, samps_per_chan_written),
        )
        return response.samps_per_chan_written

    def write_ctr_freq(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            frequency, duty_cycle, num_samps_per_chan_written):
        response = self._invoke(
            self._client.WriteCtrFreq,
            grpc_types.WriteCtrFreqRequest(self, task, num_samps_per_chan, auto_start, timeout, data_layout, frequency, duty_cycle, num_samps_per_chan_written),
        )
        return response.num_samps_per_chan_written

    def write_ctr_freq_scalar(
            self, task, auto_start, timeout, frequency, duty_cycle):
        response = self._invoke(
            self._client.WriteCtrFreqScalar,
            grpc_types.WriteCtrFreqScalarRequest(self, task, auto_start, timeout, frequency, duty_cycle),
        )

    def write_ctr_ticks(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            high_ticks, low_ticks, num_samps_per_chan_written):
        response = self._invoke(
            self._client.WriteCtrTicks,
            grpc_types.WriteCtrTicksRequest(self, task, num_samps_per_chan, auto_start, timeout, data_layout, high_ticks, low_ticks, num_samps_per_chan_written),
        )
        return response.num_samps_per_chan_written

    def write_ctr_ticks_scalar(
            self, task, auto_start, timeout, high_ticks, low_ticks):
        response = self._invoke(
            self._client.WriteCtrTicksScalar,
            grpc_types.WriteCtrTicksScalarRequest(self, task, auto_start, timeout, high_ticks, low_ticks),
        )

    def write_ctr_time(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            high_time, low_time, num_samps_per_chan_written):
        response = self._invoke(
            self._client.WriteCtrTime,
            grpc_types.WriteCtrTimeRequest(self, task, num_samps_per_chan, auto_start, timeout, data_layout, high_time, low_time, num_samps_per_chan_written),
        )
        return response.num_samps_per_chan_written

    def write_ctr_time_scalar(
            self, task, auto_start, timeout, high_time, low_time):
        response = self._invoke(
            self._client.WriteCtrTimeScalar,
            grpc_types.WriteCtrTimeScalarRequest(self, task, auto_start, timeout, high_time, low_time),
        )

    def write_digital_lines(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            write_array, samps_per_chan_written):
        response = self._invoke(
            self._client.WriteDigitalLines,
            grpc_types.WriteDigitalLinesRequest(self, task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, samps_per_chan_written),
        )
        return response.samps_per_chan_written

    def write_digital_scalar_u32(self, task, auto_start, timeout, value):
        response = self._invoke(
            self._client.WriteDigitalScalarU32,
            grpc_types.WriteDigitalScalarU32Request(self, task, auto_start, timeout, value),
        )

    def write_digital_u16(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            write_array, samps_per_chan_written):
        response = self._invoke(
            self._client.WriteDigitalU16,
            grpc_types.WriteDigitalU16Request(self, task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, samps_per_chan_written),
        )
        return response.samps_per_chan_written

    def write_digital_u32(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            write_array, samps_per_chan_written):
        response = self._invoke(
            self._client.WriteDigitalU32,
            grpc_types.WriteDigitalU32Request(self, task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, samps_per_chan_written),
        )
        return response.samps_per_chan_written

    def write_digital_u8(
            self, task, num_samps_per_chan, auto_start, timeout, data_layout,
            write_array, samps_per_chan_written):
        response = self._invoke(
            self._client.WriteDigitalU8,
            grpc_types.WriteDigitalU8Request(self, task, num_samps_per_chan, auto_start, timeout, data_layout, write_array, samps_per_chan_written),
        )
        return response.samps_per_chan_written

    def write_to_teds_from_array(
            self, physical_channel, array_size, bit_stream,
            basic_teds_options):
        response = self._invoke(
            self._client.WriteToTEDSFromArray,
            grpc_types.WriteToTEDSFromArrayRequest(self, physical_channel, array_size, bit_stream, basic_teds_options),
        )

    def write_to_teds_from_file(
            self, physical_channel, file_path, basic_teds_options):
        response = self._invoke(
            self._client.WriteToTEDSFromFile,
            grpc_types.WriteToTEDSFromFileRequest(self, physical_channel, file_path, basic_teds_options),
        )
