# Do not edit this file; it was automatically generated.

import ctypes
import numpy

from nidaqmx._lib import (
    lib_importer, wrapped_ndpointer, ctypes_byte_str, c_bool32)
from nidaqmx.scale import Scale
from nidaqmx.errors import (
    check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
from nidaqmx._task_modules.channels.channel import Channel
from nidaqmx.constants import (
    AOIdleOutputBehavior, CurrentUnits, DataTransferActiveTransferMode,
    DigitalWidthUnits, FuncGenType, ModulationType,
    OutputDataTransferCondition, ResolutionType, SourceSelection,
    TerminalConfiguration, UsageTypeAO, VoltageUnits)


class AOChannel(Channel):
    """
    Represents one or more analog output virtual channels and their properties.
    """
    __slots__ = []

    def __repr__(self):
        return f'AOChannel(name={self._name})'

    @property
    def ao_common_mode_offset(self):
        """
        float: Specifies the common-mode offset of the AO channel. Use
            the property only when Terminal Configuration is set to
            Differential.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12748)
        return val

    @ao_common_mode_offset.setter
    def ao_common_mode_offset(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12748, val)

    @ao_common_mode_offset.deleter
    def ao_common_mode_offset(self):
        cfunc = lib_importer.windll.DAQmxResetAOCommonModeOffset
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_current_units(self):
        """
        :class:`nidaqmx.constants.CurrentUnits`: Specifies in what units
            to generate current on the channel. Write data to the
            channel in the units you select.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4361)
        return CurrentUnits(val)

    @ao_current_units.setter
    def ao_current_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 4361, val)

    @ao_current_units.deleter
    def ao_current_units(self):
        cfunc = lib_importer.windll.DAQmxResetAOCurrentUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_custom_scale(self):
        """
        :class:`nidaqmx.system.scale.Scale`: Specifies the name of a
            custom scale for the channel.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 4488)
        return Scale(val.value.decode('ascii'))

    @ao_custom_scale.setter
    def ao_custom_scale(self, val):
        val = val.name
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 4488, val)

    @ao_custom_scale.deleter
    def ao_custom_scale(self):
        cfunc = lib_importer.windll.DAQmxResetAOCustomScaleName
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_offset_ext_src(self):
        """
        str: Specifies the source of the DAC offset voltage if
            **ao_dac_offset_src** is **SourceSelection.EXTERNAL**. The
            valid sources for this signal vary by device.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8788)
        return val

    @ao_dac_offset_ext_src.setter
    def ao_dac_offset_ext_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8788, val)

    @ao_dac_offset_ext_src.deleter
    def ao_dac_offset_ext_src(self):
        cfunc = lib_importer.windll.DAQmxResetAODACOffsetExtSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_offset_src(self):
        """
        :class:`nidaqmx.constants.SourceSelection`: Specifies the source
            of the DAC offset voltage. The value of this voltage source
            determines the full-scale value of the DAC.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8787)
        return SourceSelection(val)

    @ao_dac_offset_src.setter
    def ao_dac_offset_src(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8787, val)

    @ao_dac_offset_src.deleter
    def ao_dac_offset_src(self):
        cfunc = lib_importer.windll.DAQmxResetAODACOffsetSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_offset_val(self):
        """
        float: Specifies in volts the value of the DAC offset voltage.
            To achieve best accuracy, the DAC offset value should be
            hand calibrated.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8789)
        return val

    @ao_dac_offset_val.setter
    def ao_dac_offset_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8789, val)

    @ao_dac_offset_val.deleter
    def ao_dac_offset_val(self):
        cfunc = lib_importer.windll.DAQmxResetAODACOffsetVal
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_ref_allow_conn_to_gnd(self):
        """
        bool: Specifies whether to allow grounding the internal DAC
            reference at run time. You must set this property to True
            and set **ao_dac_ref_src** to **SourceSelection.INTERNAL**
            before you can set **ao_dac_ref_conn_to_gnd** to True.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 6192)
        return val

    @ao_dac_ref_allow_conn_to_gnd.setter
    def ao_dac_ref_allow_conn_to_gnd(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 6192, val)

    @ao_dac_ref_allow_conn_to_gnd.deleter
    def ao_dac_ref_allow_conn_to_gnd(self):
        cfunc = lib_importer.windll.DAQmxResetAODACRefAllowConnToGnd
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_ref_conn_to_gnd(self):
        """
        bool: Specifies whether to ground the internal DAC reference.
            Grounding the internal DAC reference has the effect of
            grounding all analog output channels and stopping waveform
            generation across all analog output channels regardless of
            whether the channels belong to the current task. You can
            ground the internal DAC reference only when
            **ao_dac_ref_src** is **SourceSelection.INTERNAL** and
            **ao_dac_ref_allow_conn_to_gnd** is True.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 304)
        return val

    @ao_dac_ref_conn_to_gnd.setter
    def ao_dac_ref_conn_to_gnd(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 304, val)

    @ao_dac_ref_conn_to_gnd.deleter
    def ao_dac_ref_conn_to_gnd(self):
        cfunc = lib_importer.windll.DAQmxResetAODACRefConnToGnd
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_ref_ext_src(self):
        """
        str: Specifies the source of the DAC reference voltage if
            **ao_dac_ref_src** is **SourceSelection.EXTERNAL**. The
            valid sources for this signal vary by device.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8786)
        return val

    @ao_dac_ref_ext_src.setter
    def ao_dac_ref_ext_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8786, val)

    @ao_dac_ref_ext_src.deleter
    def ao_dac_ref_ext_src(self):
        cfunc = lib_importer.windll.DAQmxResetAODACRefExtSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_ref_src(self):
        """
        :class:`nidaqmx.constants.SourceSelection`: Specifies the source
            of the DAC reference voltage. The value of this voltage
            source determines the full-scale value of the DAC.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 306)
        return SourceSelection(val)

    @ao_dac_ref_src.setter
    def ao_dac_ref_src(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 306, val)

    @ao_dac_ref_src.deleter
    def ao_dac_ref_src(self):
        cfunc = lib_importer.windll.DAQmxResetAODACRefSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_ref_val(self):
        """
        float: Specifies in volts the value of the DAC reference
            voltage. This voltage determines the full-scale range of the
            DAC. Smaller reference voltages result in smaller ranges,
            but increased resolution.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6194)
        return val

    @ao_dac_ref_val.setter
    def ao_dac_ref_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6194, val)

    @ao_dac_ref_val.deleter
    def ao_dac_ref_val(self):
        cfunc = lib_importer.windll.DAQmxResetAODACRefVal
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_rng_high(self):
        """
        float: Specifies the upper limit of the output range of the
            device. This value is in the native units of the device. On
            E Series devices, for example, the native units is volts.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6190)
        return val

    @ao_dac_rng_high.setter
    def ao_dac_rng_high(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6190, val)

    @ao_dac_rng_high.deleter
    def ao_dac_rng_high(self):
        cfunc = lib_importer.windll.DAQmxResetAODACRngHigh
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dac_rng_low(self):
        """
        float: Specifies the lower limit of the output range of the
            device. This value is in the native units of the device. On
            E Series devices, for example, the native units is volts.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6189)
        return val

    @ao_dac_rng_low.setter
    def ao_dac_rng_low(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6189, val)

    @ao_dac_rng_low.deleter
    def ao_dac_rng_low(self):
        cfunc = lib_importer.windll.DAQmxResetAODACRngLow
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_data_xfer_mech(self):
        """
        :class:`nidaqmx.constants.DataTransferActiveTransferMode`:
            Specifies the data transfer mode for the device.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 308)
        return DataTransferActiveTransferMode(val)

    @ao_data_xfer_mech.setter
    def ao_data_xfer_mech(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 308, val)

    @ao_data_xfer_mech.deleter
    def ao_data_xfer_mech(self):
        cfunc = lib_importer.windll.DAQmxResetAODataXferMech
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_data_xfer_req_cond(self):
        """
        :class:`nidaqmx.constants.OutputDataTransferCondition`:
            Specifies under what condition to transfer data from the
            buffer to the onboard memory of the device.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6204)
        return OutputDataTransferCondition(val)

    @ao_data_xfer_req_cond.setter
    def ao_data_xfer_req_cond(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6204, val)

    @ao_data_xfer_req_cond.deleter
    def ao_data_xfer_req_cond(self):
        cfunc = lib_importer.windll.DAQmxResetAODataXferReqCond
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_dev_scaling_coeff(self):
        """
        List[float]: Indicates the coefficients of a linear equation
            that NI-DAQmx uses to scale values from a voltage to the
            native format of the device. Each element of the list
            corresponds to a term of the equation. The first element of
            the list corresponds to the y-intercept, and the second
            element corresponds to the slope. Scaling coefficients do
            not account for any custom scales that may be applied to the
            channel.
        """


        val = self._interpreter.get_chan_attribute_double_array(
                self._handle, self._name, 6449)
        return val

    @property
    def ao_enhanced_image_rejection_enable(self):
        """
        bool: Specifies whether to enable the DAC interpolation filter.
            Disable the interpolation filter to improve DAC signal-to-
            noise ratio at the expense of degraded image rejection.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8769)
        return val

    @ao_enhanced_image_rejection_enable.setter
    def ao_enhanced_image_rejection_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8769, val)

    @ao_enhanced_image_rejection_enable.deleter
    def ao_enhanced_image_rejection_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAOEnhancedImageRejectionEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_filter_delay(self):
        """
        float: Specifies the amount of time between when the sample is
            written by the host device and when the sample is output by
            the DAC. This value is in the units you specify with
            **ao_filter_delay_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12405)
        return val

    @ao_filter_delay.setter
    def ao_filter_delay(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12405, val)

    @ao_filter_delay.deleter
    def ao_filter_delay(self):
        cfunc = lib_importer.windll.DAQmxResetAOFilterDelay
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_filter_delay_adjustment(self):
        """
        float: Specifies an additional amount of time to wait between
            when the sample is written by the host device and when the
            sample is output by the DAC. This delay adjustment is in
            addition to the value indicated by **ao_filter_delay**. This
            delay adjustment is in the units you specify with
            **ao_filter_delay_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12402)
        return val

    @ao_filter_delay_adjustment.setter
    def ao_filter_delay_adjustment(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12402, val)

    @ao_filter_delay_adjustment.deleter
    def ao_filter_delay_adjustment(self):
        cfunc = lib_importer.windll.DAQmxResetAOFilterDelayAdjustment
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_filter_delay_units(self):
        """
        :class:`nidaqmx.constants.DigitalWidthUnits`: Specifies the
            units of **ao_filter_delay** and
            **ao_filter_delay_adjustment**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12406)
        return DigitalWidthUnits(val)

    @ao_filter_delay_units.setter
    def ao_filter_delay_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12406, val)

    @ao_filter_delay_units.deleter
    def ao_filter_delay_units(self):
        cfunc = lib_importer.windll.DAQmxResetAOFilterDelayUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_func_gen_amplitude(self):
        """
        float: Specifies the zero-to-peak amplitude of the waveform to
            generate in volts. Zero and negative values are valid.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10778)
        return val

    @ao_func_gen_amplitude.setter
    def ao_func_gen_amplitude(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10778, val)

    @ao_func_gen_amplitude.deleter
    def ao_func_gen_amplitude(self):
        cfunc = lib_importer.windll.DAQmxResetAOFuncGenAmplitude
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_func_gen_fm_deviation(self):
        """
        float: Specifies the FM deviation in hertz per volt when
            **ao_func_gen_modulation_type** is **ModulationType.FM**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10787)
        return val

    @ao_func_gen_fm_deviation.setter
    def ao_func_gen_fm_deviation(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10787, val)

    @ao_func_gen_fm_deviation.deleter
    def ao_func_gen_fm_deviation(self):
        cfunc = lib_importer.windll.DAQmxResetAOFuncGenFMDeviation
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_func_gen_freq(self):
        """
        float: Specifies the frequency of the waveform to generate in
            hertz.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10777)
        return val

    @ao_func_gen_freq.setter
    def ao_func_gen_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10777, val)

    @ao_func_gen_freq.deleter
    def ao_func_gen_freq(self):
        cfunc = lib_importer.windll.DAQmxResetAOFuncGenFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_func_gen_modulation_type(self):
        """
        :class:`nidaqmx.constants.ModulationType`: Specifies if the
            device generates a modulated version of the waveform using
            the original waveform as a carrier and input from an
            external terminal as the signal.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 10786)
        return ModulationType(val)

    @ao_func_gen_modulation_type.setter
    def ao_func_gen_modulation_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 10786, val)

    @ao_func_gen_modulation_type.deleter
    def ao_func_gen_modulation_type(self):
        cfunc = lib_importer.windll.DAQmxResetAOFuncGenModulationType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_func_gen_offset(self):
        """
        float: Specifies the voltage offset of the waveform to generate.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10779)
        return val

    @ao_func_gen_offset.setter
    def ao_func_gen_offset(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10779, val)

    @ao_func_gen_offset.deleter
    def ao_func_gen_offset(self):
        cfunc = lib_importer.windll.DAQmxResetAOFuncGenOffset
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_func_gen_square_duty_cycle(self):
        """
        float: Specifies the square wave duty cycle of the waveform to
            generate.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10780)
        return val

    @ao_func_gen_square_duty_cycle.setter
    def ao_func_gen_square_duty_cycle(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10780, val)

    @ao_func_gen_square_duty_cycle.deleter
    def ao_func_gen_square_duty_cycle(self):
        cfunc = lib_importer.windll.DAQmxResetAOFuncGenSquareDutyCycle
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_func_gen_start_phase(self):
        """
        float: Specifies the starting phase in degrees of the waveform
            to generate.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12740)
        return val

    @ao_func_gen_start_phase.setter
    def ao_func_gen_start_phase(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12740, val)

    @ao_func_gen_start_phase.deleter
    def ao_func_gen_start_phase(self):
        cfunc = lib_importer.windll.DAQmxResetAOFuncGenStartPhase
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_func_gen_type(self):
        """
        :class:`nidaqmx.constants.FuncGenType`: Specifies the kind of
            the waveform to generate.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 10776)
        return FuncGenType(val)

    @ao_func_gen_type.setter
    def ao_func_gen_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 10776, val)

    @ao_func_gen_type.deleter
    def ao_func_gen_type(self):
        cfunc = lib_importer.windll.DAQmxResetAOFuncGenType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_gain(self):
        """
        float: Specifies in decibels the gain factor to apply to the
            channel.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 280)
        return val

    @ao_gain.setter
    def ao_gain(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 280, val)

    @ao_gain.deleter
    def ao_gain(self):
        cfunc = lib_importer.windll.DAQmxResetAOGain
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_idle_output_behavior(self):
        """
        :class:`nidaqmx.constants.AOIdleOutputBehavior`: Specifies the
            state of the channel when no generation is in progress.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8768)
        return AOIdleOutputBehavior(val)

    @ao_idle_output_behavior.setter
    def ao_idle_output_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8768, val)

    @ao_idle_output_behavior.deleter
    def ao_idle_output_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetAOIdleOutputBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_load_impedance(self):
        """
        float: Specifies in ohms the load impedance connected to the
            analog output channel.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 289)
        return val

    @ao_load_impedance.setter
    def ao_load_impedance(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 289, val)

    @ao_load_impedance.deleter
    def ao_load_impedance(self):
        cfunc = lib_importer.windll.DAQmxResetAOLoadImpedance
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_max(self):
        """
        float: Specifies the maximum value you expect to generate. The
            value is in the units you specify with a units property. If
            you try to write a value larger than the maximum value, NI-
            DAQmx generates an error. NI-DAQmx might coerce this value
            to a smaller value if other task settings restrict the
            device from generating the desired maximum.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 4486)
        return val

    @ao_max.setter
    def ao_max(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 4486, val)

    @ao_max.deleter
    def ao_max(self):
        cfunc = lib_importer.windll.DAQmxResetAOMax
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_mem_map_enable(self):
        """
        bool: Specifies for NI-DAQmx to map hardware registers to the
            memory space of the application, if possible. Normally, NI-
            DAQmx maps hardware registers to memory accessible only to
            the kernel. Mapping the registers to the memory space of the
            application increases performance. However, if the
            application accesses the memory space mapped to the
            registers, it can adversely affect the operation of the
            device and possibly result in a system crash.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 6287)
        return val

    @ao_mem_map_enable.setter
    def ao_mem_map_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 6287, val)

    @ao_mem_map_enable.deleter
    def ao_mem_map_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAOMemMapEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_min(self):
        """
        float: Specifies the minimum value you expect to generate. The
            value is in the units you specify with a units property. If
            you try to write a value smaller than the minimum value, NI-
            DAQmx generates an error. NI-DAQmx might coerce this value
            to a larger value if other task settings restrict the device
            from generating the desired minimum.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 4487)
        return val

    @ao_min.setter
    def ao_min(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 4487, val)

    @ao_min.deleter
    def ao_min(self):
        cfunc = lib_importer.windll.DAQmxResetAOMin
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_output_impedance(self):
        """
        float: Specifies in ohms the impedance of the analog output
            stage of the device.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 5264)
        return val

    @ao_output_impedance.setter
    def ao_output_impedance(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 5264, val)

    @ao_output_impedance.deleter
    def ao_output_impedance(self):
        cfunc = lib_importer.windll.DAQmxResetAOOutputImpedance
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_output_type(self):
        """
        :class:`nidaqmx.constants.UsageTypeAO`: Indicates whether the
            channel generates voltage,  current, or a waveform.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4360)
        return UsageTypeAO(val)

    @property
    def ao_reglitch_enable(self):
        """
        bool: Specifies whether to enable reglitching.  The output of a
            DAC normally glitches whenever the DAC is updated with a new
            value. The amount of glitching differs from code to code and
            is generally largest at major code transitions.  Reglitching
            generates uniform glitch energy at each code transition and
            provides for more uniform glitches.  Uniform glitch energy
            makes it easier to filter out the noise introduced from
            glitching during spectrum analysis.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 307)
        return val

    @ao_reglitch_enable.setter
    def ao_reglitch_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 307, val)

    @ao_reglitch_enable.deleter
    def ao_reglitch_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAOReglitchEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_resolution(self):
        """
        float: Indicates the resolution of the digital-to-analog
            converter of the channel. This value is in the units you
            specify with **ao_resolution_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6188)
        return val

    @property
    def ao_resolution_units(self):
        """
        :class:`nidaqmx.constants.ResolutionType`: Specifies the units
            of **ao_resolution**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6187)
        return ResolutionType(val)

    @ao_resolution_units.setter
    def ao_resolution_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6187, val)

    @ao_resolution_units.deleter
    def ao_resolution_units(self):
        cfunc = lib_importer.windll.DAQmxResetAOResolutionUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            terminal configuration of the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6286)
        return TerminalConfiguration(val)

    @ao_term_cfg.setter
    def ao_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6286, val)

    @ao_term_cfg.deleter
    def ao_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetAOTermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_usb_xfer_req_count(self):
        """
        int: Specifies the maximum number of simultaneous USB transfers
            used to stream data. Modify this value to affect performance
            under different combinations of operating system and device.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12289)
        return val

    @ao_usb_xfer_req_count.setter
    def ao_usb_xfer_req_count(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12289, val)

    @ao_usb_xfer_req_count.deleter
    def ao_usb_xfer_req_count(self):
        cfunc = lib_importer.windll.DAQmxResetAOUsbXferReqCount
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_usb_xfer_req_size(self):
        """
        int: Specifies the maximum size of a USB transfer request in
            bytes. Modify this value to affect performance under
            different combinations of operating system and device.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 10895)
        return val

    @ao_usb_xfer_req_size.setter
    def ao_usb_xfer_req_size(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 10895, val)

    @ao_usb_xfer_req_size.deleter
    def ao_usb_xfer_req_size(self):
        cfunc = lib_importer.windll.DAQmxResetAOUsbXferReqSize
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_use_only_on_brd_mem(self):
        """
        bool: Specifies whether to write samples directly to the onboard
            memory of the device, bypassing the memory buffer.
            Generally, you cannot update onboard memory directly after
            you start the task. Onboard memory includes data FIFOs.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 6202)
        return val

    @ao_use_only_on_brd_mem.setter
    def ao_use_only_on_brd_mem(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 6202, val)

    @ao_use_only_on_brd_mem.deleter
    def ao_use_only_on_brd_mem(self):
        cfunc = lib_importer.windll.DAQmxResetAOUseOnlyOnBrdMem
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_voltage_current_limit(self):
        """
        float: Specifies the current limit, in amperes, for the voltage
            channel.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10781)
        return val

    @ao_voltage_current_limit.setter
    def ao_voltage_current_limit(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10781, val)

    @ao_voltage_current_limit.deleter
    def ao_voltage_current_limit(self):
        cfunc = lib_importer.windll.DAQmxResetAOVoltageCurrentLimit
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ao_voltage_units(self):
        """
        :class:`nidaqmx.constants.VoltageUnits`: Specifies in what units
            to generate voltage on the channel. Write data to the
            channel in the units you select.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4484)
        return VoltageUnits(val)

    @ao_voltage_units.setter
    def ao_voltage_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 4484, val)

    @ao_voltage_units.deleter
    def ao_voltage_units(self):
        cfunc = lib_importer.windll.DAQmxResetAOVoltageUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

