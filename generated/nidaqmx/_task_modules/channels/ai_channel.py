# Do not edit this file; it was automatically generated.

import ctypes
import numpy
import deprecation

from nidaqmx._lib import (
    lib_importer, wrapped_ndpointer, ctypes_byte_str, c_bool32)
from nidaqmx.scale import Scale
from nidaqmx.errors import (
    check_for_error, is_string_buffer_too_small, is_array_buffer_too_small)
from nidaqmx._task_modules.channels.channel import Channel
from nidaqmx.utils import unflatten_channel_string
from nidaqmx.constants import (
    ACExcitWireMode, ADCTimingMode, AccelChargeSensitivityUnits,
    AccelSensitivityUnits, AccelUnits, AngleUnits, AutoZeroType,
    BridgeConfiguration, BridgeElectricalUnits, BridgePhysicalUnits,
    BridgeShuntCalSource, BridgeUnits, CJCSource, ChargeUnits, Coupling,
    CurrentShuntResistorLocation, CurrentUnits, DataJustification,
    DataTransferActiveTransferMode, DigitalWidthUnits,
    EddyCurrentProxProbeSensitivityUnits, ExcitationDCorAC,
    ExcitationIdleOutputBehavior, ExcitationSource,
    ExcitationVoltageOrCurrent, FilterResponse, FilterType,
    ForceIEPESensorSensitivityUnits, ForceUnits, FrequencyUnits, Impedance1,
    InputDataTransferCondition, LVDTSensitivityUnits, LengthUnits,
    PowerIdleOutputBehavior, PowerOutputState, PressureUnits, RTDType,
    RVDTSensitivityUnits, RawDataCompressionType, ResistanceConfiguration,
    ResistanceUnits, ResolutionType, ScaleType, Sense, SensorPowerCfg,
    SensorPowerType, ShuntCalSelect, SoundPressureUnits, SourceSelection,
    StrainGageBridgeType, StrainGageRosetteMeasurementType,
    StrainGageRosetteType, StrainUnits, TemperatureUnits,
    TerminalConfiguration, ThermocoupleType, TorqueUnits, UsageTypeAI,
    VelocityIEPESensorSensitivityUnits, VelocityUnits, VoltageUnits)


class AIChannel(Channel):
    """
    Represents one or more analog input virtual channels and their properties.
    """
    __slots__ = []

    def __repr__(self):
        return f'AIChannel(name={self._name})'

    @property
    def ai_ac_excit_freq(self):
        """
        float: Specifies the AC excitation frequency in Hertz.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 257)
        return val

    @ai_ac_excit_freq.setter
    def ai_ac_excit_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 257, val)

    @ai_ac_excit_freq.deleter
    def ai_ac_excit_freq(self):
        cfunc = lib_importer.windll.DAQmxResetAIACExcitFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_ac_excit_sync_enable(self):
        """
        bool: Specifies whether to synchronize the AC excitation source
            of the channel to that of another channel. Synchronize the
            excitation sources of multiple channels to use multichannel
            sensors. Set this property to False for the master channel
            and to True for the slave channels.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 258)
        return val

    @ai_ac_excit_sync_enable.setter
    def ai_ac_excit_sync_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 258, val)

    @ai_ac_excit_sync_enable.deleter
    def ai_ac_excit_sync_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIACExcitSyncEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_ac_excit_wire_mode(self):
        """
        :class:`nidaqmx.constants.ACExcitWireMode`: Specifies the number
            of leads on the LVDT or RVDT. Some sensors require you to
            tie leads together to create a four- or five- wire sensor.
            Refer to the sensor documentation for more information.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6349)
        return ACExcitWireMode(val)

    @ai_ac_excit_wire_mode.setter
    def ai_ac_excit_wire_mode(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6349, val)

    @ai_ac_excit_wire_mode.deleter
    def ai_ac_excit_wire_mode(self):
        cfunc = lib_importer.windll.DAQmxResetAIACExcitWireMode
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_accel_4_wire_dc_voltage_sensitivity(self):
        """
        float: Specifies the sensitivity of the 4 wire DC voltage
            acceleration sensor connected to the channel. This value is
            the units you specify with
            AI.Accel.4WireDCVoltage.SensitivityUnits. Refer to the
            sensor documentation to determine this value.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12565)
        return val

    @ai_accel_4_wire_dc_voltage_sensitivity.setter
    def ai_accel_4_wire_dc_voltage_sensitivity(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12565, val)

    @ai_accel_4_wire_dc_voltage_sensitivity.deleter
    def ai_accel_4_wire_dc_voltage_sensitivity(self):
        cfunc = lib_importer.windll.DAQmxResetAIAccel4WireDCVoltageSensitivity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_accel_4_wire_dc_voltage_sensitivity_units(self):
        """
        :class:`nidaqmx.constants.AccelSensitivityUnits`: Specifies the
            units of AI.Accel.4WireDCVoltage.Sensitivity.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12566)
        return AccelSensitivityUnits(val)

    @ai_accel_4_wire_dc_voltage_sensitivity_units.setter
    def ai_accel_4_wire_dc_voltage_sensitivity_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12566, val)

    @ai_accel_4_wire_dc_voltage_sensitivity_units.deleter
    def ai_accel_4_wire_dc_voltage_sensitivity_units(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIAccel4WireDCVoltageSensitivityUnits)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_accel_charge_sensitivity(self):
        """
        float: Specifies the sensitivity of the charge acceleration
            sensor connected to the channel. This value is the units you
            specify with AI.Accel.Charge.SensitivityUnits. Refer to the
            sensor documentation to determine this value.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12563)
        return val

    @ai_accel_charge_sensitivity.setter
    def ai_accel_charge_sensitivity(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12563, val)

    @ai_accel_charge_sensitivity.deleter
    def ai_accel_charge_sensitivity(self):
        cfunc = lib_importer.windll.DAQmxResetAIAccelChargeSensitivity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_accel_charge_sensitivity_units(self):
        """
        :class:`nidaqmx.constants.AccelChargeSensitivityUnits`:
            Specifies the units of AI.Accel.Charge.Sensitivity.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12564)
        return AccelChargeSensitivityUnits(val)

    @ai_accel_charge_sensitivity_units.setter
    def ai_accel_charge_sensitivity_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12564, val)

    @ai_accel_charge_sensitivity_units.deleter
    def ai_accel_charge_sensitivity_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIAccelChargeSensitivityUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_accel_db_ref(self):
        """
        float: Specifies the decibel reference level in the units of the
            channel. When you read samples as a waveform, the decibel
            reference level is included in the waveform attributes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10674)
        return val

    @ai_accel_db_ref.setter
    def ai_accel_db_ref(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10674, val)

    @ai_accel_db_ref.deleter
    def ai_accel_db_ref(self):
        cfunc = lib_importer.windll.DAQmxResetAIAcceldBRef
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_accel_sensitivity(self):
        """
        float: Specifies the sensitivity of the accelerometer. This
            value is in the units you specify with
            **ai_accel_sensitivity_units**. Refer to the sensor
            documentation to determine this value.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 1682)
        return val

    @ai_accel_sensitivity.setter
    def ai_accel_sensitivity(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 1682, val)

    @ai_accel_sensitivity.deleter
    def ai_accel_sensitivity(self):
        cfunc = lib_importer.windll.DAQmxResetAIAccelSensitivity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_accel_sensitivity_units(self):
        """
        :class:`nidaqmx.constants.AccelSensitivityUnits`: Specifies the
            units of **ai_accel_sensitivity**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8604)
        return AccelSensitivityUnits(val)

    @ai_accel_sensitivity_units.setter
    def ai_accel_sensitivity_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8604, val)

    @ai_accel_sensitivity_units.deleter
    def ai_accel_sensitivity_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIAccelSensitivityUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_accel_units(self):
        """
        :class:`nidaqmx.constants.AccelUnits`: Specifies the units to
            use to return acceleration measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 1651)
        return AccelUnits(val)

    @ai_accel_units.setter
    def ai_accel_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 1651, val)

    @ai_accel_units.deleter
    def ai_accel_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIAccelUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_adc_custom_timing_mode(self):
        """
        int: Specifies the timing mode of the ADC when
            **ai_adc_timing_mode** is **ADCTimingMode.CUSTOM**.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12139)
        return val

    @ai_adc_custom_timing_mode.setter
    def ai_adc_custom_timing_mode(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12139, val)

    @ai_adc_custom_timing_mode.deleter
    def ai_adc_custom_timing_mode(self):
        cfunc = lib_importer.windll.DAQmxResetAIADCCustomTimingMode
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_adc_timing_mode(self):
        """
        :class:`nidaqmx.constants.ADCTimingMode`: Specifies the ADC
            timing mode, controlling the tradeoff between speed and
            effective resolution. Some ADC timing modes provide
            increased powerline noise rejection. On devices that have an
            AI Convert clock, this setting affects both the maximum and
            default values for **ai_conv_rate**. You must use the same
            ADC timing mode for all channels on a device, but you can
            use different ADC timing modes for different devices in the
            same task.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 10745)
        return ADCTimingMode(val)

    @ai_adc_timing_mode.setter
    def ai_adc_timing_mode(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 10745, val)

    @ai_adc_timing_mode.deleter
    def ai_adc_timing_mode(self):
        cfunc = lib_importer.windll.DAQmxResetAIADCTimingMode
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_atten(self):
        """
        float: Specifies the amount of attenuation to use.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6145)
        return val

    @ai_atten.setter
    def ai_atten(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6145, val)

    @ai_atten.deleter
    def ai_atten(self):
        cfunc = lib_importer.windll.DAQmxResetAIAtten
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_auto_zero_mode(self):
        """
        :class:`nidaqmx.constants.AutoZeroType`: Specifies how often to
            measure ground. NI-DAQmx subtracts the measured ground
            voltage from every sample.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 5984)
        return AutoZeroType(val)

    @ai_auto_zero_mode.setter
    def ai_auto_zero_mode(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 5984, val)

    @ai_auto_zero_mode.deleter
    def ai_auto_zero_mode(self):
        cfunc = lib_importer.windll.DAQmxResetAIAutoZeroMode
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_averaging_win_size(self):
        """
        int: Specifies the number of samples to average while acquiring
            data. Increasing the number of samples to average reduces
            noise in your measurement.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12270)
        return val

    @ai_averaging_win_size.setter
    def ai_averaging_win_size(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12270, val)

    @ai_averaging_win_size.deleter
    def ai_averaging_win_size(self):
        cfunc = lib_importer.windll.DAQmxResetAIAveragingWinSize
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_balance_coarse_pot(self):
        """
        int: Specifies by how much to compensate for offset in the
            signal. This value can be between 0 and 127.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6129)
        return val

    @ai_bridge_balance_coarse_pot.setter
    def ai_bridge_balance_coarse_pot(self, val):
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6129, val)

    @ai_bridge_balance_coarse_pot.deleter
    def ai_bridge_balance_coarse_pot(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeBalanceCoarsePot
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_balance_fine_pot(self):
        """
        int: Specifies by how much to compensate for offset in the
            signal. This value can be between 0 and 4095.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6388)
        return val

    @ai_bridge_balance_fine_pot.setter
    def ai_bridge_balance_fine_pot(self, val):
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6388, val)

    @ai_bridge_balance_fine_pot.deleter
    def ai_bridge_balance_fine_pot(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeBalanceFinePot
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_cfg(self):
        """
        :class:`nidaqmx.constants.BridgeConfiguration`: Specifies the
            type of Wheatstone bridge connected to the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 135)
        return BridgeConfiguration(val)

    @ai_bridge_cfg.setter
    def ai_bridge_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 135, val)

    @ai_bridge_cfg.deleter
    def ai_bridge_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_electrical_units(self):
        """
        :class:`nidaqmx.constants.BridgeElectricalUnits`: Specifies from
            which electrical unit to scale data. Select  the same unit
            that the sensor data sheet or calibration certificate uses
            for electrical values.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12167)
        return BridgeElectricalUnits(val)

    @ai_bridge_electrical_units.setter
    def ai_bridge_electrical_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12167, val)

    @ai_bridge_electrical_units.deleter
    def ai_bridge_electrical_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeElectricalUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_initial_ratio(self):
        """
        float: Specifies in volts per volt the ratio of output voltage
            from the bridge to excitation voltage supplied to the bridge
            while not under load. NI-DAQmx subtracts this value from any
            measurements before applying scaling equations. If you set
            **ai_bridge_initial_voltage**, NI-DAQmx coerces this
            property  to **ai_bridge_initial_voltage** divided by
            **ai_excit_actual_val**. If you set this property, NI-DAQmx
            coerces **ai_bridge_initial_voltage** to the value of this
            property times **ai_excit_actual_val**. If you set both this
            property and **ai_bridge_initial_voltage**, and their values
            conflict, NI-DAQmx returns an error.  To avoid this error,
            reset one property to its default value before setting the
            other.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12166)
        return val

    @ai_bridge_initial_ratio.setter
    def ai_bridge_initial_ratio(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12166, val)

    @ai_bridge_initial_ratio.deleter
    def ai_bridge_initial_ratio(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeInitialRatio
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_initial_voltage(self):
        """
        float: Specifies in volts the output voltage of the bridge while
            not under load. NI-DAQmx subtracts this value from any
            measurements before applying scaling equations.  If you set
            **ai_bridge_initial_ratio**, NI-DAQmx coerces this property
            to **ai_bridge_initial_ratio** times
            **ai_excit_actual_val**. This property is set by DAQmx
            Perform Bridge Offset Nulling Calibration. If you set this
            property, NI-DAQmx coerces **ai_bridge_initial_ratio** to
            the value of this property divided by
            **ai_excit_actual_val**. If you set both this property and
            **ai_bridge_initial_ratio**, and their values conflict, NI-
            DAQmx returns an error. To avoid this error, reset one
            property to its default value before setting the other.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6125)
        return val

    @ai_bridge_initial_voltage.setter
    def ai_bridge_initial_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6125, val)

    @ai_bridge_initial_voltage.deleter
    def ai_bridge_initial_voltage(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeInitialVoltage
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_nom_resistance(self):
        """
        float: Specifies in ohms the resistance of the bridge while not
            under load.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6124)
        return val

    @ai_bridge_nom_resistance.setter
    def ai_bridge_nom_resistance(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6124, val)

    @ai_bridge_nom_resistance.deleter
    def ai_bridge_nom_resistance(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeNomResistance
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_physical_units(self):
        """
        :class:`nidaqmx.constants.BridgePhysicalUnits`: Specifies to
            which physical unit to scale electrical data. Select the
            same unit that the sensor data sheet or calibration
            certificate uses for physical values.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12168)
        return BridgePhysicalUnits(val)

    @ai_bridge_physical_units.setter
    def ai_bridge_physical_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12168, val)

    @ai_bridge_physical_units.deleter
    def ai_bridge_physical_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgePhysicalUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_poly_forward_coeff(self):
        """
        List[float]: Specifies an list of coefficients for the
            polynomial that converts electrical values to physical
            values. Each element of the list corresponds to a term of
            the equation. For example, if index three of the list is 9,
            the fourth term of the equation is 9x^3.
        """


        val = self._interpreter.get_chan_attribute_double_array(
                self._handle, self._name, 12176)
        return val

    @ai_bridge_poly_forward_coeff.setter
    def ai_bridge_poly_forward_coeff(self, val):
        val = numpy.float64(val)
        self._interpreter.set_chan_attribute_double_array(
                self._handle, self._name, 12176, val, len(val))

    @ai_bridge_poly_forward_coeff.deleter
    def ai_bridge_poly_forward_coeff(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgePolyForwardCoeff
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_poly_reverse_coeff(self):
        """
        List[float]: Specifies an list of coefficients for the
            polynomial that converts physical values to electrical
            values. Each element of the list corresponds to a term of
            the equation. For example, if index three of the list is 9,
            the fourth term of the equation is 9x^3.
        """


        val = self._interpreter.get_chan_attribute_double_array(
                self._handle, self._name, 12177)
        return val

    @ai_bridge_poly_reverse_coeff.setter
    def ai_bridge_poly_reverse_coeff(self, val):
        val = numpy.float64(val)
        self._interpreter.set_chan_attribute_double_array(
                self._handle, self._name, 12177, val, len(val))

    @ai_bridge_poly_reverse_coeff.deleter
    def ai_bridge_poly_reverse_coeff(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgePolyReverseCoeff
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_scale_type(self):
        """
        :class:`nidaqmx.constants.ScaleType`: Specifies the scaling type
            to use when scaling electrical values from the sensor to
            physical units.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12169)
        return ScaleType(val)

    @ai_bridge_scale_type.setter
    def ai_bridge_scale_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12169, val)

    @ai_bridge_scale_type.deleter
    def ai_bridge_scale_type(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeScaleType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_shunt_cal_enable(self):
        """
        bool: Specifies whether to enable a shunt calibration switch.
            Use **ai_bridge_shunt_cal_select** to select the switch(es)
            to enable.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 148)
        return val

    @ai_bridge_shunt_cal_enable.setter
    def ai_bridge_shunt_cal_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 148, val)

    @ai_bridge_shunt_cal_enable.deleter
    def ai_bridge_shunt_cal_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeShuntCalEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_shunt_cal_gain_adjust(self):
        """
        float: Specifies the result of a shunt calibration. This
            property is set by DAQmx Perform Shunt Calibration. NI-DAQmx
            multiplies data read from the channel by the value of this
            property. This value should be close to 1.0.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6463)
        return val

    @ai_bridge_shunt_cal_gain_adjust.setter
    def ai_bridge_shunt_cal_gain_adjust(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6463, val)

    @ai_bridge_shunt_cal_gain_adjust.deleter
    def ai_bridge_shunt_cal_gain_adjust(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeShuntCalGainAdjust
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_shunt_cal_select(self):
        """
        :class:`nidaqmx.constants.ShuntCalSelect`: Specifies which shunt
            calibration switch(es) to enable.  Use
            **ai_bridge_shunt_cal_enable** to enable the switch(es) you
            specify with this property.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8661)
        return ShuntCalSelect(val)

    @ai_bridge_shunt_cal_select.setter
    def ai_bridge_shunt_cal_select(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8661, val)

    @ai_bridge_shunt_cal_select.deleter
    def ai_bridge_shunt_cal_select(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeShuntCalSelect
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_shunt_cal_shunt_cal_a_actual_resistance(self):
        """
        float: Specifies in ohms the actual value of the internal shunt
            calibration A resistor.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12153)
        return val

    @ai_bridge_shunt_cal_shunt_cal_a_actual_resistance.setter
    def ai_bridge_shunt_cal_shunt_cal_a_actual_resistance(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12153, val)

    @ai_bridge_shunt_cal_shunt_cal_a_actual_resistance.deleter
    def ai_bridge_shunt_cal_shunt_cal_a_actual_resistance(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIBridgeShuntCalShuntCalAActualResistance)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_shunt_cal_shunt_cal_a_resistance(self):
        """
        float: Specifies in ohms the desired value of the internal shunt
            calibration A resistor.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12152)
        return val

    @ai_bridge_shunt_cal_shunt_cal_a_resistance.setter
    def ai_bridge_shunt_cal_shunt_cal_a_resistance(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12152, val)

    @ai_bridge_shunt_cal_shunt_cal_a_resistance.deleter
    def ai_bridge_shunt_cal_shunt_cal_a_resistance(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIBridgeShuntCalShuntCalAResistance)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_shunt_cal_shunt_cal_a_src(self):
        """
        :class:`nidaqmx.constants.BridgeShuntCalSource`: Specifies
            whether to use internal or external shunt when Shunt Cal A
            is selected.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12490)
        return BridgeShuntCalSource(val)

    @ai_bridge_shunt_cal_shunt_cal_a_src.setter
    def ai_bridge_shunt_cal_shunt_cal_a_src(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12490, val)

    @ai_bridge_shunt_cal_shunt_cal_a_src.deleter
    def ai_bridge_shunt_cal_shunt_cal_a_src(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeShuntCalShuntCalASrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_shunt_cal_shunt_cal_b_actual_resistance(self):
        """
        float: Specifies in ohms the actual value of the internal shunt
            calibration B resistor.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12155)
        return val

    @ai_bridge_shunt_cal_shunt_cal_b_actual_resistance.setter
    def ai_bridge_shunt_cal_shunt_cal_b_actual_resistance(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12155, val)

    @ai_bridge_shunt_cal_shunt_cal_b_actual_resistance.deleter
    def ai_bridge_shunt_cal_shunt_cal_b_actual_resistance(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIBridgeShuntCalShuntCalBActualResistance)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_shunt_cal_shunt_cal_b_resistance(self):
        """
        float: Specifies in ohms the desired value of the internal shunt
            calibration B resistor.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12154)
        return val

    @ai_bridge_shunt_cal_shunt_cal_b_resistance.setter
    def ai_bridge_shunt_cal_shunt_cal_b_resistance(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12154, val)

    @ai_bridge_shunt_cal_shunt_cal_b_resistance.deleter
    def ai_bridge_shunt_cal_shunt_cal_b_resistance(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIBridgeShuntCalShuntCalBResistance)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_table_electrical_vals(self):
        """
        List[float]: Specifies the list of electrical values that map to
            the values in **ai_bridge_table_physical_vals**. Specify
            this value in the unit indicated by
            **ai_bridge_electrical_units**.
        """


        val = self._interpreter.get_chan_attribute_double_array(
                self._handle, self._name, 12174)
        return val

    @ai_bridge_table_electrical_vals.setter
    def ai_bridge_table_electrical_vals(self, val):
        val = numpy.float64(val)
        self._interpreter.set_chan_attribute_double_array(
                self._handle, self._name, 12174, val, len(val))

    @ai_bridge_table_electrical_vals.deleter
    def ai_bridge_table_electrical_vals(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeTableElectricalVals
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_table_physical_vals(self):
        """
        List[float]: Specifies the list of physical values that map to
            the values in **ai_bridge_table_electrical_vals**. Specify
            this value in the unit indicated by
            **ai_bridge_physical_units**.
        """


        val = self._interpreter.get_chan_attribute_double_array(
                self._handle, self._name, 12175)
        return val

    @ai_bridge_table_physical_vals.setter
    def ai_bridge_table_physical_vals(self, val):
        val = numpy.float64(val)
        self._interpreter.set_chan_attribute_double_array(
                self._handle, self._name, 12175, val, len(val))

    @ai_bridge_table_physical_vals.deleter
    def ai_bridge_table_physical_vals(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeTablePhysicalVals
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_two_point_lin_first_electrical_val(self):
        """
        float: Specifies the first electrical value, corresponding to
            **ai_bridge_two_point_lin_first_physical_val**. Specify this
            value in the unit indicated by
            **ai_bridge_electrical_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12170)
        return val

    @ai_bridge_two_point_lin_first_electrical_val.setter
    def ai_bridge_two_point_lin_first_electrical_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12170, val)

    @ai_bridge_two_point_lin_first_electrical_val.deleter
    def ai_bridge_two_point_lin_first_electrical_val(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIBridgeTwoPointLinFirstElectricalVal)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_two_point_lin_first_physical_val(self):
        """
        float: Specifies the first physical value, corresponding to
            **ai_bridge_two_point_lin_first_electrical_val**. Specify
            this value in the unit indicated by
            **ai_bridge_physical_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12171)
        return val

    @ai_bridge_two_point_lin_first_physical_val.setter
    def ai_bridge_two_point_lin_first_physical_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12171, val)

    @ai_bridge_two_point_lin_first_physical_val.deleter
    def ai_bridge_two_point_lin_first_physical_val(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIBridgeTwoPointLinFirstPhysicalVal)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_two_point_lin_second_electrical_val(self):
        """
        float: Specifies the second electrical value, corresponding to
            **ai_bridge_two_point_lin_second_physical_val**. Specify
            this value in the unit indicated by
            **ai_bridge_electrical_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12172)
        return val

    @ai_bridge_two_point_lin_second_electrical_val.setter
    def ai_bridge_two_point_lin_second_electrical_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12172, val)

    @ai_bridge_two_point_lin_second_electrical_val.deleter
    def ai_bridge_two_point_lin_second_electrical_val(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIBridgeTwoPointLinSecondElectricalVal)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_two_point_lin_second_physical_val(self):
        """
        float: Specifies the second physical value, corresponding to
            **ai_bridge_two_point_lin_second_electrical_val**. Specify
            this value in the unit indicated by
            **ai_bridge_physical_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12173)
        return val

    @ai_bridge_two_point_lin_second_physical_val.setter
    def ai_bridge_two_point_lin_second_physical_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12173, val)

    @ai_bridge_two_point_lin_second_physical_val.deleter
    def ai_bridge_two_point_lin_second_physical_val(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIBridgeTwoPointLinSecondPhysicalVal)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_bridge_units(self):
        """
        :class:`nidaqmx.constants.BridgeUnits`: Specifies in which unit
            to return voltage ratios from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12178)
        return BridgeUnits(val)

    @ai_bridge_units.setter
    def ai_bridge_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12178, val)

    @ai_bridge_units.deleter
    def ai_bridge_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIBridgeUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_charge_units(self):
        """
        :class:`nidaqmx.constants.ChargeUnits`: Specifies the units to
            use to return charge measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12562)
        return ChargeUnits(val)

    @ai_charge_units.setter
    def ai_charge_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12562, val)

    @ai_charge_units.deleter
    def ai_charge_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIChargeUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_chop_enable(self):
        """
        bool: Specifies whether the device will chop its inputs.
            Chopping removes offset voltages and other low frequency
            errors.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12611)
        return val

    @ai_chop_enable.setter
    def ai_chop_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12611, val)

    @ai_chop_enable.deleter
    def ai_chop_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIChopEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_coupling(self):
        """
        :class:`nidaqmx.constants.Coupling`: Specifies the coupling for
            the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 100)
        return Coupling(val)

    @ai_coupling.setter
    def ai_coupling(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 100, val)

    @ai_coupling.deleter
    def ai_coupling(self):
        cfunc = lib_importer.windll.DAQmxResetAICoupling
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_current_acrms_units(self):
        """
        :class:`nidaqmx.constants.CurrentUnits`: Specifies the units to
            use to return current RMS measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6115)
        return CurrentUnits(val)

    @ai_current_acrms_units.setter
    def ai_current_acrms_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6115, val)

    @ai_current_acrms_units.deleter
    def ai_current_acrms_units(self):
        cfunc = lib_importer.windll.DAQmxResetAICurrentACRMSUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_current_shunt_loc(self):
        """
        :class:`nidaqmx.constants.CurrentShuntResistorLocation`:
            Specifies the shunt resistor location for current
            measurements.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6130)
        return CurrentShuntResistorLocation(val)

    @ai_current_shunt_loc.setter
    def ai_current_shunt_loc(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6130, val)

    @ai_current_shunt_loc.deleter
    def ai_current_shunt_loc(self):
        cfunc = lib_importer.windll.DAQmxResetAICurrentShuntLoc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_current_shunt_resistance(self):
        """
        float: Specifies in ohms the external shunt resistance for
            current measurements.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6131)
        return val

    @ai_current_shunt_resistance.setter
    def ai_current_shunt_resistance(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6131, val)

    @ai_current_shunt_resistance.deleter
    def ai_current_shunt_resistance(self):
        cfunc = lib_importer.windll.DAQmxResetAICurrentShuntResistance
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_current_units(self):
        """
        :class:`nidaqmx.constants.CurrentUnits`: Specifies the units to
            use to return current measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 1793)
        return CurrentUnits(val)

    @ai_current_units.setter
    def ai_current_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 1793, val)

    @ai_current_units.deleter
    def ai_current_units(self):
        cfunc = lib_importer.windll.DAQmxResetAICurrentUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_custom_scale(self):
        """
        :class:`nidaqmx.system.scale.Scale`: Specifies the name of a
            custom scale for the channel.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 6112)
        return Scale(val.value.decode('ascii'))

    @ai_custom_scale.setter
    def ai_custom_scale(self, val):
        val = val.name
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 6112, val)

    @ai_custom_scale.deleter
    def ai_custom_scale(self):
        cfunc = lib_importer.windll.DAQmxResetAICustomScaleName
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_data_xfer_custom_threshold(self):
        """
        int: Specifies the number of samples that must be in the FIFO to
            transfer data from the device if **ai_data_xfer_req_cond**
            is
            **InputDataTransferCondition.ONBOARD_MEMORY_CUSTOM_THRESHOLD**.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 8972)
        return val

    @ai_data_xfer_custom_threshold.setter
    def ai_data_xfer_custom_threshold(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 8972, val)

    @ai_data_xfer_custom_threshold.deleter
    def ai_data_xfer_custom_threshold(self):
        cfunc = lib_importer.windll.DAQmxResetAIDataXferCustomThreshold
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_data_xfer_max_rate(self):
        """
        float: Specifies the rate in B/s to transfer data from the
            device. If this value is not set, then the device will
            transfer data at a rate based on the bus detected. Modify
            this value to affect performance under different
            combinations of operating system, configuration, and device.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12567)
        return val

    @ai_data_xfer_max_rate.setter
    def ai_data_xfer_max_rate(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12567, val)

    @ai_data_xfer_max_rate.deleter
    def ai_data_xfer_max_rate(self):
        cfunc = lib_importer.windll.DAQmxResetAIDataXferMaxRate
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_data_xfer_mech(self):
        """
        :class:`nidaqmx.constants.DataTransferActiveTransferMode`:
            Specifies the data transfer mode for the device.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6177)
        return DataTransferActiveTransferMode(val)

    @ai_data_xfer_mech.setter
    def ai_data_xfer_mech(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6177, val)

    @ai_data_xfer_mech.deleter
    def ai_data_xfer_mech(self):
        cfunc = lib_importer.windll.DAQmxResetAIDataXferMech
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_data_xfer_req_cond(self):
        """
        :class:`nidaqmx.constants.InputDataTransferCondition`: Specifies
            under what condition to transfer data from the onboard
            memory of the device to the buffer.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6283)
        return InputDataTransferCondition(val)

    @ai_data_xfer_req_cond.setter
    def ai_data_xfer_req_cond(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6283, val)

    @ai_data_xfer_req_cond.deleter
    def ai_data_xfer_req_cond(self):
        cfunc = lib_importer.windll.DAQmxResetAIDataXferReqCond
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dc_offset(self):
        """
        float: Specifies the DC value to add to the input range of the
            device. Use **ai_rng_high** and **ai_rng_low** to specify
            the input range. This offset is in the native units of the
            device .
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10889)
        return val

    @ai_dc_offset.setter
    def ai_dc_offset(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10889, val)

    @ai_dc_offset.deleter
    def ai_dc_offset(self):
        cfunc = lib_importer.windll.DAQmxResetAIDCOffset
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dev_scaling_coeff(self):
        """
        List[float]: Indicates the coefficients of a polynomial equation
            that NI-DAQmx uses to scale values from the native format of
            the device to volts. Each element of the list corresponds to
            a term of the equation. For example, if index two of the
            list is 4, the third term of the equation is 4x^2. Scaling
            coefficients do not account for any custom scales or sensors
            contained by the channel.
        """


        val = self._interpreter.get_chan_attribute_double_array(
                self._handle, self._name, 6448)
        return val

    @property
    def ai_dig_fltr_bandpass_center_freq(self):
        """
        float: Specifies the center frequency of the passband for the
            digital filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12483)
        return val

    @ai_dig_fltr_bandpass_center_freq.setter
    def ai_dig_fltr_bandpass_center_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12483, val)

    @ai_dig_fltr_bandpass_center_freq.deleter
    def ai_dig_fltr_bandpass_center_freq(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrBandpassCenterFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_bandpass_width(self):
        """
        float: Specifies the width of the passband centered around the
            center frequency for the digital filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12484)
        return val

    @ai_dig_fltr_bandpass_width.setter
    def ai_dig_fltr_bandpass_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12484, val)

    @ai_dig_fltr_bandpass_width.deleter
    def ai_dig_fltr_bandpass_width(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrBandpassWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_coeff(self):
        """
        List[float]: Specifies the digital filter coefficients.
        """


        val = self._interpreter.get_chan_attribute_double_array(
                self._handle, self._name, 12487)
        return val

    @ai_dig_fltr_coeff.setter
    def ai_dig_fltr_coeff(self, val):
        val = numpy.float64(val)
        self._interpreter.set_chan_attribute_double_array(
                self._handle, self._name, 12487, val, len(val))

    @ai_dig_fltr_coeff.deleter
    def ai_dig_fltr_coeff(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrCoeff
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_enable(self):
        """
        bool: Specifies whether the digital filter is enabled or
            disabled.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12477)
        return val

    @ai_dig_fltr_enable.setter
    def ai_dig_fltr_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12477, val)

    @ai_dig_fltr_enable.deleter
    def ai_dig_fltr_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_highpass_cutoff_freq(self):
        """
        float: Specifies the highpass cutoff frequency of the digital
            filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12482)
        return val

    @ai_dig_fltr_highpass_cutoff_freq.setter
    def ai_dig_fltr_highpass_cutoff_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12482, val)

    @ai_dig_fltr_highpass_cutoff_freq.deleter
    def ai_dig_fltr_highpass_cutoff_freq(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrHighpassCutoffFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_lowpass_cutoff_freq(self):
        """
        float: Specifies the lowpass cutoff frequency of the digital
            filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12481)
        return val

    @ai_dig_fltr_lowpass_cutoff_freq.setter
    def ai_dig_fltr_lowpass_cutoff_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12481, val)

    @ai_dig_fltr_lowpass_cutoff_freq.deleter
    def ai_dig_fltr_lowpass_cutoff_freq(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrLowpassCutoffFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_notch_center_freq(self):
        """
        float: Specifies the center frequency of the stopband for the
            digital filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12485)
        return val

    @ai_dig_fltr_notch_center_freq.setter
    def ai_dig_fltr_notch_center_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12485, val)

    @ai_dig_fltr_notch_center_freq.deleter
    def ai_dig_fltr_notch_center_freq(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrNotchCenterFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_notch_width(self):
        """
        float: Specifies the width of the stopband centered around the
            center frequency for the digital filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12486)
        return val

    @ai_dig_fltr_notch_width.setter
    def ai_dig_fltr_notch_width(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12486, val)

    @ai_dig_fltr_notch_width.deleter
    def ai_dig_fltr_notch_width(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrNotchWidth
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_order(self):
        """
        int: Specifies the order of the digital filter.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12480)
        return val

    @ai_dig_fltr_order.setter
    def ai_dig_fltr_order(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12480, val)

    @ai_dig_fltr_order.deleter
    def ai_dig_fltr_order(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrOrder
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_response(self):
        """
        :class:`nidaqmx.constants.FilterResponse`: Specifies the digital
            filter response.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12479)
        return FilterResponse(val)

    @ai_dig_fltr_response.setter
    def ai_dig_fltr_response(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12479, val)

    @ai_dig_fltr_response.deleter
    def ai_dig_fltr_response(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrResponse
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dig_fltr_type(self):
        """
        :class:`nidaqmx.constants.FilterType`: Specifies the digital
            filter type.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12478)
        return FilterType(val)

    @ai_dig_fltr_type.setter
    def ai_dig_fltr_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12478, val)

    @ai_dig_fltr_type.deleter
    def ai_dig_fltr_type(self):
        cfunc = lib_importer.windll.DAQmxResetAIDigFltrType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_dither_enable(self):
        """
        bool: Specifies whether to enable dithering.  Dithering adds
            Gaussian noise to the input signal. You can use dithering to
            achieve higher resolution measurements by over sampling the
            input signal and averaging the results.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 104)
        return val

    @ai_dither_enable.setter
    def ai_dither_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 104, val)

    @ai_dither_enable.deleter
    def ai_dither_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIDitherEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_eddy_current_prox_sensitivity(self):
        """
        float: Specifies the sensitivity of the eddy current proximity
            probe . This value is in the units you specify with
            **ai_eddy_current_prox_sensitivity_units**. Refer to the
            sensor documentation to determine this value.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10942)
        return val

    @ai_eddy_current_prox_sensitivity.setter
    def ai_eddy_current_prox_sensitivity(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10942, val)

    @ai_eddy_current_prox_sensitivity.deleter
    def ai_eddy_current_prox_sensitivity(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIEddyCurrentProxProbeSensitivity)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_eddy_current_prox_sensitivity_units(self):
        """
        :class:`nidaqmx.constants.EddyCurrentProxProbeSensitivityUnits`:
            Specifies the units of **ai_eddy_current_prox_sensitivity**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 10943)
        return EddyCurrentProxProbeSensitivityUnits(val)

    @ai_eddy_current_prox_sensitivity_units.setter
    def ai_eddy_current_prox_sensitivity_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 10943, val)

    @ai_eddy_current_prox_sensitivity_units.deleter
    def ai_eddy_current_prox_sensitivity_units(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIEddyCurrentProxProbeSensitivityUnits)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_eddy_current_prox_units(self):
        """
        :class:`nidaqmx.constants.LengthUnits`: Specifies the units to
            use to return proximity measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 10944)
        return LengthUnits(val)

    @ai_eddy_current_prox_units.setter
    def ai_eddy_current_prox_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 10944, val)

    @ai_eddy_current_prox_units.deleter
    def ai_eddy_current_prox_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIEddyCurrentProxProbeUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_enhanced_alias_rejection_enable(self):
        """
        bool: Specifies whether to enable enhanced alias rejection.
            Leave this property set to the default value for most
            applications.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8852)
        return val

    @ai_enhanced_alias_rejection_enable.setter
    def ai_enhanced_alias_rejection_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8852, val)

    @ai_enhanced_alias_rejection_enable.deleter
    def ai_enhanced_alias_rejection_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIEnhancedAliasRejectionEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_excit_actual_val(self):
        """
        float: Specifies the actual amount of excitation supplied by an
            internal excitation source.  If you read an internal
            excitation source more precisely with an external device,
            set this property to the value you read.  NI-DAQmx ignores
            this value for external excitation. When performing shunt
            calibration, some devices set this property automatically.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6275)
        return val

    @ai_excit_actual_val.setter
    def ai_excit_actual_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6275, val)

    @ai_excit_actual_val.deleter
    def ai_excit_actual_val(self):
        cfunc = lib_importer.windll.DAQmxResetAIExcitActualVal
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_excit_d_cor_ac(self):
        """
        :class:`nidaqmx.constants.ExcitationDCorAC`: Specifies if the
            excitation supply is DC or AC.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6139)
        return ExcitationDCorAC(val)

    @ai_excit_d_cor_ac.setter
    def ai_excit_d_cor_ac(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6139, val)

    @ai_excit_d_cor_ac.deleter
    def ai_excit_d_cor_ac(self):
        cfunc = lib_importer.windll.DAQmxResetAIExcitDCorAC
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_excit_idle_output_behavior(self):
        """
        :class:`nidaqmx.constants.ExcitationIdleOutputBehavior`:
            Specifies whether this channel will disable excitation after
            the task is uncommitted. Setting this to Zero Volts or Amps
            disables excitation after task uncommit. Setting this
            attribute to Maintain Existing Value leaves the excitation
            on after task uncommit.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12472)
        return ExcitationIdleOutputBehavior(val)

    @ai_excit_idle_output_behavior.setter
    def ai_excit_idle_output_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12472, val)

    @ai_excit_idle_output_behavior.deleter
    def ai_excit_idle_output_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetAIExcitIdleOutputBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_excit_sense(self):
        """
        :class:`nidaqmx.constants.Sense`: Specifies whether to use local
            or remote sense to sense excitation.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12541)
        return Sense(val)

    @ai_excit_sense.setter
    def ai_excit_sense(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12541, val)

    @ai_excit_sense.deleter
    def ai_excit_sense(self):
        cfunc = lib_importer.windll.DAQmxResetAIExcitSense
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_excit_src(self):
        """
        :class:`nidaqmx.constants.ExcitationSource`: Specifies the
            source of excitation.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6132)
        return ExcitationSource(val)

    @ai_excit_src.setter
    def ai_excit_src(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6132, val)

    @ai_excit_src.deleter
    def ai_excit_src(self):
        cfunc = lib_importer.windll.DAQmxResetAIExcitSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_excit_use_for_scaling(self):
        """
        bool: Specifies if NI-DAQmx divides the measurement by the
            excitation. You should typically set this property to True
            for ratiometric transducers. If you set this property to
            True, set **ai_max** and **ai_min** to reflect the scaling.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 6140)
        return val

    @ai_excit_use_for_scaling.setter
    def ai_excit_use_for_scaling(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 6140, val)

    @ai_excit_use_for_scaling.deleter
    def ai_excit_use_for_scaling(self):
        cfunc = lib_importer.windll.DAQmxResetAIExcitUseForScaling
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_excit_use_multiplexed(self):
        """
        bool: Specifies if the SCXI-1122 multiplexes the excitation to
            the upper half of the channels as it advances through the
            scan list.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 8576)
        return val

    @ai_excit_use_multiplexed.setter
    def ai_excit_use_multiplexed(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 8576, val)

    @ai_excit_use_multiplexed.deleter
    def ai_excit_use_multiplexed(self):
        cfunc = lib_importer.windll.DAQmxResetAIExcitUseMultiplexed
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_excit_val(self):
        """
        float: Specifies the amount of excitation that the sensor
            requires. If **ai_excit_voltage_or_current** is
            **ExcitationVoltageOrCurrent.USE_VOLTAGE**, this value is in
            volts. If **ai_excit_voltage_or_current** is
            **ExcitationVoltageOrCurrent.USE_CURRENT**, this value is in
            amperes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6133)
        return val

    @ai_excit_val.setter
    def ai_excit_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6133, val)

    @ai_excit_val.deleter
    def ai_excit_val(self):
        cfunc = lib_importer.windll.DAQmxResetAIExcitVal
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_excit_voltage_or_current(self):
        """
        :class:`nidaqmx.constants.ExcitationVoltageOrCurrent`: Specifies
            if the channel uses current or voltage excitation.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6134)
        return ExcitationVoltageOrCurrent(val)

    @ai_excit_voltage_or_current.setter
    def ai_excit_voltage_or_current(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6134, val)

    @ai_excit_voltage_or_current.deleter
    def ai_excit_voltage_or_current(self):
        cfunc = lib_importer.windll.DAQmxResetAIExcitVoltageOrCurrent
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_filter_delay(self):
        """
        float: Indicates the amount of time between when the ADC samples
            data and when the sample is read by the host device. This
            value is in the units you specify with
            **ai_filter_delay_units**. You can adjust this amount of
            time using **ai_filter_delay_adjustment**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12269)
        return val

    @property
    def ai_filter_delay_adjustment(self):
        """
        float: Specifies the amount of filter delay that gets removed if
            **ai_remove_filter_delay** is enabled. This delay adjustment
            is in addition to the value indicated by
            **ai_filter_delay**. This delay adjustment is in the units
            you specify with **ai_filter_delay_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12404)
        return val

    @ai_filter_delay_adjustment.setter
    def ai_filter_delay_adjustment(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12404, val)

    @ai_filter_delay_adjustment.deleter
    def ai_filter_delay_adjustment(self):
        cfunc = lib_importer.windll.DAQmxResetAIFilterDelayAdjustment
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_filter_delay_units(self):
        """
        :class:`nidaqmx.constants.DigitalWidthUnits`: Specifies the
            units of **ai_filter_delay** and
            **ai_filter_delay_adjustment**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12401)
        return DigitalWidthUnits(val)

    @ai_filter_delay_units.setter
    def ai_filter_delay_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12401, val)

    @ai_filter_delay_units.deleter
    def ai_filter_delay_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIFilterDelayUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_filter_enable(self):
        """
        bool: Specifies the corresponding filter enable/disable state.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12659)
        return val

    @ai_filter_enable.setter
    def ai_filter_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12659, val)

    @ai_filter_enable.deleter
    def ai_filter_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIFilterEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_filter_freq(self):
        """
        float: Specifies the corresponding filter frequency (cutoff or
            center) of the filter response.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12660)
        return val

    @ai_filter_freq.setter
    def ai_filter_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12660, val)

    @ai_filter_freq.deleter
    def ai_filter_freq(self):
        cfunc = lib_importer.windll.DAQmxResetAIFilterFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_filter_order(self):
        """
        int: Specifies the corresponding filter order and defines the
            slope of the filter response.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12662)
        return val

    @ai_filter_order.setter
    def ai_filter_order(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12662, val)

    @ai_filter_order.deleter
    def ai_filter_order(self):
        cfunc = lib_importer.windll.DAQmxResetAIFilterOrder
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_filter_response(self):
        """
        :class:`nidaqmx.constants.FilterResponse`: Specifies the
            corresponding filter response and defines the shape of the
            filter response.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12661)
        return FilterResponse(val)

    @ai_filter_response.setter
    def ai_filter_response(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12661, val)

    @ai_filter_response.deleter
    def ai_filter_response(self):
        cfunc = lib_importer.windll.DAQmxResetAIFilterResponse
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_force_iepe_sensor_sensitivity(self):
        """
        float: Specifies the sensitivity of the IEPE force sensor
            connected to the channel. Specify this value in the unit
            indicated by **ai_force_iepe_sensor_sensitivity_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12161)
        return val

    @ai_force_iepe_sensor_sensitivity.setter
    def ai_force_iepe_sensor_sensitivity(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12161, val)

    @ai_force_iepe_sensor_sensitivity.deleter
    def ai_force_iepe_sensor_sensitivity(self):
        cfunc = lib_importer.windll.DAQmxResetAIForceIEPESensorSensitivity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_force_iepe_sensor_sensitivity_units(self):
        """
        :class:`nidaqmx.constants.ForceIEPESensorSensitivityUnits`:
            Specifies the units for
            **ai_force_iepe_sensor_sensitivity**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12162)
        return ForceIEPESensorSensitivityUnits(val)

    @ai_force_iepe_sensor_sensitivity_units.setter
    def ai_force_iepe_sensor_sensitivity_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12162, val)

    @ai_force_iepe_sensor_sensitivity_units.deleter
    def ai_force_iepe_sensor_sensitivity_units(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIForceIEPESensorSensitivityUnits)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_force_read_from_chan(self):
        """
        bool: Specifies whether to read from the channel if it is a
            cold-junction compensation channel. By default, DAQmx Read
            does not return data from cold-junction compensation
            channels.  Setting this property to True forces read
            operations to return the cold-junction compensation channel
            data with the other channels in the task.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 6392)
        return val

    @ai_force_read_from_chan.setter
    def ai_force_read_from_chan(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 6392, val)

    @ai_force_read_from_chan.deleter
    def ai_force_read_from_chan(self):
        cfunc = lib_importer.windll.DAQmxResetAIForceReadFromChan
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_force_units(self):
        """
        :class:`nidaqmx.constants.ForceUnits`: Specifies in which unit
            to return force or load measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12149)
        return ForceUnits(val)

    @ai_force_units.setter
    def ai_force_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12149, val)

    @ai_force_units.deleter
    def ai_force_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIForceUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_freq_hyst(self):
        """
        float: Specifies in volts a window below
            **ai_freq_thresh_voltage**. The input voltage must pass
            below **ai_freq_thresh_voltage** minus this value before NI-
            DAQmx recognizes a waveform repetition at
            **ai_freq_thresh_voltage**. Hysteresis can improve the
            measurement accuracy when the signal contains noise or
            jitter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2068)
        return val

    @ai_freq_hyst.setter
    def ai_freq_hyst(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2068, val)

    @ai_freq_hyst.deleter
    def ai_freq_hyst(self):
        cfunc = lib_importer.windll.DAQmxResetAIFreqHyst
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_freq_thresh_voltage(self):
        """
        float: Specifies the voltage level at which to recognize
            waveform repetitions. You should select a voltage level that
            occurs only once within the entire period of a waveform. You
            also can select a voltage that occurs only once while the
            voltage rises or falls.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2069)
        return val

    @ai_freq_thresh_voltage.setter
    def ai_freq_thresh_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2069, val)

    @ai_freq_thresh_voltage.deleter
    def ai_freq_thresh_voltage(self):
        cfunc = lib_importer.windll.DAQmxResetAIFreqThreshVoltage
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_freq_units(self):
        """
        :class:`nidaqmx.constants.FrequencyUnits`: Specifies the units
            to use to return frequency measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2054)
        return FrequencyUnits(val)

    @ai_freq_units.setter
    def ai_freq_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2054, val)

    @ai_freq_units.deleter
    def ai_freq_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIFreqUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_gain(self):
        """
        float: Specifies a gain factor to apply to the channel.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6168)
        return val

    @ai_gain.setter
    def ai_gain(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6168, val)

    @ai_gain.deleter
    def ai_gain(self):
        cfunc = lib_importer.windll.DAQmxResetAIGain
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_impedance(self):
        """
        :class:`nidaqmx.constants.Impedance1`: Specifies the input
            impedance of the channel.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 98)
        return Impedance1(val)

    @ai_impedance.setter
    def ai_impedance(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 98, val)

    @ai_impedance.deleter
    def ai_impedance(self):
        cfunc = lib_importer.windll.DAQmxResetAIImpedance
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_input_limits_fault_detect_enable(self):
        """
        bool: Specifies whether to enable input limits fault detection.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12686)
        return val

    @ai_input_limits_fault_detect_enable.setter
    def ai_input_limits_fault_detect_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12686, val)

    @ai_input_limits_fault_detect_enable.deleter
    def ai_input_limits_fault_detect_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIInputLimitsFaultDetectEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_input_limits_fault_detect_lower_limit(self):
        """
        float: Specifies the level of the lower limit for input limits
            detection. An input sample outside the upper and lower
            bounds causes a fault. Note: Fault detection applies to both
            positive and negative inputs. For instance, if you specify a
            lower limit of 2 mA and an upper limit of 12 mA, NI-DAQmx
            detects a fault at 15 mA and -15 mA, but not at -6 mA
            because it is in the range of -12 mA to -2 mA.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12685)
        return val

    @ai_input_limits_fault_detect_lower_limit.setter
    def ai_input_limits_fault_detect_lower_limit(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12685, val)

    @ai_input_limits_fault_detect_lower_limit.deleter
    def ai_input_limits_fault_detect_lower_limit(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIInputLimitsFaultDetectLowerLimit)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_input_limits_fault_detect_upper_limit(self):
        """
        float: Specifies the level of the upper limit for input limits
            detection. An input sample outside the upper and lower
            bounds causes a fault. Note: Fault detection applies to both
            positive and negative inputs. For instance, if you specify a
            lower limit of 2 mA and an upper limit of 12 mA, NI-DAQmx
            detects a fault at 15 mA and -15 mA, but not at -6 mA
            because it is in the range of -12 mA to -2 mA.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12684)
        return val

    @ai_input_limits_fault_detect_upper_limit.setter
    def ai_input_limits_fault_detect_upper_limit(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12684, val)

    @ai_input_limits_fault_detect_upper_limit.deleter
    def ai_input_limits_fault_detect_upper_limit(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIInputLimitsFaultDetectUpperLimit)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_input_src(self):
        """
        str: Specifies the source of the channel. You can use the signal
            from the I/O connector or one of several calibration
            signals. Certain devices have a single calibration signal
            bus. For these devices, you must specify the same
            calibration signal for all channels you connect to a
            calibration signal.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8600)
        return val

    @ai_input_src.setter
    def ai_input_src(self, val):
        self._interpreter.set_chan_attribute_string(
                self._handle, self._name, 8600, val)

    @ai_input_src.deleter
    def ai_input_src(self):
        cfunc = lib_importer.windll.DAQmxResetAIInputSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lead_wire_resistance(self):
        """
        float: Specifies in ohms the resistance of the wires that lead
            to the sensor.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6126)
        return val

    @ai_lead_wire_resistance.setter
    def ai_lead_wire_resistance(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6126, val)

    @ai_lead_wire_resistance.deleter
    def ai_lead_wire_resistance(self):
        cfunc = lib_importer.windll.DAQmxResetAILeadWireResistance
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lossy_lsb_removal_compressed_samp_size(self):
        """
        int: Specifies the number of bits to return in a raw sample when
            **ai_raw_data_compression_type** is set to
            **RawDataCompressionType.LOSSY_LSB_REMOVAL**.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 8921)
        return val

    @ai_lossy_lsb_removal_compressed_samp_size.setter
    def ai_lossy_lsb_removal_compressed_samp_size(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 8921, val)

    @ai_lossy_lsb_removal_compressed_samp_size.deleter
    def ai_lossy_lsb_removal_compressed_samp_size(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAILossyLSBRemovalCompressedSampSize)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lowpass_cutoff_freq(self):
        """
        float: Specifies the frequency in Hertz that corresponds to the
            -3dB cutoff of the filter.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6147)
        return val

    @ai_lowpass_cutoff_freq.setter
    def ai_lowpass_cutoff_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6147, val)

    @ai_lowpass_cutoff_freq.deleter
    def ai_lowpass_cutoff_freq(self):
        cfunc = lib_importer.windll.DAQmxResetAILowpassCutoffFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lowpass_enable(self):
        """
        bool: Specifies whether to enable the lowpass filter of the
            channel.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 6146)
        return val

    @ai_lowpass_enable.setter
    def ai_lowpass_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 6146, val)

    @ai_lowpass_enable.deleter
    def ai_lowpass_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAILowpassEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lowpass_switch_cap_clk_src(self):
        """
        :class:`nidaqmx.constants.SourceSelection`: Specifies the source
            of the filter clock. If you need a higher resolution for the
            filter, you can supply an external clock to increase the
            resolution. Refer to the SCXI-1141/1142/1143 User Manual for
            more information.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6276)
        return SourceSelection(val)

    @ai_lowpass_switch_cap_clk_src.setter
    def ai_lowpass_switch_cap_clk_src(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6276, val)

    @ai_lowpass_switch_cap_clk_src.deleter
    def ai_lowpass_switch_cap_clk_src(self):
        cfunc = lib_importer.windll.DAQmxResetAILowpassSwitchCapClkSrc
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lowpass_switch_cap_ext_clk_div(self):
        """
        int: Specifies the divisor for the external clock when you set
            **ai_lowpass_switch_cap_clk_src** to
            **SourceSelection.EXTERNAL**. On the SCXI-1141, SCXI-1142,
            and SCXI-1143, NI-DAQmx determines the filter cutoff by
            using the equation f/(100*n), where f is the external
            frequency, and n is the external clock divisor. Refer to the
            SCXI-1141/1142/1143 User Manual for more information.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 6278)
        return val

    @ai_lowpass_switch_cap_ext_clk_div.setter
    def ai_lowpass_switch_cap_ext_clk_div(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 6278, val)

    @ai_lowpass_switch_cap_ext_clk_div.deleter
    def ai_lowpass_switch_cap_ext_clk_div(self):
        cfunc = lib_importer.windll.DAQmxResetAILowpassSwitchCapExtClkDiv
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lowpass_switch_cap_ext_clk_freq(self):
        """
        float: Specifies the frequency of the external clock when you
            set **ai_lowpass_switch_cap_clk_src** to
            **SourceSelection.EXTERNAL**.  NI-DAQmx uses this frequency
            to set the pre- and post- filters on the SCXI-1141,
            SCXI-1142, and SCXI-1143. On those devices, NI-DAQmx
            determines the filter cutoff by using the equation
            f/(100*n), where f is the external frequency, and n is the
            external clock divisor. Refer to the SCXI-1141/1142/1143
            User Manual for more information.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6277)
        return val

    @ai_lowpass_switch_cap_ext_clk_freq.setter
    def ai_lowpass_switch_cap_ext_clk_freq(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6277, val)

    @ai_lowpass_switch_cap_ext_clk_freq.deleter
    def ai_lowpass_switch_cap_ext_clk_freq(self):
        cfunc = lib_importer.windll.DAQmxResetAILowpassSwitchCapExtClkFreq
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lowpass_switch_cap_out_clk_div(self):
        """
        int: Specifies the divisor for the output clock.  NI-DAQmx uses
            the cutoff frequency to determine the output clock
            frequency. Refer to the SCXI-1141/1142/1143 User Manual for
            more information.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 6279)
        return val

    @ai_lowpass_switch_cap_out_clk_div.setter
    def ai_lowpass_switch_cap_out_clk_div(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 6279, val)

    @ai_lowpass_switch_cap_out_clk_div.deleter
    def ai_lowpass_switch_cap_out_clk_div(self):
        cfunc = lib_importer.windll.DAQmxResetAILowpassSwitchCapOutClkDiv
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lvdt_sensitivity(self):
        """
        float: Specifies the sensitivity of the LVDT. This value is in
            the units you specify with **ai_lvdt_sensitivity_units**.
            Refer to the sensor documentation to determine this value.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2361)
        return val

    @ai_lvdt_sensitivity.setter
    def ai_lvdt_sensitivity(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2361, val)

    @ai_lvdt_sensitivity.deleter
    def ai_lvdt_sensitivity(self):
        cfunc = lib_importer.windll.DAQmxResetAILVDTSensitivity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lvdt_sensitivity_units(self):
        """
        :class:`nidaqmx.constants.LVDTSensitivityUnits`: Specifies the
            units of **ai_lvdt_sensitivity**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8602)
        return LVDTSensitivityUnits(val)

    @ai_lvdt_sensitivity_units.setter
    def ai_lvdt_sensitivity_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8602, val)

    @ai_lvdt_sensitivity_units.deleter
    def ai_lvdt_sensitivity_units(self):
        cfunc = lib_importer.windll.DAQmxResetAILVDTSensitivityUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_lvdt_units(self):
        """
        :class:`nidaqmx.constants.LengthUnits`: Specifies the units to
            use to return linear position measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2320)
        return LengthUnits(val)

    @ai_lvdt_units.setter
    def ai_lvdt_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2320, val)

    @ai_lvdt_units.deleter
    def ai_lvdt_units(self):
        cfunc = lib_importer.windll.DAQmxResetAILVDTUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_max(self):
        """
        float: Specifies the maximum value you expect to measure. This
            value is in the units you specify with a units property.
            When you query this property, it returns the coerced maximum
            value that the device can measure with the current settings.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6109)
        return val

    @ai_max.setter
    def ai_max(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6109, val)

    @ai_max.deleter
    def ai_max(self):
        cfunc = lib_importer.windll.DAQmxResetAIMax
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_meas_type(self):
        """
        :class:`nidaqmx.constants.UsageTypeAI`: Indicates the
            measurement to take with the analog input channel and in
            some cases, such as for temperature measurements, the sensor
            to use.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 1685)
        return UsageTypeAI(val)

    @property
    def ai_mem_map_enable(self):
        """
        bool: Specifies for NI-DAQmx to map hardware registers to the
            memory space of the application, if possible. Normally, NI-
            DAQmx maps hardware registers to memory accessible only to
            the kernel. Mapping the registers to the memory space of the
            application increases performance. However, if the
            application accesses the memory space mapped to the
            registers, it can adversely affect the operation of the
            device and possibly result in a system crash.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 6284)
        return val

    @ai_mem_map_enable.setter
    def ai_mem_map_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 6284, val)

    @ai_mem_map_enable.deleter
    def ai_mem_map_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIMemMapEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_microphone_sensitivity(self):
        """
        float: Specifies the sensitivity of the microphone. This value
            is in mV/Pa. Refer to the sensor documentation to determine
            this value.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 5430)
        return val

    @ai_microphone_sensitivity.setter
    def ai_microphone_sensitivity(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 5430, val)

    @ai_microphone_sensitivity.deleter
    def ai_microphone_sensitivity(self):
        cfunc = lib_importer.windll.DAQmxResetAIMicrophoneSensitivity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_min(self):
        """
        float: Specifies the minimum value you expect to measure. This
            value is in the units you specify with a units property.
            When you query this property, it returns the coerced minimum
            value that the device can measure with the current settings.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6110)
        return val

    @ai_min.setter
    def ai_min(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6110, val)

    @ai_min.deleter
    def ai_min(self):
        cfunc = lib_importer.windll.DAQmxResetAIMin
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_open_chan_detect_enable(self):
        """
        bool: Specifies whether to enable open channel detection.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12543)
        return val

    @ai_open_chan_detect_enable.setter
    def ai_open_chan_detect_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12543, val)

    @ai_open_chan_detect_enable.deleter
    def ai_open_chan_detect_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIOpenChanDetectEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_open_thrmcpl_detect_enable(self):
        """
        bool: Specifies whether to apply the open thermocouple detection
            bias voltage to the channel. Changing the value of this
            property on a channel may require settling time before the
            data returned is valid. To compensate for this settling
            time, discard unsettled data or add a delay between
            committing and starting the task. Refer to your device
            specifications for the required settling time. When open
            thermocouple detection is enabled, use
            **open_thrmcpl_chans_exist** to determine if any channels
            were open.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12146)
        return val

    @ai_open_thrmcpl_detect_enable.setter
    def ai_open_thrmcpl_detect_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12146, val)

    @ai_open_thrmcpl_detect_enable.deleter
    def ai_open_thrmcpl_detect_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIOpenThrmcplDetectEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_overcurrent_detect_enable(self):
        """
        bool: Specifies whether to enable overcurrent detection.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12692)
        return val

    @ai_overcurrent_detect_enable.setter
    def ai_overcurrent_detect_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12692, val)

    @ai_overcurrent_detect_enable.deleter
    def ai_overcurrent_detect_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIOvercurrentDetectEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_power_supply_fault_detect_enable(self):
        """
        bool: Specifies whether to enable power supply fault detection.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12689)
        return val

    @ai_power_supply_fault_detect_enable.setter
    def ai_power_supply_fault_detect_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12689, val)

    @ai_power_supply_fault_detect_enable.deleter
    def ai_power_supply_fault_detect_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAIPowerSupplyFaultDetectEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_pressure_units(self):
        """
        :class:`nidaqmx.constants.PressureUnits`: Specifies  in which
            unit to return pressure measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12150)
        return PressureUnits(val)

    @ai_pressure_units.setter
    def ai_pressure_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12150, val)

    @ai_pressure_units.deleter
    def ai_pressure_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIPressureUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_probe_atten(self):
        """
        float: Specifies the amount of attenuation provided by the probe
            connected to the channel. Specify this attenuation as a
            ratio.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10888)
        return val

    @ai_probe_atten.setter
    def ai_probe_atten(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10888, val)

    @ai_probe_atten.deleter
    def ai_probe_atten(self):
        cfunc = lib_importer.windll.DAQmxResetAIProbeAtten
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_raw_data_compression_type(self):
        """
        :class:`nidaqmx.constants.RawDataCompressionType`: Specifies the
            type of compression to apply to raw samples returned from
            the device.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8920)
        return RawDataCompressionType(val)

    @ai_raw_data_compression_type.setter
    def ai_raw_data_compression_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8920, val)

    @ai_raw_data_compression_type.deleter
    def ai_raw_data_compression_type(self):
        cfunc = lib_importer.windll.DAQmxResetAIRawDataCompressionType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_raw_samp_justification(self):
        """
        :class:`nidaqmx.constants.DataJustification`: Indicates the
            justification of a raw sample from the device.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 80)
        return DataJustification(val)

    @property
    def ai_raw_samp_size(self):
        """
        int: Indicates in bits the size of a raw sample from the device.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 8922)
        return val

    @property
    def ai_remove_filter_delay(self):
        """
        bool: Specifies if filter delay removal is enabled on the
            device.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12221)
        return val

    @ai_remove_filter_delay.setter
    def ai_remove_filter_delay(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12221, val)

    @ai_remove_filter_delay.deleter
    def ai_remove_filter_delay(self):
        cfunc = lib_importer.windll.DAQmxResetAIRemoveFilterDelay
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_resistance_cfg(self):
        """
        :class:`nidaqmx.constants.ResistanceConfiguration`: Specifies
            the resistance configuration for the channel. NI-DAQmx uses
            this value for any resistance-based measurements, including
            temperature measurement using a thermistor or RTD.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6273)
        return ResistanceConfiguration(val)

    @ai_resistance_cfg.setter
    def ai_resistance_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6273, val)

    @ai_resistance_cfg.deleter
    def ai_resistance_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetAIResistanceCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_resistance_units(self):
        """
        :class:`nidaqmx.constants.ResistanceUnits`: Specifies the units
            to use to return resistance measurements.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2389)
        return ResistanceUnits(val)

    @ai_resistance_units.setter
    def ai_resistance_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2389, val)

    @ai_resistance_units.deleter
    def ai_resistance_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIResistanceUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_resolution(self):
        """
        float: Indicates the resolution of the analog-to-digital
            converter of the channel. This value is in the units you
            specify with **ai_resolution_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 5989)
        return val

    @property
    def ai_resolution_units(self):
        """
        :class:`nidaqmx.constants.ResolutionType`: Indicates the units
            of **ai_resolution**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 5988)
        return ResolutionType(val)

    @property
    def ai_rng_high(self):
        """
        float: Specifies the upper limit of the input range of the
            device. This value is in the native units of the device. On
            E Series devices, for example, the native units is volts.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6165)
        return val

    @ai_rng_high.setter
    def ai_rng_high(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6165, val)

    @ai_rng_high.deleter
    def ai_rng_high(self):
        cfunc = lib_importer.windll.DAQmxResetAIRngHigh
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rng_low(self):
        """
        float: Specifies the lower limit of the input range of the
            device. This value is in the native units of the device. On
            E Series devices, for example, the native units is volts.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6166)
        return val

    @ai_rng_low.setter
    def ai_rng_low(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6166, val)

    @ai_rng_low.deleter
    def ai_rng_low(self):
        cfunc = lib_importer.windll.DAQmxResetAIRngLow
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rosette_strain_gage_gage_orientation(self):
        """
        float: Specifies gage orientation in degrees with respect to the
            X axis.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12284)
        return val

    @ai_rosette_strain_gage_gage_orientation.setter
    def ai_rosette_strain_gage_gage_orientation(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12284, val)

    @ai_rosette_strain_gage_gage_orientation.deleter
    def ai_rosette_strain_gage_gage_orientation(self):
        cfunc = lib_importer.windll.DAQmxResetAIRosetteStrainGageOrientation
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rosette_strain_gage_rosette_meas_type(self):
        """
        :class:`nidaqmx.constants.StrainGageRosetteMeasurementType`:
            Specifies the type of rosette measurement.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12285)
        return StrainGageRosetteMeasurementType(val)

    @ai_rosette_strain_gage_rosette_meas_type.setter
    def ai_rosette_strain_gage_rosette_meas_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12285, val)

    @ai_rosette_strain_gage_rosette_meas_type.deleter
    def ai_rosette_strain_gage_rosette_meas_type(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIRosetteStrainGageRosetteMeasType)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rosette_strain_gage_rosette_type(self):
        """
        :class:`nidaqmx.constants.StrainGageRosetteType`: Indicates the
            type of rosette gage.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12286)
        return StrainGageRosetteType(val)

    @property
    def ai_rosette_strain_gage_strain_chans(self):
        """
        List[str]: Indicates the raw strain channels that comprise the
            strain rosette.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 12283)
        return unflatten_channel_string(val)

    @property
    def ai_rtd_a(self):
        """
        float: Specifies the 'A' constant of the Callendar-Van Dusen
            equation. NI-DAQmx requires this value when you use a custom
            RTD.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 4112)
        return val

    @ai_rtd_a.setter
    def ai_rtd_a(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 4112, val)

    @ai_rtd_a.deleter
    def ai_rtd_a(self):
        cfunc = lib_importer.windll.DAQmxResetAIRTDA
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rtd_b(self):
        """
        float: Specifies the 'B' constant of the Callendar-Van Dusen
            equation. NI-DAQmx requires this value when you use a custom
            RTD.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 4113)
        return val

    @ai_rtd_b.setter
    def ai_rtd_b(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 4113, val)

    @ai_rtd_b.deleter
    def ai_rtd_b(self):
        cfunc = lib_importer.windll.DAQmxResetAIRTDB
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rtd_c(self):
        """
        float: Specifies the 'C' constant of the Callendar-Van Dusen
            equation. NI-DAQmx requires this value when you use a custom
            RTD.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 4115)
        return val

    @ai_rtd_c.setter
    def ai_rtd_c(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 4115, val)

    @ai_rtd_c.deleter
    def ai_rtd_c(self):
        cfunc = lib_importer.windll.DAQmxResetAIRTDC
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rtd_r0(self):
        """
        float: Specifies in ohms the sensor resistance at 0 deg C. The
            Callendar-Van Dusen equation requires this value. Refer to
            the sensor documentation to determine this value.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 4144)
        return val

    @ai_rtd_r0.setter
    def ai_rtd_r0(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 4144, val)

    @ai_rtd_r0.deleter
    def ai_rtd_r0(self):
        cfunc = lib_importer.windll.DAQmxResetAIRTDR0
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rtd_type(self):
        """
        :class:`nidaqmx.constants.RTDType`: Specifies the type of RTD
            connected to the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4146)
        return RTDType(val)

    @ai_rtd_type.setter
    def ai_rtd_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 4146, val)

    @ai_rtd_type.deleter
    def ai_rtd_type(self):
        cfunc = lib_importer.windll.DAQmxResetAIRTDType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rvdt_sensitivity(self):
        """
        float: Specifies the sensitivity of the RVDT. This value is in
            the units you specify with **ai_rvdt_sensitivity_units**.
            Refer to the sensor documentation to determine this value.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2307)
        return val

    @ai_rvdt_sensitivity.setter
    def ai_rvdt_sensitivity(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2307, val)

    @ai_rvdt_sensitivity.deleter
    def ai_rvdt_sensitivity(self):
        cfunc = lib_importer.windll.DAQmxResetAIRVDTSensitivity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rvdt_sensitivity_units(self):
        """
        :class:`nidaqmx.constants.RVDTSensitivityUnits`: Specifies the
            units of **ai_rvdt_sensitivity**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 8603)
        return RVDTSensitivityUnits(val)

    @ai_rvdt_sensitivity_units.setter
    def ai_rvdt_sensitivity_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 8603, val)

    @ai_rvdt_sensitivity_units.deleter
    def ai_rvdt_sensitivity_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIRVDTSensitivityUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_rvdt_units(self):
        """
        :class:`nidaqmx.constants.AngleUnits`: Specifies the units to
            use to return angular position measurements from the
            channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2167)
        return AngleUnits(val)

    @ai_rvdt_units.setter
    def ai_rvdt_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2167, val)

    @ai_rvdt_units.deleter
    def ai_rvdt_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIRVDTUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_samp_and_hold_enable(self):
        """
        bool: Specifies whether to enable the sample and hold circuitry
            of the device. When you disable sample and hold circuitry, a
            small voltage offset might be introduced into the signal.
            You can eliminate this offset by using **ai_auto_zero_mode**
            to perform an auto zero on the channel.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 6170)
        return val

    @ai_samp_and_hold_enable.setter
    def ai_samp_and_hold_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 6170, val)

    @ai_samp_and_hold_enable.deleter
    def ai_samp_and_hold_enable(self):
        cfunc = lib_importer.windll.DAQmxResetAISampAndHoldEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_sensor_power_cfg(self):
        """
        :class:`nidaqmx.constants.SensorPowerCfg`: Specifies whether to
            turn on the sensor's power supply or to leave the
            configuration unchanged.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12650)
        return SensorPowerCfg(val)

    @ai_sensor_power_cfg.setter
    def ai_sensor_power_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12650, val)

    @ai_sensor_power_cfg.deleter
    def ai_sensor_power_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetAISensorPowerCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_sensor_power_type(self):
        """
        :class:`nidaqmx.constants.SensorPowerType`: Specifies the type
            of power supplied to the sensor.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12651)
        return SensorPowerType(val)

    @ai_sensor_power_type.setter
    def ai_sensor_power_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12651, val)

    @ai_sensor_power_type.deleter
    def ai_sensor_power_type(self):
        cfunc = lib_importer.windll.DAQmxResetAISensorPowerType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_sensor_power_voltage(self):
        """
        float: Specifies the voltage level for the sensor's power
            supply.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12649)
        return val

    @ai_sensor_power_voltage.setter
    def ai_sensor_power_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12649, val)

    @ai_sensor_power_voltage.deleter
    def ai_sensor_power_voltage(self):
        cfunc = lib_importer.windll.DAQmxResetAISensorPowerVoltage
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_sound_pressure_db_ref(self):
        """
        float: Specifies the decibel reference level in the units of the
            channel. When you read samples as a waveform, the decibel
            reference level is included in the waveform attributes. NI-
            DAQmx also uses the decibel reference level when converting
            **ai_sound_pressure_max_sound_pressure_lvl** to a voltage
            level.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10673)
        return val

    @ai_sound_pressure_db_ref.setter
    def ai_sound_pressure_db_ref(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10673, val)

    @ai_sound_pressure_db_ref.deleter
    def ai_sound_pressure_db_ref(self):
        cfunc = lib_importer.windll.DAQmxResetAISoundPressuredBRef
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_sound_pressure_max_sound_pressure_lvl(self):
        """
        float: Specifies the maximum instantaneous sound pressure level
            you expect to measure. This value is in decibels, referenced
            to 20 micropascals. NI-DAQmx uses the maximum sound pressure
            level to calculate values in pascals for **ai_max** and
            **ai_min** for the channel.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 8762)
        return val

    @ai_sound_pressure_max_sound_pressure_lvl.setter
    def ai_sound_pressure_max_sound_pressure_lvl(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 8762, val)

    @ai_sound_pressure_max_sound_pressure_lvl.deleter
    def ai_sound_pressure_max_sound_pressure_lvl(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAISoundPressureMaxSoundPressureLvl)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_sound_pressure_units(self):
        """
        :class:`nidaqmx.constants.SoundPressureUnits`: Specifies the
            units to use to return sound pressure measurements from the
            channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 5416)
        return SoundPressureUnits(val)

    @ai_sound_pressure_units.setter
    def ai_sound_pressure_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 5416, val)

    @ai_sound_pressure_units.deleter
    def ai_sound_pressure_units(self):
        cfunc = lib_importer.windll.DAQmxResetAISoundPressureUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_strain_force_read_from_chan(self):
        """
        bool: Specifies whether the data is returned by DAQmx Read when
            set on a raw strain channel that is part of a rosette
            configuration.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12282)
        return val

    @ai_strain_force_read_from_chan.setter
    def ai_strain_force_read_from_chan(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12282, val)

    @ai_strain_force_read_from_chan.deleter
    def ai_strain_force_read_from_chan(self):
        cfunc = lib_importer.windll.DAQmxResetAIStrainGageForceReadFromChan
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_strain_gage_cfg(self):
        """
        :class:`nidaqmx.constants.StrainGageBridgeType`: Specifies the
            bridge configuration of the strain gages.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2434)
        return StrainGageBridgeType(val)

    @ai_strain_gage_cfg.setter
    def ai_strain_gage_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2434, val)

    @ai_strain_gage_cfg.deleter
    def ai_strain_gage_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetAIStrainGageCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_strain_gage_gage_factor(self):
        """
        float: Specifies the sensitivity of the strain gage.  Gage
            factor relates the change in electrical resistance to the
            change in strain. Refer to the sensor documentation for this
            value.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2452)
        return val

    @ai_strain_gage_gage_factor.setter
    def ai_strain_gage_gage_factor(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2452, val)

    @ai_strain_gage_gage_factor.deleter
    def ai_strain_gage_gage_factor(self):
        cfunc = lib_importer.windll.DAQmxResetAIStrainGageGageFactor
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_strain_gage_poisson_ratio(self):
        """
        float: Specifies the ratio of lateral strain to axial strain in
            the material you are measuring.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 2456)
        return val

    @ai_strain_gage_poisson_ratio.setter
    def ai_strain_gage_poisson_ratio(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 2456, val)

    @ai_strain_gage_poisson_ratio.deleter
    def ai_strain_gage_poisson_ratio(self):
        cfunc = lib_importer.windll.DAQmxResetAIStrainGagePoissonRatio
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_strain_units(self):
        """
        :class:`nidaqmx.constants.StrainUnits`: Specifies the units to
            use to return strain measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 2433)
        return StrainUnits(val)

    @ai_strain_units.setter
    def ai_strain_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 2433, val)

    @ai_strain_units.deleter
    def ai_strain_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIStrainUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_teds_is_teds(self):
        """
        bool: Indicates if the virtual channel was initialized using a
            TEDS bitstream from the corresponding physical channel.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 10627)
        return val

    @property
    def ai_teds_units(self):
        """
        str: Indicates the units defined by TEDS information associated
            with the channel.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 8672)
        return val

    @property
    def ai_temp_units(self):
        """
        :class:`nidaqmx.constants.TemperatureUnits`: Specifies the units
            to use to return temperature measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4147)
        return TemperatureUnits(val)

    @ai_temp_units.setter
    def ai_temp_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 4147, val)

    @ai_temp_units.deleter
    def ai_temp_units(self):
        cfunc = lib_importer.windll.DAQmxResetAITempUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_term_cfg(self):
        """
        :class:`nidaqmx.constants.TerminalConfiguration`: Specifies the
            terminal configuration for the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4247)
        return TerminalConfiguration(val)

    @ai_term_cfg.setter
    def ai_term_cfg(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 4247, val)

    @ai_term_cfg.deleter
    def ai_term_cfg(self):
        cfunc = lib_importer.windll.DAQmxResetAITermCfg
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_thrmcpl_cjc_chan(self):
        """
        :class:`nidaqmx._task_modules.channels.channel.Channel`:
            Indicates the channel that acquires the temperature of the
            cold junction if **ai_thrmcpl_cjc_src** is
            **CJCSource1.SCANNABLE_CHANNEL**. If the channel is a
            temperature channel, NI-DAQmx acquires the temperature in
            the correct units. Other channel types, such as a resistance
            channel with a custom sensor, must use a custom scale to
            scale values to degrees Celsius.
        """


        val = self._interpreter.get_chan_attribute_string(
                self._handle, self._name, 4148)
        return Channel._factory(self._handle, val.value.decode('ascii'))

    @property
    def ai_thrmcpl_cjc_src(self):
        """
        :class:`nidaqmx.constants.CJCSource`: Indicates the source of
            cold-junction compensation.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4149)
        return CJCSource(val)

    @property
    def ai_thrmcpl_cjc_val(self):
        """
        float: Specifies the temperature of the cold junction if
            **ai_thrmcpl_cjc_src** is
            **CJCSource1.CONSTANT_USER_VALUE**. Specify this value in
            the units of the measurement.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 4150)
        return val

    @ai_thrmcpl_cjc_val.setter
    def ai_thrmcpl_cjc_val(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 4150, val)

    @ai_thrmcpl_cjc_val.deleter
    def ai_thrmcpl_cjc_val(self):
        cfunc = lib_importer.windll.DAQmxResetAIThrmcplCJCVal
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_thrmcpl_lead_offset_voltage(self):
        """
        float: Specifies the lead offset nulling voltage to subtract
            from measurements on a device. This property is ignored if
            open thermocouple detection is disabled.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12216)
        return val

    @ai_thrmcpl_lead_offset_voltage.setter
    def ai_thrmcpl_lead_offset_voltage(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12216, val)

    @ai_thrmcpl_lead_offset_voltage.deleter
    def ai_thrmcpl_lead_offset_voltage(self):
        cfunc = lib_importer.windll.DAQmxResetAIThrmcplLeadOffsetVoltage
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_thrmcpl_scale_type(self):
        """
        :class:`nidaqmx.constants.ScaleType`: Specifies the method or
            equation form that the thermocouple scale uses.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 10704)
        return ScaleType(val)

    @ai_thrmcpl_scale_type.setter
    def ai_thrmcpl_scale_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 10704, val)

    @ai_thrmcpl_scale_type.deleter
    def ai_thrmcpl_scale_type(self):
        cfunc = lib_importer.windll.DAQmxResetAIThrmcplScaleType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_thrmcpl_type(self):
        """
        :class:`nidaqmx.constants.ThermocoupleType`: Specifies the type
            of thermocouple connected to the channel. Thermocouple types
            differ in composition and measurement range.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4176)
        return ThermocoupleType(val)

    @ai_thrmcpl_type.setter
    def ai_thrmcpl_type(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 4176, val)

    @ai_thrmcpl_type.deleter
    def ai_thrmcpl_type(self):
        cfunc = lib_importer.windll.DAQmxResetAIThrmcplType
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_thrmstr_a(self):
        """
        float: Specifies the 'A' constant of the Steinhart-Hart
            thermistor equation.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6345)
        return val

    @ai_thrmstr_a.setter
    def ai_thrmstr_a(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6345, val)

    @ai_thrmstr_a.deleter
    def ai_thrmstr_a(self):
        cfunc = lib_importer.windll.DAQmxResetAIThrmstrA
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_thrmstr_b(self):
        """
        float: Specifies the 'B' constant of the Steinhart-Hart
            thermistor equation.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6347)
        return val

    @ai_thrmstr_b.setter
    def ai_thrmstr_b(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6347, val)

    @ai_thrmstr_b.deleter
    def ai_thrmstr_b(self):
        cfunc = lib_importer.windll.DAQmxResetAIThrmstrB
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_thrmstr_c(self):
        """
        float: Specifies the 'C' constant of the Steinhart-Hart
            thermistor equation.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 6346)
        return val

    @ai_thrmstr_c.setter
    def ai_thrmstr_c(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 6346, val)

    @ai_thrmstr_c.deleter
    def ai_thrmstr_c(self):
        cfunc = lib_importer.windll.DAQmxResetAIThrmstrC
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_thrmstr_r1(self):
        """
        float: Specifies in ohms the value of the reference resistor for
            the thermistor if you use voltage excitation. NI-DAQmx
            ignores this value for current excitation.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 4193)
        return val

    @ai_thrmstr_r1.setter
    def ai_thrmstr_r1(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 4193, val)

    @ai_thrmstr_r1.deleter
    def ai_thrmstr_r1(self):
        cfunc = lib_importer.windll.DAQmxResetAIThrmstrR1
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_torque_units(self):
        """
        :class:`nidaqmx.constants.TorqueUnits`: Specifies in which unit
            to return torque measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12151)
        return TorqueUnits(val)

    @ai_torque_units.setter
    def ai_torque_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12151, val)

    @ai_torque_units.deleter
    def ai_torque_units(self):
        cfunc = lib_importer.windll.DAQmxResetAITorqueUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_usb_xfer_req_count(self):
        """
        int: Specifies the maximum number of simultaneous USB transfers
            used to stream data. Modify this value to affect performance
            under different combinations of operating system and device.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 12288)
        return val

    @ai_usb_xfer_req_count.setter
    def ai_usb_xfer_req_count(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 12288, val)

    @ai_usb_xfer_req_count.deleter
    def ai_usb_xfer_req_count(self):
        cfunc = lib_importer.windll.DAQmxResetAIUsbXferReqCount
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_usb_xfer_req_size(self):
        """
        int: Specifies the maximum size of a USB transfer request in
            bytes. Modify this value to affect performance under
            different combinations of operating system and device.
        """


        val = self._interpreter.get_chan_attribute_uint32(
                self._handle, self._name, 10894)
        return val

    @ai_usb_xfer_req_size.setter
    def ai_usb_xfer_req_size(self, val):
        self._interpreter.set_chan_attribute_uint32(
                self._handle, self._name, 10894, val)

    @ai_usb_xfer_req_size.deleter
    def ai_usb_xfer_req_size(self):
        cfunc = lib_importer.windll.DAQmxResetAIUsbXferReqSize
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_velocity_iepe_sensor_db_ref(self):
        """
        float: Specifies the decibel reference level in the units of the
            channel. When you read samples as a waveform, the decibel
            reference level is included in the waveform attributes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12277)
        return val

    @ai_velocity_iepe_sensor_db_ref.setter
    def ai_velocity_iepe_sensor_db_ref(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12277, val)

    @ai_velocity_iepe_sensor_db_ref.deleter
    def ai_velocity_iepe_sensor_db_ref(self):
        cfunc = lib_importer.windll.DAQmxResetAIVelocityIEPESensordBRef
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_velocity_iepe_sensor_sensitivity(self):
        """
        float: Specifies the sensitivity of the IEPE velocity sensor
            connected to the channel. Specify this value in the unit
            indicated by **ai_velocity_iepe_sensor_sensitivity_units**.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12278)
        return val

    @ai_velocity_iepe_sensor_sensitivity.setter
    def ai_velocity_iepe_sensor_sensitivity(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12278, val)

    @ai_velocity_iepe_sensor_sensitivity.deleter
    def ai_velocity_iepe_sensor_sensitivity(self):
        cfunc = lib_importer.windll.DAQmxResetAIVelocityIEPESensorSensitivity
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_velocity_iepe_sensor_sensitivity_units(self):
        """
        :class:`nidaqmx.constants.VelocityIEPESensorSensitivityUnits`:
            Specifies the units for
            **ai_velocity_iepe_sensor_sensitivity**.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12279)
        return VelocityIEPESensorSensitivityUnits(val)

    @ai_velocity_iepe_sensor_sensitivity_units.setter
    def ai_velocity_iepe_sensor_sensitivity_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12279, val)

    @ai_velocity_iepe_sensor_sensitivity_units.deleter
    def ai_velocity_iepe_sensor_sensitivity_units(self):
        cfunc = (lib_importer.windll.
                 DAQmxResetAIVelocityIEPESensorSensitivityUnits)
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_velocity_units(self):
        """
        :class:`nidaqmx.constants.VelocityUnits`: Specifies in which
            unit to return velocity measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12276)
        return VelocityUnits(val)

    @ai_velocity_units.setter
    def ai_velocity_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12276, val)

    @ai_velocity_units.deleter
    def ai_velocity_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIVelocityUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_voltage_acrms_units(self):
        """
        :class:`nidaqmx.constants.VoltageUnits`: Specifies the units to
            use to return voltage RMS measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 6114)
        return VoltageUnits(val)

    @ai_voltage_acrms_units.setter
    def ai_voltage_acrms_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 6114, val)

    @ai_voltage_acrms_units.deleter
    def ai_voltage_acrms_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIVoltageACRMSUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_voltage_db_ref(self):
        """
        float: Specifies the decibel reference level in the units of the
            channel. When you read samples as a waveform, the decibel
            reference level is included in the waveform attributes.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 10672)
        return val

    @ai_voltage_db_ref.setter
    def ai_voltage_db_ref(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 10672, val)

    @ai_voltage_db_ref.deleter
    def ai_voltage_db_ref(self):
        cfunc = lib_importer.windll.DAQmxResetAIVoltagedBRef
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def ai_voltage_units(self):
        """
        :class:`nidaqmx.constants.VoltageUnits`: Specifies the units to
            use to return voltage measurements from the channel.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 4244)
        return VoltageUnits(val)

    @ai_voltage_units.setter
    def ai_voltage_units(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 4244, val)

    @ai_voltage_units.deleter
    def ai_voltage_units(self):
        cfunc = lib_importer.windll.DAQmxResetAIVoltageUnits
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def pwr_current_dev_scaling_coeff(self):
        """
        List[float]: Indicates the coefficients of the polynomial
            equation that NI-DAQmx uses to scale values from the native
            format of the device to amperes. Can be read at any time
            during a task.
        """


        val = self._interpreter.get_chan_attribute_double_array(
                self._handle, self._name, 12762)
        return val

    @property
    def pwr_current_setpoint(self):
        """
        float: Specifies the output current, in amperes. If the load
            draws current greater than the specified value, the device
            will operate in Constant Current mode.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12757)
        return val

    @pwr_current_setpoint.setter
    def pwr_current_setpoint(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12757, val)

    @pwr_current_setpoint.deleter
    def pwr_current_setpoint(self):
        cfunc = lib_importer.windll.DAQmxResetPwrCurrentSetpoint
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def pwr_idle_output_behavior(self):
        """
        :class:`nidaqmx.constants.PowerIdleOutputBehavior`: Specifies
            whether to disable the output or maintain the existing value
            after the task is uncommitted.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12760)
        return PowerIdleOutputBehavior(val)

    @pwr_idle_output_behavior.setter
    def pwr_idle_output_behavior(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12760, val)

    @pwr_idle_output_behavior.deleter
    def pwr_idle_output_behavior(self):
        cfunc = lib_importer.windll.DAQmxResetPwrIdleOutputBehavior
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def pwr_output_enable(self):
        """
        bool: Specifies whether to enable or disable power module
            output. Can be set while a task is running. Can be read at
            any time during a task. When a task is running, the output
            is enabled immediately. Otherwise, the output is not enabled
            until the task enters the Committed state.
        """


        val = self._interpreter.get_chan_attribute_bool(
                self._handle, self._name, 12758)
        return val

    @pwr_output_enable.setter
    def pwr_output_enable(self, val):
        self._interpreter.set_chan_attribute_bool(
                self._handle, self._name, 12758, val)

    @pwr_output_enable.deleter
    def pwr_output_enable(self):
        cfunc = lib_importer.windll.DAQmxResetPwrOutputEnable
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def pwr_output_state(self):
        """
        :class:`nidaqmx.constants.PowerOutputState`: Indicates power
            channel operating state. Can be read at any time during a
            task.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12759)
        return PowerOutputState(val)

    @property
    def pwr_remote_sense(self):
        """
        :class:`nidaqmx.constants.Sense`: Specifies whether to use local
            or remote sense to sense the output voltage. DAQmx Read
            (Power) will return remote or local voltage based on the
            Remote Sense attribute value. Reading this property will
            return the user-defined value.
        """


        val = self._interpreter.get_chan_attribute_int32(
                self._handle, self._name, 12763)
        return Sense(val)

    @pwr_remote_sense.setter
    def pwr_remote_sense(self, val):
        val = val.value
        self._interpreter.set_chan_attribute_int32(
                self._handle, self._name, 12763, val)

    @pwr_remote_sense.deleter
    def pwr_remote_sense(self):
        cfunc = lib_importer.windll.DAQmxResetPwrRemoteSense
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    def pwr_voltage_dev_scaling_coeff(self):
        """
        List[float]: Indicates the coefficients of the polynomial
            equation that NI-DAQmx uses to scale values from the native
            format of the device to volts. Can be read at any time
            during a task.
        """


        val = self._interpreter.get_chan_attribute_double_array(
                self._handle, self._name, 12761)
        return val

    @property
    def pwr_voltage_setpoint(self):
        """
        float: Specifies the constant output voltage, in volts. Can be
            set while a task is running. Can be read at any time during
            a task.
        """


        val = self._interpreter.get_chan_attribute_double(
                self._handle, self._name, 12756)
        return val

    @pwr_voltage_setpoint.setter
    def pwr_voltage_setpoint(self, val):
        self._interpreter.set_chan_attribute_double(
                self._handle, self._name, 12756, val)

    @pwr_voltage_setpoint.deleter
    def pwr_voltage_setpoint(self):
        cfunc = lib_importer.windll.DAQmxResetPwrVoltageSetpoint
        if cfunc.argtypes is None:
            with cfunc.arglock:
                if cfunc.argtypes is None:
                    cfunc.argtypes = [
                        lib_importer.task_handle, ctypes_byte_str]

        error_code = cfunc(
            self._handle, self._name)
        check_for_error(error_code)

    @property
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_rtd_r0 instead.")
    def ai_rtd_r_0(self):
        return self.ai_rtd_r0

    @ai_rtd_r_0.setter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_rtd_r0 instead.")
    def ai_rtd_r_0(self, val):
        self.ai_rtd_r0 = val

    @ai_rtd_r_0.deleter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_rtd_r0 instead.")
    def ai_rtd_r_0(self):
        del self.ai_rtd_r0

    @property
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_sound_pressure_db_ref instead.")
    def ai_sound_pressured_b_ref(self):
        return self.ai_sound_pressure_db_ref

    @ai_sound_pressured_b_ref.setter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_sound_pressure_db_ref instead.")
    def ai_sound_pressured_b_ref(self, val):
        self.ai_sound_pressure_db_ref = val

    @ai_sound_pressured_b_ref.deleter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_sound_pressure_db_ref instead.")
    def ai_sound_pressured_b_ref(self):
        del self.ai_sound_pressure_db_ref

    @property
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_thrmstr_r1 instead.")
    def ai_thrmstr_r_1(self):
        return self.ai_thrmstr_r1

    @ai_thrmstr_r_1.setter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_thrmstr_r1 instead.")
    def ai_thrmstr_r_1(self, val):
        self.ai_thrmstr_r1 = val

    @ai_thrmstr_r_1.deleter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_thrmstr_r1 instead.")
    def ai_thrmstr_r_1(self):
        del self.ai_thrmstr_r1

    @property
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_accel_db_ref instead.")
    def ai_acceld_b_ref(self):
        return self.ai_accel_db_ref

    @ai_acceld_b_ref.setter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_accel_db_ref instead.")
    def ai_acceld_b_ref(self, val):
        self.ai_accel_db_ref = val

    @ai_acceld_b_ref.deleter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_accel_db_ref instead.")
    def ai_acceld_b_ref(self):
        del self.ai_accel_db_ref

    @property
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_voltage_db_ref instead.")
    def ai_voltaged_b_ref(self):
        return self.ai_voltage_db_ref

    @ai_voltaged_b_ref.setter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_voltage_db_ref instead.")
    def ai_voltaged_b_ref(self, val):
        self.ai_voltage_db_ref = val

    @ai_voltaged_b_ref.deleter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_voltage_db_ref instead.")
    def ai_voltaged_b_ref(self):
        del self.ai_voltage_db_ref

    @property
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_velocity_iepe_sensor_db_ref instead.")
    def ai_velocity_iepe_sensord_b_ref(self):
        return self.ai_velocity_iepe_sensor_db_ref

    @ai_velocity_iepe_sensord_b_ref.setter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_velocity_iepe_sensor_db_ref instead.")
    def ai_velocity_iepe_sensord_b_ref(self, val):
        self.ai_velocity_iepe_sensor_db_ref = val

    @ai_velocity_iepe_sensord_b_ref.deleter
    @deprecation.deprecated(deprecated_in="0.7.0", details="Use ai_velocity_iepe_sensor_db_ref instead.")
    def ai_velocity_iepe_sensord_b_ref(self):
        del self.ai_velocity_iepe_sensor_db_ref

